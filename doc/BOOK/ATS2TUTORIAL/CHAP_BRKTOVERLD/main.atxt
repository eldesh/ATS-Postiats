%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/ats2tutorial.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="bracket-overload">
#langeng("
#title("Bracket Overloading")
")
#langja("
#title("角括弧オーバーロード")
")

#langeng("
#para('\

In many programming languages, bracket-notation is commonly associated
with array subscripting. For instance, #dyncode("A[i]") is a left-value
in C that refers to array-cell #dyncode("i") in the array referred to by
#dyncode("A").  There is support in ATS for overloading brackets with
multiple function names so that bracket-notation can be employed to call
these functions, resulting in code that reads like some form of subscripting.
It is expected that this style of calling functions can, sometimes, make
the code written in ATS more easily accessible.\

')#comment("para")
")
#langja("
#para('\

多くのプログラミング言語では、角括弧表記は一般に配列の添字を連想させます。例えば、#dyncode("A[i]") はC言語における左辺値で、#dyncode("A") によって参照された配列の配列セル #dyncode("i") を示しています。ATS では、角括弧表記で複数の関数を呼び出せるようにその複数の関数名で角括弧をオーバーロードすることができます。その結果、添字アクセスのような見た目のコードになります。このスタイルの関数呼び出しは、ときに、ATS で書かれたコードをより読み易いものにするでしょう。\

')#comment("para")
")

#langeng("
#para('\

Let us now see a simple example of bracket-notation in overloading.
In the followng code, a linear abstract type #dyncode("lock") is
introduced together with two functions:

#dats2xhtml('\
//
absvtype lock(a:vt@ype)
//
extern
fun{a:vt0p} lock_acquire(!lock(a)): a
extern
fun{a:vt0p} lock_release(!lock(a), a): void
//
')#comment("dats2xhtml")

As one can imagine, #dyncode("lock_acquire") is called to obtain the value
stored in a given lock while #dyncode("lock_release") is called to return a
value to a given lock.\

')#comment("para")
")
#langja("
#para('\

ここで、角括弧オーバーロードの単純な例を見てみましょう。次のコードでは、線形抽象型 #dyncode("lock") が2つの関数と共に導入されています:

#dats2xhtml('\
//
absvtype lock(a:vt@ype)
//
extern
fun{a:vt0p} lock_acquire(!lock(a)): a
extern
fun{a:vt0p} lock_release(!lock(a), a): void
//
')#comment("atscode")

想像できるように、#dyncode("lock_acquire") は与えられたロック中に保管された値を得るために呼び出され、#dyncode("lock_release") 与えられたロックに値を戻すために呼び出されます。\

')#comment("para")
")

#langeng("
#para('\

Suppose that we now introduce the following overloading declarations:

#sats2xhtml('\
//
overload [] with lock_acquire
overload [] with lock_release
//
')#comment("sats2xhtml")

With these declarations, the following code typechecks:

#dats2xhtml('\
//
val
mylock = $extval(lock(int), "mylock")
//
val x0 = mylock[] // = lock_acquire (mylock)
val () = mylock[] := x0 // = lock_release (mylock, x0)
//
')#comment("dats2xhtml")

Note that the bracket-notation in any assigement is only allowed to
refer to a function that returns the void-value. In the above example, the
function #dyncode("lock_release") returns the void-value.\

')#comment("para")
")
#langja("
#para('\

ここで、次のオーバーロード宣言を導入することを想像してみましょう:

#sats2xhtml('\
//
overload [] with lock_acquire
overload [] with lock_release
//
')#comment("atscode")

この宣言の後で次のコードを型検査を通ります:

#dats2xhtml('\
//
val
mylock = $extval(lock(int), "mylock")
//
val x0 = mylock[] // = lock_acquire (myclok)
val () = mylock[] := x0 // = lock_release (myclok, x0)
//
')#comment("atscode")

代入における角括弧表記は void 値を返す関数のみ参照できることに注意してください。上記の例では、関数 #dyncode("lock_release") は void 値を返します。\

')#comment("para")
")

#langeng("
#para('\

In ATS, bracket-notation is already overloaded with functions performing
list-subscripting, array-subscripting and matrix-subscripting, and it can
also be used to access and update a given reference.\

')#comment("para")
")
#langja("
#para('\

ATS では、角括弧表記は既にリストの添字指定、配列の添字指定、行列の添字指定の関数でオーバーロードされています。そしてそれは与えれた参照にアクセス/更新するためにも使われます。\

')#comment("para")
")

#langeng("
#para("\

Please find #mycodelink("chap_brktoverld.dats", "on-line") the entirety of the
code presented in this chapter.\

")#comment("para")
")
#langja("
#para("\

この章で示したコードの全体は #mycodelink("chap_brktoverld.dats", "オンライン") から入手できます。\

")#comment("para")
")

</chapter><!--"bracket-overload"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
