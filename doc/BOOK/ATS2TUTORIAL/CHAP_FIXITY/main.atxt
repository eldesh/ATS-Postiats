%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/ats2tutorial.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="fixity">
#langeng("
#title("Fixity Declarations")
")
#langja("
#title("結合性宣言")
")

#langeng("
#para("\

Given a function #emphasis("f"), the standard syntax for applying
#emphasis("f") to an argument #emphasis("v") is #emphasis("f(v)"); for two
arguments #emphasis("v1") and #emphasis("v2"), the syntax is
#emphasis("f(v1, v2)"). Also, it is allowed in ATS to use infix notation
for a binary function application, and prefix/postifix notation for a unary
function application.\

")
")
#langja("
#para("\

関数 #emphasis("f") が与えられたとき、#emphasis("f") を引数 #emphasis("v") に適用する標準的な構文は #emphasis("f(v)") です;
2つの引数 #emphasis("v1") と #emphasis("v2") に適用する構文は #emphasis("f(v1, v2)") です。
また、引数が2つの関数適用のための中置記法と、引数が1つの関数適用のための前置/後置記法が
ATS では許されています。\

")
")

#langeng("
#para("\

Each identifier in ATS can be assigned one of the following fixities:
#emphasis("prefix"), #emphasis("infix") and #emphasis("postfix").  The
fixity declarations for many commonly used identifiers can be found in
#myatscodelink("prelude/fixity.ats", "prelude/fixity.ats").  Often, the
name #emphasis("operator") is used to refer to an identifier that is
assigned a fixity. For instance, the following syntax declares that
#dyncode("+") and #dyncode("-") are infix operators of a precedence value
equal to 50:

#sats2xhtml("\
infixl 50 + -
")

After this declaration, we can write an expression like #dyncode("1 + 2 -
3"), which is parsed into #dyncode("-(+(1, 2), 3)") in terms of the
standard syntax for function application.\

")#comment("para")
")
#langja("
#para("\

ATS におけるそれぞれの識別子には次の結合性の内1つを割り当てることができます:
#emphasis("前置 (prefix)"), #emphasis("中置 (infix)"), #emphasis("後置 (postfix)") です。
多くの一般に使われる識別子の結合性宣言を
#myatscodelink("prelude/fixity.ats", "prelude/fixity.ats")
から見ることができます。
しばしば、結合性が割り当てられた識別子を #emphasis("演算子") と呼びます。
例えば、次の構文で宣言している #dyncode("+") と #dyncode("-") は優先順位 50 の中置演算子です:

#sats2xhtml("\
infixl 50 + -
")

この宣言によって、#dyncode("1 + 2 - 3") のような式を書くことができます。
この式は、標準的な関数適用構文の観点から #dyncode("-(+(1, 2), 3)") のように構文解析されます。\

")#comment("para")
")

#langeng("
#para("\

The keyword #dyncode("infixl") indicates that the declared infix operators
are left-associative. For right-associative and non-associative infix
operators, please use the keywords #dyncode("infixr") and
#dyncode("infix"), respectively. If the precedence value is omitted in a
fixity declaration, it is assumed to be equal to 0.\

")
")
#langja("
#para("\

キーワード #dyncode("infixl") は宣言した中置演算子が左結合であることを示しています。
右結合と無結合の中置演算子には、それぞれキーワード #dyncode("infixr") と #dyncode("infix") を使ってください。
もし結合性宣言の優先順位を省略した場合、0 であると見做されます。\

")
")

#langeng("
#para("\

We can also use the following syntax to declare that #dyncode("iadd"),
#dyncode("fadd"), #dyncode("padd") and #dyncode("uadd") are
left-associative infix operators with a precedence value equal to that of
the operator #dyncode("+"):

#sats2xhtml("\
infixl (+) iadd fadd padd uadd
")

This is useful as it is difficult in practice to remember the precedence
values of (a large collection of) declared operators. Sometimes, we may
need to specify that the precedence value of one operator in relation to
that of another one. For instance, the following syntax declares that
#dyncode("opr2") is a left-associative infix operator and its precedence
value is that of #dyncode("opr1") plus 10:

#sats2xhtml("\
infixl (opr1 + 10) opr2
")

If the plus sign (+) is changed to the minus sign (-), then the precedence
value of #dyncode("opr2") is that of #dyncode("opr1") minus 10.\

")#comment("para")
")
#langja("
#para("\

また、#dyncode("iadd"), #dyncode("fadd"), #dyncode("padd"), #dyncode("uadd")
が #dyncode("+") 演算子と等しい優先順位を持つ左結合中置演算子であることを宣言するのに次の構文を使うことができます:

#sats2xhtml("\
infixl (+) iadd fadd padd uadd
")

これは数多く宣言された演算子の優先順位を思い出すのが困難な場面で実際に有用です。
ときには、演算子の優先順位をもう一つの演算子の優先順位と関連を持たせて指定したくなることがあります。
例えば、次の構文は #dyncode("opr2") が左結合中置演算子で、その優先順位は #dyncode("opr1")
の優先順位に 10 加えたものであると宣言しています:

#sats2xhtml("\
infixl (opr1 + 10) opr2
")

もしプラス記号 (+) をマイナス記号 (-) に変えると、#dyncode("opr2")
の優先順位は #dyncode("opr1") の優先順位から 10 減じたものになります。\

")#comment("para")
")

#langeng("
#para("\

We can also turn an identifier #dyncode("opr") into a non-associative infix
operator (of precedence value 0) by putting the backslash symbol
(#dyncode("\\\\")) in front of it. For instance, the expression
#dyncode("exp1 \\\\opr exp2") stands for #dyncode("opr (exp1, exp2)"),
where #dyncode("exp1") and #dyncode("exp2") refer to some expressions,
either static or dynamic.\

")
")
#langja("
#para("\

また、識別子 #dyncode("opr") の前にバックスラッシュ記号 (#dyncode("\\\\"))
を付けると、優先順位 0 の無結合中置演算子にすることもできます。
例えば、式 #dyncode("exp1 \\\\opr exp2") は #dyncode("opr (exp1, exp2)")
を表わします。
このとき、#dyncode("exp1") と #dyncode("exp2") はなんらかの静的もしくは動的な式です。\

")
")

#langeng("
#para("\

The syntax for declaring (unary) prefix and postfix operators are
similar. For instance, the following syntax declares that #dyncode("~") and
#dyncode("?") are prefix and postfix operators of precedence values 61 and 69,
respectively:

#sats2xhtml("\
prefix 61 ~
postfix 69 ?
")

As an example, a postfix operator is involved in the following 3-line
program:

#dats2xhtml('\
postfix (imul + 10) !!
extern fun !! (x: int): int
implement !! (x) = if x >= 2 then x * (x - 2)!! else 1
')

")#comment("para")
")
#langja("
#para("\

(引数が1つの) 前置演算子と後置演算子を宣言する構文は同じです。
例えば、次の構文は #dyncode("~") と #dyncode("?") をそれぞれ優先順位
61 の前置演算子と、優先順位 69 の後置演算子として宣言しています:

#sats2xhtml("\
prefix 61 ~
postfix 69 ?
")

例として、次の3行プログラムでは後置演算子を使っています:

#dats2xhtml('\
postfix (imul + 10) !!
extern fun !! (x: int): int
implement !! (x) = if x >= 2 then x * (x - 2)!! else 1
')

")#comment("para")
")

#langeng("
#para("\

For a given occurrence of an operator, we can deprive it of its assigned
fixity status by simply putting the keyword #dyncode("op") in front of
it. For instance #dyncode("1 + 2 - 3") can be writen as #dyncode("op- (op+
(1, 2), 3)").  It is also possible to (permanently) deprive an operator of
its assigned fixity status.  For instance, the following syntax does so to
the operators #dyncode("iadd"), #dyncode("fadd"), #dyncode("padd") and
#dyncode("uadd"):

#sats2xhtml('nonfix iadd fadd padd uadd')

Note that #dyncode("nonfix") is a keyword in ATS.

")#comment("para")
")
#langja("
#para("\

演算子の前にキーワード #dyncode("op")
を単純に付けることで、その演算子に割り当てられた結合性設定を無効化することができます。
例えば、#dyncode("1 + 2 - 3") は #dyncode("op- (op+ (1, 2), 3)") のように書くことができます。
また、演算子に割り当てられた結合性設定を (永久に)
無効化することも可能です。
例えば、次の構文は演算子
#dyncode("iadd"), #dyncode("fadd"), #dyncode("padd"), #dyncode("uadd")
に対して結合性設定を無効化します:

#sats2xhtml('nonfix iadd fadd padd uadd')

#dyncode("nonfix") は ATS のキーワードであることに注意してください。

")#comment("para")
")

#langeng("
#para("\

Lastly, please note that each fixity declaration is only effective within
its own legal scope.

")
")
#langja("
#para("\

最後に、それぞれの結合性宣言はそのスコープ内でのみ効力を持つことに注意してください。

")
")

</chapter><!--"fixity"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
