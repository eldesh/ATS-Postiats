%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="introduction-to-views-and-viewtypes">
#langeng("
#title("Introduction to Views and Viewtypes")
")
#langja("
#title("観 (view) と観型入門")
")

<!-- ****** ****** -->

#langeng("
#para('\

Probably the single greatest motivation behind the development of ATS is
the desire to make ATS a programming language that can be employed
effectively to construct safe and reliable programs running in the kernels
of operating systems. Instead of following seemingly natural approaches
that often focus on carving out a "safe" subset of C and/or put wrappers
around "unsafe" programming features in C, ATS relies on the paradigm of
programming with theorem-proving to prevent resources such as memory from
being misused or mismanaged, advocating an approach to safety that is both
general and flexible. For example, a well-typed program constructed in ATS
cannot cause buffer overrun at run-time even though pointer arithmetic is
fully supported in ATS. More specifically, if a pointer is to be
dereferenced, ATS requires that a proof be given attesting to the safety of
the dereferencing operation. Proofs of this kind are constructed to
demonstrate the validity of linear propositions, which are referred to as
views in ATS, for classifying resources as well as capabilities.

')#comment("para")
")
#langja("
#para('\

おそらく、ATS 開発の背後にある最も大きな動機は、ATS
をオペレーティングシステムのカーネルの中で実行される安全で信頼できるプログラムを効果的に構築できるようなプログラミング言語にしたいという要求です。
一見したところ自然なアプローチは、C言語の "安全な"
サブセットを苦心して作り上げることに集中したり、C言語の "安全でない"
プログラミングの機能のラッパーを作ったりすることでしょう。
このようなアプローチの代わりに、ATS は定理証明によるプログラミングのパラダイムを信頼しています。
このおかげで、メモリのようなリソースが誤って使用されたり誤って処置されたりするのを防ぐことができます。
一般化と柔軟性を両立した安全性のためにこのアプローチを支持しています。
例えば、ATS ではポインタ演算がサポートされているにもかわらず、ATS
で構築された型付けされたプログラムは実行時にバッファオーバーランを引き起しません。
より具体的には、もしポインタがデリファレンスされると、ATS
はデリファレンス操作の安全性を実証するような証明を要求します。
このような証明は線形命題の正当性を立証することで構築されます。
この線形命題は ATS では観 (view) と呼ばれ、リソースおよび性能を分類します。

')#comment("para")
")

#langeng("
#para('\

Please find #mycodelink("CHAP_VVTINTRO/", "on-line") the code presented
for illustration in this chapter.

')
")
#langja("
#para('\

この章で紹介するコードは
#mycodelink("CHAP_VVTINTRO/", "オンライン")
から入手できます。

')
")

<!-- ****** ****** -->

<sect1
id="views_for_pointers">
#langeng("
#title("Views for Memory Access through Pointers")
")
#langja("
#title("ポインタを通じたメモリアクセスのための観")
")

#langeng("
#para('\

A view is a linear version of prop, where the word #emphasis("linear")
comes from linear logic, a resource-aware logic invented by Jean-Yves
Girard. There is a built-in sort #stacode("view") for static terms
representing views.  Given a type T and a memory location L, a view of the
form #stacode("T@L") can be formed to indicate a value of the type T being stored in
the memory at the location L, where #stacode("@") is a special infix
operator.  Views of this form are extremely common in practice, and they
are often referred to as at-views.  As an example, the following function
templates #dyncode("ptr_get0") and #dyncode("ptr_set0"), which reads and
writes through a given pointer, are assigned types containing at-views:

#atscode('\
fun{a:t@ype}
ptr_get0 {l:addr} (pf: a @ l | p: ptr l): (a @ l | a)

fun{a:t@ype}
ptr_set0 {l:addr} (pf: a? @ l | p: ptr l, x: a): (a @ l | void)
')

')
")
#langja("
#para('\

観は命題 (prop) の線形バージョンです。
#emphasis("線形 (linear)") という単語は、Jean-Yves Girard
によって考案されたリソースを意識した論理である線形論理に由来します。
観を表わす静的な項のためにビルトインの種 #stacode("view") があります。
型 T とメモリ位置 L が与えられた時、#stacode("T@L") という観を作ることができ、
これは型 T の値が位置 L にあるメモリに格納されていることを示しています。
#stacode("@") は中置の特殊演算子です。
この形の観は実用上非常に一般的で、それらはしばしば駐観 (at-view) と呼ばれます。
例として、次の関数テンプレート #dyncode("ptr_get0") と #dyncode("ptr_set0")
は、与えられたポインタを通して読み書きをし、駐観を含む型が割り当てられています:

#atscode('\
fun{a:t@ype}
ptr_get0 {l:addr} (pf: a @ l | p: ptr l): (a @ l | a)

fun{a:t@ype}
ptr_set0 {l:addr} (pf: a? @ l | p: ptr l, x: a): (a @ l | void)
')

')
")

#langeng("
#para('\

Note that #stacode("ptr") is a type constructor that forms a type
#stacode("ptr(L)") when applied to a static term L of the sort
#stacode("addr"), and the only value of the type #stacode("ptr(L)") is the
pointer that points to the location denoted by L.

')
")
#langja("
#para('\

#stacode("ptr") は型コンストラクタで、種 #stacode("addr") の静的な項 L に適用されると型
#stacode("ptr(L)") を作ることに注意してください。
型 #stacode("ptr(L)") の唯一の値は L によって示された位置を指すポインタです。

')
")

#langeng("
#para('\

Given a type T, the function #dyncode("ptr_get0&lt;T&gt;") is assigned the
following type:

#atscode('\
{l:addr} (T @ l | ptr (l)) -> (T @ l | T)
')

which indicates that the function #dyncode("ptr_get0&lt;T&gt;") returns a
proof of the view #stacode("T@L") and a value of the type T when applied to
a proof of the view #stacode("T@L") and a pointer of the type
#stacode("ptr(L)") for some L. Intuitively speaking, a proof of the view
#stacode("T@L"), which is a form of resource as #stacode("T@L") is linear, is
#emphasis("consumed") when it is passed to #dyncode("ptr_get0&lt;T&gt;"),
and another proof of the same view #stacode('T@L') is generated when
#dyncode("ptr_get0&lt;T&gt;") returns. Notice that a proof of the view
#stacode('T@L') must be returned for otherwise subsequent accesses to the
memory location L would have been precluded.

')
")
#langja("
#para('\

型 T が与えられた時、関数 #dyncode("ptr_get0&lt;T&gt;") には次の型が割り当てられます:

#atscode('\
{l:addr} (T @ l | ptr (l)) -> (T @ l | T)
')

これは観 #stacode("T@L") の証明とどこか L について型 #stacode("ptr(L)")
のポインタに適用すると、関数 #dyncode("ptr_get0&lt;T&gt;") が観 #stacode("T@L")
の証明と型 T の値を返すことを示しています。
直感的に言うと、#stacode("T@L") が線形であるようなリソースである観 #stacode("T@L")
の証明は、#dyncode("ptr_get0&lt;T&gt;") に渡された時に #emphasis("消費 (consumed)") されます。
さらに同じ観 #stacode('T@L') の別の証明が #dyncode("ptr_get0&lt;T&gt;") が返る時に生成されます。
観 #stacode('T@L') の証明が返らなければならないことに注意してください。
さもなければ後続のメモリ位置 L へのアクセスは不可能になります。

')
")

#langeng("
#para('\

Similarly, the function #dyncode("ptr_set0&lt;T&gt;") is assigned the
following type:

')
")
#langja("
#para('\

同様に、関数 #dyncode("ptr_set0&lt;T&gt;") には次の型が割り当てられます:

')
")

#atscode('\
{l:addr} (T? @ l | ptr (l)) -> (T @ l | void)
')

#langeng("
#para('\

Note that T? is a type for values of size #stacode("sizeof(T)") that are
assumed to be uninitialized.  The function #dyncode("ptr_set0&lt;T&gt;")
returns a proof of the view #stacode("T@L") when applied to a proof of the
view #stacode("T?@L"), a pointer of the type #stacode("ptr(L)") and a value
of the type T. The use of the view #stacode("T?@L") indicates that the
memory location at L is assumed to be uninitialized when
#dyncode("ptr_set0&lt;T&gt;") is called.

')
")
#langja("
#para('\

T? は未初期化であることを仮定したサイズ #stacode("sizeof(T)") の値のための型であることに注意してください。
関数 #dyncode("ptr_set0&lt;T&gt;") は、観 #stacode("T?@L") の証明と型 #stacode("ptr(L)")
のポインタ、型 T の値に適用されると、観 #stacode("T@L") の証明を返します。
観 #stacode("T?@L") の使用は、#dyncode("ptr_set0&lt;T&gt;")
が呼び出された時に、L のメモリ位置が未初期化であると仮定されていることを示しています。

')
")

#langeng("
#para('\

As an example, a function template #dyncode("swap0") is implemented as follows
for swapping memory contents at two given locations:

#atscode('\
fn{a:t@ype}
swap0 {l1,l2:addr}
(
  pf1: a @ l1, pf2: a @ l2
| p1: ptr (l1), p2: ptr (l2)
) : (a @ l1, a @ l2 | void) = let
  val (pf1 | x1) = ptr_get0<a> (pf1 | p1)
  val (pf2 | x2) = ptr_get0<a> (pf2 | p2)
  val (pf1 | ()) = ptr_set0<a> (pf1 | p1, x2)
  val (pf2 | ()) = ptr_set0<a> (pf2 | p2, x1)
in
  (pf1, pf2 | ())
end // end of [swap0]
')

')
")
#langja("
#para('\

例として、与えられた2つの位置にあるメモリコンテンツをスワップする関数テンプレート #dyncode("swap0")
は次のように実装されます:

#atscode('\
fn{a:t@ype}
swap0 {l1,l2:addr}
(
  pf1: a @ l1, pf2: a @ l2
| p1: ptr (l1), p2: ptr (l2)
) : (a @ l1, a @ l2 | void) = let
  val (pf1 | x1) = ptr_get0<a> (pf1 | p1)
  val (pf2 | x2) = ptr_get0<a> (pf2 | p2)
  val (pf1 | ()) = ptr_set0<a> (pf1 | p1, x2)
  val (pf2 | ()) = ptr_set0<a> (pf2 | p2, x1)
in
  (pf1, pf2 | ())
end // end of [swap0]
')

')
")

#langeng("
#para('\

Compared to a corresponding implementation in C, the verbosity of this one
in ATS is evident. In particular, the need for #emphasis("threading")
linear proofs through calls to functions that make use of resources can
often result in a lot of #emphasis("administrative") code to be written. I
now present some special syntax to significantly alleviate the need for
such administrative code.

')
")
#langja("
#para('\

対応するC言語の実装と比較して、ATSでのこの実装が冗長であることは明白です。
特に、リソースを使用する関数の呼び出しを通じて、線形の証明が #emphasis("分断") されてしまうため、
多くの #emphasis("管理上の") コードを書くことになってしまいます。
ここで、このような管理上のコードの必要性を大きく緩和するために、いくつか特別な構文を紹介します。

')
")

#langeng("
#para('\

The function templates #dyncode("ptr_get1") and #dyncode("ptr_set1") are
given the following interfaces:

#atscode('\
fun{a:t@ype}
ptr_get1 {l:addr} (pf: !a @ l >> a @ l | p: ptr l): a

fun{a:t@ype}
ptr_set1 {l:addr} (pf: !a? @ l >> a @ l | p: ptr l, x: a): void
')

Clearly, for each type T, the function
#dyncode("ptr_get1&lt;T&gt;") is assigned the following type:

#atscode('\
{l:addr} (!T @ l >> T @ l | ptr(l)) -> T
')

Given a linear proof pf of the view #stacode("T@L") for some L and a
pointer p of the type #stacode("ptr(L)"), the function call
#dyncode("ptr_get1&lt;T&gt;")(pf, p) is expected to return a value of the
type T. However, the proof pf is not consumed. Instead, it is still a proof
of the view #stacode("T@L") after the function call returns. Similarly, the
function #dyncode("ptr_set1&lt;T&gt;") is assigned the following type:

#atscode('\
{l:addr} (!T? @ l >> T @ l | ptr(l), T) -> void
')

Given a linear proof pf of the view #stacode("T?@L") for some L, a pointer
p of the type #stacode("ptr(L)") and a value v of the type T, the function
call #dyncode("ptr_set1&lt;T&gt;")(pf, p, v) is expected to return the void
value while changing the view of pf from #stacode("T?@L") to
#stacode("T@L").  In general, assume that f is given a type of the
following form for some views V1 and V2:

#atscode('\
(...,!V1 >> V2, ...) -> ...
')

Then a function call f(..., pf, ...) on some proof variable pf of the view
V1 is to change the view of pf into V2 upon its return.  In the case where
V1 and V2 are the same, !V1 >> V2 can simply be written as !V1.  As an
example, a function template #dyncode("swap1") for swapping the contents at
two given memory locations is implemented as follows:

#atscode('\
fn{a:t@ype}
swap1 {l1,l2:addr} (
  pf1: !a@l1, pf2: !a@l2 | p1: ptr l1, p2: ptr l2
) : void = let
  val x = ptr_get1<a> (pf1 | p1)
  val () = ptr_set1<a> (pf1 | p1, ptr_get1<a> (pf2 | p2))
  val () = ptr_set1<a> (pf2 | p2, x)
in
  // nothing
end // end of [swap1]
')

Clearly, this implementation is considerably cleaner when compared to the
above implementation of #dyncode("swap0").

')
")
#langja("
#para('\

関数テンプレート #dyncode("ptr_get1") と #dyncode("ptr_set1") は次のようなインターフェイスを持ちます:

#atscode('\
fun{a:t@ype}
ptr_get1 {l:addr} (pf: !a @ l >> a @ l | p: ptr l): a

fun{a:t@ype}
ptr_set1 {l:addr} (pf: !a? @ l >> a @ l | p: ptr l, x: a): void
')

明確に、それぞれの型 T について、関数 #dyncode("ptr_get1&lt;T&gt;") には次の型が割り当てられます:

#atscode('\
{l:addr} (!T @ l >> T @ l | ptr(l)) -> T
')

どこか L と型 #stacode("ptr(L)") のポインタ p について、観 #stacode("T@L") の線形の証明 pf
が与えられた時、関数呼び出し #dyncode("ptr_get1&lt;T&gt;")(pf, p) は型 T の値を返すことが期待されています。
けれども、証明 pf は消費されません。
その代わりに、関数呼び出しが返った後も観 #stacode("T@L") の証明はまだ在ります。
同様に、関数 #dyncode("ptr_set1&lt;T&gt;") には次の型が割り当てられます:

#atscode('\
{l:addr} (!T? @ l >> T @ l | ptr(l), T) -> void
')

どこか L と型 #stacode("ptr(L)") のポインタ p、型 T の値 v について、観 #stacode("T?@L") の線形の証明 pf
が与えられた時、関数呼び出し #dyncode("ptr_set1&lt;T&gt;")(pf, p, v) は pf の観を #stacode("T?@L")
から #stacode("T@L") に変えて、void 値を返すことが期待されています。
一般に、観 V1 と V2 が与えられた時、f には次の形の型が与えられます:

#atscode('\
(...,!V1 >> V2, ...) -> ...
')

そのとき、観 V1 の証明の値 pf について、関数呼び出し f(..., pf, ...) は返る時に pf の観を V2 に変えます。
V1 と V2 が同じ場合には、!V1 >> V2 は単に !V1 と書くこともできます。
例として、与えられた2つのメモリ位置のコンテンツをスワップする関数テンプレート
#dyncode("swap1") は次のように実装されます:

#atscode('\
fn{a:t@ype}
swap1 {l1,l2:addr} (
  pf1: !a@l1, pf2: !a@l2 | p1: ptr l1, p2: ptr l2
) : void = let
  val x = ptr_get1<a> (pf1 | p1)
  val () = ptr_set1<a> (pf1 | p1, ptr_get1<a> (pf2 | p2))
  val () = ptr_set1<a> (pf2 | p2, x)
in
  // nothing
end // end of [swap1]
')

この実装は #dyncode("swap0") の上記の実装と比較してかなり綺麗なことは明確です。

')
")

#langeng("
#para('\

A further simplied implementation of #dyncode("swap1") is given as follows:

#atscode('\
fn{a:t@ype}
swap1{l1,l2:addr}
(
  pf1: !a@l1, pf2: !a@l2
| p1: ptr (l1), p2: ptr (l2)
) : void = let
  val tmp = !p1 in !p1 := !p2; !p2 := tmp
end // end of [swap1]
')

Given a pointer p of the type #stacode("ptr(L)") for some L, #dyncode("!p")
yields the value stored at the memory location L.  The typechecker first
searches for a proof of the view #stacode("T@L") for some T among all the
currently available proofs when typechecking #dyncode("!p"); if such a
proof pf is found, then #dyncode("!p") is essentially elaborated into
#dyncode("ptr_get1(pf | p)") and then typechecked. As #dyncode("!p") is a
left-value (which is to be explained later in detail), it can also be used
to form an assignment like #dyncode("!p := v") for some value v. The
typechecker elaborates #dyncode("!p := v") into #dyncode("ptr_set1(pf | p,
v)") for the sake of typechecking if a proof of the at-view #stacode("T@L")
can be found for some type T among all the currently available proofs. Note
that this implementation of #dyncode("swap1") makes no use of
administrative code for handling linear proofs explicitly.

')
")
#langja("
#para('\

#dyncode("swap1") のさらに簡単な実装は次のようになります:

#atscode('\
fn{a:t@ype}
swap1{l1,l2:addr}
(
  pf1: !a@l1, pf2: !a@l2
| p1: ptr (l1), p2: ptr (l2)
) : void = let
  val tmp = !p1 in !p1 := !p2; !p2 := tmp
end // end of [swap1]
')

どこか L について型 #stacode("ptr(L)") のポインタ p が与えられた時、#dyncode("!p")
はメモリ位置 L に保存された値を生じます。
#dyncode("!p") を型検査すると、型検査器はまずはじめに現在有効な全ての証明の中で T について
観 #stacode("T@L") の証明を検索します:
もしそのような証明 pf が見つかったら、#dyncode("!p") は本質的に #dyncode("ptr_get1(pf | p)")
に詳細化されて、型検査は終わります。
#dyncode("!p") が左辺値 (詳細は後に説明します) である場合、
なんらかの値 v について #dyncode("!p := v") のような割り当てで使うこともできます。
もし現在有効な全ての証明の中である型 T について駐観 #stacode("T@L") の証明が見つかれば、
型検査器は型検査のために #dyncode("!p := v") を #dyncode("ptr_set1(pf | p, v)") に詳細化します。
#dyncode("swap1") のこの実装は線形の証明を明示的に扱うための管理上のコードを使っていないことに注意してください。

')
")

</sect1>#comment("sect1/id=views_for_pointers")

<!-- ****** ****** -->

<sect1
id="viewtypes_as_combination">
#langeng("
#title("Viewtypes as a Combination of Views and Types")
")
#langja("
#title("観と型を組み合わせた観型")
")

#langeng("
#para("\

A linear type in ATS is given the name #emphasis("viewtype"), which is
chosen to indicate that a linear type consists of two parts: one part for
views and the other for types. For instance, given a view V and a type T,
then the tuple (V | T) is a viewtype, where the bar symbol (|) is a
separator (just like a comma) to separate views from types. What seems a
bit surprising is the opposite: For each viewtype VT, we may assume the
existence of a view V and a type T such that VT is equivalent to (V |
T). Formally, this T can be referred as VT?! in ATS.  This somewhat
unexpected interpretation of linear types is a striking novelty of ATS,
which stresses that the linearity of a viewtype comes #emphasis("entirely")
from the view part residing within it.

")
")
#langja("
#para("\

ATS の線形型は #emphasis("観型 (viewtype)") という名前です。
これは線形型は2つの部分から構成されることを示しています: 一つは観 (view)でもう一つが型 (type) です。
例えば、観 V と型 T が与えられた時、タプル (V | T) は観型で、バー記号 (|) は観と型を
(コンマのように) 分離しています。
少し意外かもしれませんが、反対に:
それぞれの観型 VT について、VT が (V | T) と等しいような 観 V と型 T の存在を仮定できます。
形式上、ATS ではこの T は VT?! として参照されます。
この幾分意外な線形型の解釈は ATS の目立った新規性です。
それは観型の線形性は #emphasis("完全に") その中に存在する観部分に由来することを強調しています。

")
")

#langeng("
#para('\

The built-in sorts #stacode("viewtype") and #stacode("viewt@ype") are for static
terms representing viewtypes whose type parts are of the sorts
#stacode("type") and #stacode("t@ype"), respectively. In other words, the former
is assigned to viewtypes for linear values of the size equal to that of a
pointer and the latter to viewtypes for linear values of unspecified size.
For example, #stacode("tptr") is defined as follows that takes a type and an
address to form a viewtype (of the sort #stacode("viewtype")):

#atscode('\
vtypedef tptr (a:t@ype, l:addr) = (a @ l | ptr l)
')

Given a type T and an address L, the viewtype #stacode("tptr(T, L)") is for
a pointer to L paired with a linear proof stating that a value of the type
T is stored at L. If we think of a counter as a pointer paired with a proof
stating that the pointer points to an integer (representing the count),
then the following defined function #dyncode("getinc") returns the current
count of a given counter after increasing it by 1:\

#atscode('\

fn getinc
  {l:addr}{n:nat}
(
  cnt: !tptr (int(n), l) >> tptr (int(n+1), l)
) : int(n) = n where {
  val n = ptr_get1<int(n)> (cnt.0 | cnt.1)
  val () = ptr_set1<int(n+1)> (cnt.0 | cnt.1, n+1)
} (* end of [getinc] *)
')

')
")
#langja("
#para('\

ビルトインの種 #stacode("viewtype") と #stacode("viewt@ype") は、型部分がそれぞれ種
#stacode("type") と #stacode("t@ype") であるような観型を表わす静的な項です。
別の言い方をすると、前者にはポインタのサイズに等しいサイズの線形値の観型が割り当てられ、そして後者には詳細不明のサイズの線形値の観型が割り当てられます。
例えば、型と、種 #stacode("viewtype") の観型を作るアドレスを取るような、#stacode("tptr")
は次のように定義されます:

#atscode('\
viewtypedef tptr (a:t@ype, l:addr) = (a @ l | ptr l)
')

型 T とアドレス L が与えられた時、観型 #stacode("tptr(T, L)") は
L に格納された型 T の値を示す線形の証明とペアになった L のポインタです。
カウントを表わす整数を指すポインタを示す証明とペアになったポインタとしてのカウンタのことを考えるなら、
次に定義する関数 #dyncode("getinc") は与えられたカウンタを1増やした後、現時点でのカウントを返します:\

#atscode('\

fn getinc
  {l:addr}{n:nat}
(
  cnt: !tptr (int(n), l) >> tptr (int(n+1), l)
) : int(n) = n where {
  val n = ptr_get1<int(n)> (cnt.0 | cnt.1)
  val () = ptr_set1<int(n+1)> (cnt.0 | cnt.1, n+1)
} (* end of [getinc] *)
')

')
")

#langeng("
#para('\

A particularly interesting example of a viewtype is the following one:

#atscode('\
vtypedef cloptr
  (a:t@ype, b:t@ype, l:addr) =
  [env:t@ype] (((&env, a) -> b, env) @ l | ptr l)
// end of [cloptr_app]
')

Given two types A and B, a pointer to some address L where a closure
function is stored that takes a value of the type A to return a value of
the type B can be given the viewtype #stacode("cloptr(A, B, L)"). Note that
a closure function is just an envless function paired with an environment
containing bindings for variables in the body of the closure function that
are introduced from outside. In the function type #stacode("(&amp;env, a)
-> b"), the symbol #stacode("&amp;") indicates that the corresponding
function argument is passed by reference, that is, the argument is required
to be a left-value and what is actually passed at run-time is the address
of the left-value.  I will cover the issue of call-by-reference elsewhere
in more details.  The following piece of code demonstrates a pointer to a
closure function being called on a given argument:\

#atscode('\
fun{
a:t@ype}{b:t@ype
} cloptr_app {l:addr}
(
  pclo: !cloptr (a, b, l), x: a
) : b = let
  val p = pclo.1
(*
//
// taking out pf: ((&env, a) -> b, env) @ l
//
  prval pf = pclo.0
//
*)
  val res = !p.0 (!p.1, x)
(*
  prval () = pclo.0 := pf // putting the proof pf back
*)
in
  res
end // end of [cloptr]
')

Note that the linear proof in #dyncode("pclo") is first taken out so that
the code for dereferencing p (denoted by the syntax #dyncode("!p")) can
pass typechecking, and it is then returned so that the type of
#dyncode("pclo") is restored to its original one. This process of taking
out a linear proof from a record and then putting it back into the record
can be automatically performed by the typechecker of ATS.

')
")
#langja("
#para('\

次は観型の特に興味深い例です:

#atscode('\
viewtypedef cloptr
  (a:t@ype, b:t@ype, l:addr) =
  [env:t@ype] (((&env, a) -> b, env) @ l | ptr l)
// end of [cloptr_app]
')

2つの型 A と B が与えられた時、型 A の値を取り型 B の値を返すようなクロージャ関数が保管されたアドレス L
を指すポインタには観型 #stacode("cloptr(A, B, L)") を与えることができます。
クロージャ関数は、外から導入されたクロージャ関数本体内の値の束縛を含む環境とペアになった単なる無環境関数であることに注意してください。
関数型 #stacode("(&amp;env, a) -> b") において、記号 #stacode("&amp;")
は対応する関数の引数が参照で渡されていることを示しています。
つまり、この引数は左辺値であることが要求されていて、実行時に実際に渡されるものは左辺値のアドレスです。
参照渡し (call-by-reference) については別の章でより詳細に解説します。
次のコードは与えられた引数で呼び出されるクロージャ関数へのポインタを説明しています:\

#atscode('\
fun{
a:t@ype}{b:t@ype
} cloptr_app {l:addr}
(
  pclo: !cloptr (a, b, l), x: a
) : b = let
  val p = pclo.1
(*
//
// taking out pf: ((&env, a) -> b, env) @ l
//
  prval pf = pclo.0
//
*)
  val res = !p.0 (!p.1, x)
(*
  prval () = pclo.0 := pf // putting the proof pf back
*)
in
  res
end // end of [cloptr]
')

p のデリファレンスが型検査を通すために、#dyncode("pclo")
内の線形の証明がはじめに取り出されることに注意してください。
そして #dyncode("pclo") の型が元の位置に復帰されて返ります。
このレコードからの線形証明の取り出しとレコードへの復帰は ATS の型検査器によって自動的に行なわれます。

')
")

#langeng("
#para('\

The very ability to explain within ATS programming features such as closure
function is a convincing indication of the expressiveness of the type
system of ATS.

')
")
#langja("
#para('\

クロージャ関数のような ATS プログラミングの機能を説明する能力は、ATS の型システムの表現力の説得力ある証拠です。

')
")

</sect1>#comment("sect1/id=viewtypes_as_combination")

<!-- ****** ****** -->

<sect1
id="lval_and_cbr">
#langeng("
#title("Left-Values and Call-by-Reference")
")
#langja("
#title("左辺値と参照渡し")
")

#langeng("
#para('\

In its simplest form, a left-value is just a pointer paired with a linear
proof attesting to a value (of some type) being stored at the location to
which the pointer points. The name #emphasis("left-value") stems from such a
value being allowed to appear on the left-hand side of an assignment
statement (in languages like C). Often, a left-value is intuitively
explained as a value with an address attached to it. Note that whatever
representation chosen for a left-value must make it possible to identify
both the pointer and the linear proof (of some at-view) that are associated
with the left-value.

')
")
#langja("
#para('\

もっとも単純な形として、左辺値はポインタの指す位置に保存された (なんらかの型の)
値を証言している線形の証明とペアになった単なるポインタです。
#emphasis("左辺値 (left-value)") という名前は、(C言語のように)
割り当てられた文の左側に置かれることが許された値に由来します。
しばしば直感的に、左辺値はアドレスが付属した値として説明されます。
左辺値として選ばれたどのような表現も、
ポインタと左辺値に関連する (なんらかの駐観の)
線形の証明の両方ともを識別できなければならないことに注意してください。

')
")

#langeng("
#para('\

In ATS, the simplest expression representing a left-value is
#dyncode("!p"), where #dyncode("!") is a special symbol and p a value of
the type #stacode("ptr(L)") for some address L. When this expression is
typechecked, a proof of #stacode("T@L") for some type T is required to be
found among the currently available proofs. I will introduce additional
forms of left values gradually.

')
")
#langja("
#para('\

ATS では、もっとも単純な左辺値を表わす式は #dyncode("!p") です。
このとき #dyncode("!") は特殊記号で、p はどこかのアドレス L について型 #stacode("ptr(L)") の値です。
この式が型検査される時、
なんらかの型 T について #stacode("T@L") の証明が現状有効な証明群の中に見つかることを要求します。
徐々にさらなる左辺値の形について紹介します。

')
")

#langeng("
#para('\

The default strategy for passing a function argument in ATS is
call-by-value. However, it is also allowed in ATS to specify that
call-by-reference is chosen for passing a particular function argument. By
call-by-reference, it is meant that the argument to be passed must be a
left-value and what is actually passed is the address of the left-value
(instead of the value stored at the address). For example, the following
defined function #dyncode("swap2") makes essential use of
call-by-reference:

#atscode('\
fn{
a:t@ype
} swap2 (
  x1: &a, x2: &a
) : void = let
  val tmp = x1 in x1 := x2; x2 := tmp
end // end of [swap2]
')

Note that the special symbol #dyncode("&amp;") in front of the type of a
function argument indicates that the argument needs to be passed according
to the call-by-reference strategy. The following code implements
#dyncode("swap1") based on #dyncode("swap2"):

#atscode('\
fn{
a:t@ype
} swap1{l1,l2:addr}
(
  pf1: !a @ l1, pf2: !a @ l2 | p1: ptr l1, p2: ptr l2
) : void = swap2 (!p1, !p2)
')

When the call #dyncode("swap2(!p1, !p2)") is evaluated at run-time, the
parameters actually being passed are the two pointers #dyncode("p1") and
#dyncode("p2") (rather than the values stored at the locations to which
these two pointers point).\

')
")
#langja("
#para('\

ATS における関数へ引数を渡す既定の戦略は値渡し (call-by-value) です。
けれども、特定の関数に渡す引数に参照渡し (call-by-reference) を選択するように指示することも ATS では可能です。
参照渡しの場合、渡される引数は左辺値でなければなりません。
そして実際には (アドレスに格納された値の代わりに) 左辺値のアドレスが渡されることになります。
例えば、次に定義した関数 #dyncode("swap2") は参照渡しを使っています:

#atscode('\
fn{
a:t@ype
} swap2 (
  x1: &a, x2: &a
) : void = let
  val tmp = x1 in x1 := x2; x2 := tmp
end // end of [swap2]
')

関数の引数の型の直前にある特殊記号 #dyncode("&amp;")
は、その引数が参照渡し戦略に従って渡される必要があることを示すことに注意してください。
次のコードは #dyncode("swap2") を元にして #dyncode("swap1") を実装しています:

#atscode('\
fn{
a:t@ype
} swap1{l1,l2:addr}
(
  pf1: !a @ l1, pf2: !a @ l2 | p1: ptr l1, p2: ptr l2
) : void = swap2 (!p1, !p2)
')

呼び出し #dyncode("swap2(!p1, !p2)")
が実行時に評価された時、(この2つのポインタは指す位置に保管されている値ではなく)
2つのポインタ #dyncode("p1") と #dyncode("p2") が実際にはパラメータとして渡されます。\

')
")

#langeng("
#para('\

Given a type T and an integer N, the syntax #stacode("@[T][N]") stands for
a flat array consisting N elements of the type T. Please note that a value
of the type #stacode("@[T][N]") is of the size N*sizeof(T). If a function
has a parameter representing an array, then this parameter is most liklely
call-by-reference. For instance, the following code implements a function
that takes two arrays of doubles to compute their dot product (also knowns
as inner product):

#atscode('\
fun dotprod 
(
  A: &(@[double][3])
, B: &(@[double][3])
) : double =
(
  A[0] * B[0] + A[1] * B[1] + A[2] * B[2]
)
')

Note that both array arguments of #dyncode("dotprod") are call-by-reference.

')
")
#langja("
#para('\

型 T と整数 N が与えられた時、構文 #stacode("@[T][N]") は 型 T の要素数 N
から成るフラットな配列を表わしています。
型 #stacode("@[T][N]") の値のサイズは N*sizeof(T) であることに注意してください。
もし関数が配列を表わすパラメータを持つなら、このパラメータは参照渡しの方が好ましいでしょう。
例えば、次のコードは double の2つの配列を取り、ドット積 (またはスカラー積) を計算する関数を実装しています:

#atscode('\
fun dotprod 
(
  A: &(@[double][3])
, B: &(@[double][3])
) : double =
(
  A[0] * B[0] + A[1] * B[1] + A[2] * B[2]
)
')

#dyncode("dotprod") の配列引数は両方とも参照渡しであることに注意してください。

')
")

</sect1>#comment("sect1/id=lval_and_cbr")

<!-- ****** ****** -->

<sect1
id="stack-allocated_variables">
#langeng("
#title("Stack-Allocated Variables")
")
#langja("
#title("スタックに確保された値")
")

#langeng("
#para('\

Given a type T and an address L, how can a proof of the view
#stacode("T@L") be obtained in the first place? There are actually a
variety of methods for obtaining such proofs in practice, and I present one
as follows that is based on stack-allocation of local variables.

')
")
#langja("
#para('\

型 T とアドレス L が与えられた時、
最初の段階で観 #stacode("T@L") の証明はどのように得られるのでしょうか？
実際にそのような証明を得る方法は様々です。
次のようにローカルの値としてスタックに確保する方法を紹介します。

')
")

#langeng("
#para('\

In the body of the following function #dyncode("foo"), some stack-allocated
local variables are declared:

')
")
#langja("
#para('\

次の関数 #dyncode("foo") の本体では、
いくつかのスタックに確保されたローカルな値が宣言されています:

')
")

#atscode('\
fn foo (): void = let
  var x0: int // view@(x0): int? @ x0
  val () = x0 := 0 // view@(x0): int(0) @ x0
  var x1: int = 1 // view@(x1): int(1) @ x1
//
// [with] is a keyword in ATS
//
  var y: int with pfy // pfy is an alias of view@(y): int? @ y
  val () = y := 2 // pfy = view@(y): int(2) @ y
  var z: int with pfz = 3 // pfz is an alias of view@(z): int(3) @ z
in
  // nothing
end // end of [foo]
')

#langeng("
#para('\

The keyword #dyncode("var") is for declaring a local variable. When a
variable is declared, either its type or its initial value needs to be
given. If a variable is declared without a type, then the type of its
initial value is assumed to be its type. Assume that a variable x is
declared of type T. Then the pointer to the location of the variable is
denoted by #dyncode("addr@(x)"), where #dyncode("addr@") is a keyword, and
its associated linear proof (of some at-view) can be referred to as
#dyncode("view@(x)"), where #dyncode("view@") is a keyword. A variable is
another form of left-value in ATS. In the body of #dyncode("foo"),
#dyncode("x0") is declared to be a variable of the type #stacode("int") and
then it is initialized with the integer 0; #dyncode("x1") is declared to be
a variable of the type #stacode("int") that is given the initial value 1;
#dyncode("y") is declared to be a variable of the type #stacode("int")
while #dyncode("pfy") is introduced as an alias for #dyncode("view@(y)"),
and then #dyncode("y") is initialized with the integer 2; #dyncode("z") is
declared to be a variable of the type #stacode("int") that is given the
initial value 3 while #dyncode("pfz") is introduced as an alias for
#dyncode("view@(z)").

')
")
#langja("
#para('\

キーワード #dyncode("var") はローカルな値の宣言です。
値は宣言された時、その型またはその初期値を与える必要があります。
もし値が型をともなわずに宣言されたら、その初期値の型がその型であると見なされます。
値 x が型 T で宣言されていたと仮定しましょう。
するとその値の位置を指すポインタは #dyncode("addr@(x)") で表わされ、関連した (駐観の) 線形の証明は
#dyncode("view@(x)") で表わされます。
このとき #dyncode("addr@") と #dyncode("view@") はキーワードです。
値は ATS における左辺値のもう一つの形です。
#dyncode("foo") の本体では、#dyncode("x0") が型 #stacode("int") の値として宣言されて整数0で初期化されます;
#dyncode("x1") が型 #stacode("int") の値として宣言されて初期値1が与えられます;
#dyncode("pfy") が #dyncode("view@(y)") の別名として導入されているとき、
#dyncode("y") が型 #stacode("int") の値として宣言されて整数2で初期化されます;
#dyncode("pfz") が #dyncode("view@(z)") の別名として導入されているとき、
#dyncode("z") が型 #stacode("int") の値として宣言されて初期値3が与えられます。

')
")

#langeng("
#para('\

The following code gives an implementation of the factorial function:

')
")
#langja("
#para('\

次のコードは階乗関数の実装です:

')
")

#atscode('\
fn fact{n:nat}
  (n: int (n)): int = let
  fun loop{n:nat}{l:addr} .<n>.
    (pf: !int @ l | n: int n, res: ptr l): void =
    if n > 0 then let
      val () = !res := n * !res in loop (pf | n-1, res)
    end // end of [if]
  // end of [loop]
  var res: int with pf = 1
  val () = loop (pf | n, addr@res) // addr@res: the pointer to res
in
  res
end // end of [fact]
')

#langeng("
#para('\

Note that the variable #dyncode("res") holds the intermediate result during
the execution of the loop. As #dyncode("res") is stack-allocated, there is
no garbage generated after a call to #dyncode("fact") is evaluated. When
this style of programming is done in C, there is often a concern about the
pointer to #dyncode("res") being derefenced after a call to
#dyncode("fact") returns, which is commonly referred to as derefencing a
dangling pointer.  This concern is completely eliminated in ATS as it is
required by the type system of ATS that a linear proof of the at-view
associated with the variable #dyncode("res") be present at the end of legal
scope for #dyncode("res"). More specifically, if x is a declared variable
of the type T, then a linear proof of the view #stacode("T?@L"), where L is
the address of x, must be available when typechecking reaches the end of
the scope for x.  This requirement ensures that a variable can no longer be
accessed after the portion of the stack in which it is allocated is
reclaimed as no linear proof of the at-view associated with the variable is
ever available from that point on.

')
")
#langja("
#para('\

loop を実行している間、#dyncode("res") の値は中間結果を保持していることに注意してください。
#dyncode("res") はスタックに確保されるので、
#dyncode("fact") 呼び出しが評価された後にゴミが生成されることはありません。
C言語でこのスタイルのプログラミングをする時、#dyncode("fact") 呼び出しが返った後に
#dyncode("res") を指すポインタがデリファレンスされてしまう不安がしばしばあります。
これは一般に、宙ぶらりんなポインタのデリファレンス (derefencing a dangling pointer) と呼ばれます。
ATS ではこの不安は完全に取り除かれています。
変数 #dyncode("res") に関連する駐観の線形証明は、#dyncode("res")
のスコープが終わるまで存在することが ATS の型システムによって要求されます。
より具体的には、もし型 T の変数 x が宣言されていたら、L がアドレス x のとき観 #stacode("T?@L")
の線形証明は、x のスコープの終わりに型検査が到達するまで有効でなければなりません。
この要求は、確保されたスタックの割り当てが終わった後、もはや変数にアクセスできないことを保証します。
その変数に関連した駐観の線形証明がその時点では無効なのです。

')
")

#langeng("
#para('\

Arrays in ATS can also be stack-allocated. For instance, the following code
allocates two arrays of doubles in the frame of the function
#dyncode("main0") and then passes them to #dyncode("dotprod") to compute
their dot product:

#atscode('\
implement
main0 () =
{
//
var A = @[double][3](1.0) // initialized with 1.0, 1.0, 1.0
var B = @[double](1.0, 2.0, 3.0) // initialized with 1.0, 2.0, 3.0
//
val () = println! ("A * B = ", dotprod (A, B)) // A * B = 6.0
//
} (* end of [main0] *)
')

The at-view associated with the variable A is #stacode("(@[double][3])@A"),
where A also refers to the address of the variable A. Similarly, the
at-view associated with the variable B is #stacode("(@[double][3])@B").

For the sake of completeness, I mention the syntax for uninitialized arrays
as follows: Given a type T and an integer N, the syntax
#dyncode("@[T][N]()") is for an array consisting of N uninitialized values
of type T.

')
")
#langja("
#para('\

ATS の配列もまたスタックに確保できます。
例えば、次のコードは関数 #dyncode("main0") のスタックフレームに double の2つの配列を確保します。
それからそれらを #dyncode("dotprod") に渡してドット積を計算します:

#atscode('\
implement
main0 () =
{
//
var A = @[double][3](1.0) // initialized with 1.0, 1.0, 1.0
var B = @[double](1.0, 2.0, 3.0) // initialized with 1.0, 2.0, 3.0
//
val () = println! ("A * B = ", dotprod (A, B)) // A * B = 6.0
//
} (* end of [main0] *)
')

変数 A に関連した駐観は #stacode("(@[double][3])@A") です。
このとき A は 値 A のアドレスもまた参照しています。
同様に変数 B に関連した駐観は #stacode("(@[double][3])@B") です。

完全を期すために、次のような未初期化の配列のための構文を紹介します:
型 T と整数 N が与えられた時、構文 #dyncode("@[T][N]()") は型 T の N 個の未初期化の値からなる配列を表わします。

')
")

#langeng("
#para('\

Note that allocating large arrays in the call frame of a function may not
be a good practice as doing so can greatly increase the likelihood of
stack-overflow at run-time.

')
")
#langja("
#para('\

関数の呼び出しフレーム中に大きな配列確保するのは良い慣習とは言えないことに注意してください。
実行時にスタックオーバーフローが非常に発生しやすくなります。

')
")

#langeng("
#para('\

It is also allowed in ATS to allocate a closure in the call frame of a
function. For instance, the following code implements a function named
#dyncode("foo") that stores a flat closure-function in a stack-allocated
variable named #dyncode("bar"):

#atscode('\
fun foo
(
  x: int, y: int
) : int = let
//
var bar = lam@ (): int => x * y
//
in
  bar ()
end // end of [foo]
')

Note that the special keyword #keycode("lam@") should be used to form a
flat closure-function. For the sake of completeness, I present another example
as follows to show that a recursive closure-function can also be stored in
a stack-allocated variable:

#atscode('\
fun foo2
(
  x: int, y: int
) : int = let
//
var bar2 = fix@ f (x: int): int => if x > 0 then y + f(x-1) else 0
//
in
  bar2 (x)
end // end of [foo]
')

Note that the special keyword #keycode("fix@") should be used to form
a flat recursive closure-function.

')
")
#langja("
#para('\

ATS では、関数の呼び出しフレーム内にクロージャを確保することもできます。
例えば、次のコードは #dyncode("bar") という名前でスタックに確保された変数にフラットなクロージャ関数を置く
#dyncode("foo") という名前の関数を実装しています:

#atscode('\
fun foo
(
  x: int, y: int
) : int = let
//
var bar = lam@ (): int => x * y
//
in
  bar ()
end // end of [foo]
')

特殊キーワード #keycode("lam@") はフラットなクロージャ関数を作るのに使われることに注意してください。
完全を期すために、再帰クロージャ関数もまたスタックに確保された変数に格納できることを示す次のような別の例を紹介します:

#atscode('\
fun foo2
(
  x: int, y: int
) : int = let
//
var bar2 = fix@ f (x: int): int => if x > 0 then y + f(x-1) else 0
//
in
  bar2 (x)
end // end of [foo]
')

特殊キーワード #keycode("fix@") はフラットな再帰クロージャ関数を作るのに使われることに注意してください。

')
")

#langeng("
#para('\

In a setting where dynamic memory allocation is not
allowed, stack-allocated closures can play a pivotal role in supporting
programming with higher-order functions.

')
")
#langja("
#para('\

動的なメモリ確保が使えない状況下では、スタックに確保されたクロージャは高階関数を使ったプログラミングをサポートする極めて重要な存在です。

')
")

</sect1>#comment("sect1/id=stack_allocated_variables")

<!-- ****** ****** -->

<sect1
id="heap-allocated-linear-closure-functions">
#langeng("
#title("Heap-Allocated Linear Closure-Functions")
")
#langja("
#title("ヒープに確保された線形クロージャ関数")
")

#langeng("
#para('\

In ATS, a closure-function can be assiged a linear type, allowing
it to be properly tracked within the type system and also explicitly
freed by the programmer.
')
")
#langja("
#para('\

ATS では、クロージャ関数には線形型を割り当てることができます。
これは型システムによって適切に追跡され、またプログラマによって明示的に解放されます。
')
")

#langeng("
#para('\

The following code implements a higher-order function
#dyncode("list_map_cloptr") which takes a linear closure-function
as its second argument:

#atscode('\
fun{
a:t@ype}{b:vt@ype
} list_map_cloptr{n:int}
(
  xs: list (a, n), f: !(a) -<cloptr1> b
) : list_vt (b, n) =
(
  case+ xs of
  | list_nil () => list_vt_nil ()
  | list_cons (x, xs) => list_vt_cons (f (x), list_map_cloptr<a><b> (xs, f))
)
')

Note that the keyword #keycode("-&lt;cloptr1&gt;") indicates that the
function type it forms is for a linear closure-function. If a type for a
pure linear closure-function is needed, the keyword
#keycode("-&lt;cloptr0&gt;") can be used.  The symbol #keycode("!") in
front of the function type means that the second (linear) argument of
#dyncode("list_map_cloptr") is call-by-value and it is still available
after #dyncode("list_map_cloptr") returns.\

')
")
#langja("
#para('\

次のコードは、第二引数に線形クロージャ関数を取る高階関数 #dyncode("list_map_cloptr") を実装しています:

#atscode('\
fun{
a:t@ype}{b:vt@ype
} list_map_cloptr{n:int}
(
  xs: list (a, n), f: !(a) -<cloptr1> b
) : list_vt (b, n) =
(
  case+ xs of
  | list_nil () => list_vt_nil ()
  | list_cons (x, xs) => list_vt_cons (f (x), list_map_cloptr<a><b> (xs, f))
)
')

キーワード #keycode("-&lt;cloptr1&gt;") はその関数型が線形クロージャ関数であること示すことに注意してください。
もし純粋な線形クロージャ関数の型が必要であれば、キーワード  #keycode("-&lt;cloptr0&gt;") が使えます。
関数型の前にある記号 #keycode("!") は #dyncode("list_map_cloptr")
の線形の第二引数が値渡しであり、#dyncode("list_map_cloptr") が返った後もそれが有効であることを意味します。\

')
")

#langeng("
#para('\

Let us now see some concrete code in which a linear closure-function is
created, called, and finally freed:

#atscode('\
implement
main0 () =
{
//
val xs =
$list_vt{int}(0, 1, 2, 3, 4)
//
val len = list_vt_length (xs)
//
val f = lam (x: int): int =<cloptr1> x * len
//
val ys =
list_map_cloptr<int><int> ($UNSAFE.list_vt2t(xs), f)
//
val () = cloptr_free($UNSAFE.castvwtp0{cloptr(void)}(f))
//
val () = println! ("xs = ", xs) // xs = 0, 1, 2, 3, 4
val () = println! ("ys = ", ys) // ys = 0, 5, 10, 15, 20
//
val ((*freed*)) = list_vt_free (xs)
val ((*freed*)) = list_vt_free (ys)
//
} (* end of [main0] *)
')

The function #dyncode("cloptr_free") is given the following
interface:

#atscode('\
fun cloptr_free{a:t0p}(pclo: cloptr (a)):<!wrt> void
')

Also, the cast involved in
#dyncode("$UNSAFE.castvwtp0{cloptr(void)}(f)") is a safe cast.

')
")
#langja("
#para('\

線形クロージャ関数が生成され、呼び出され、最後に解放されるような具体的なコードをいくつか見てみましょう:

#atscode('\
implement
main0 () =
{
//
val xs =
$list_vt{int}(0, 1, 2, 3, 4)
//
val len = list_vt_length (xs)
//
val f = lam (x: int): int =<cloptr1> x * len
//
val ys =
list_map_cloptr<int><int> ($UNSAFE.list_vt2t(xs), f)
//
val () = cloptr_free($UNSAFE.castvwtp0{cloptr(void)}(f))
//
val () = println! ("xs = ", xs) // xs = 0, 1, 2, 3, 4
val () = println! ("ys = ", ys) // ys = 0, 5, 10, 15, 20
//
val ((*freed*)) = list_vt_free (xs)
val ((*freed*)) = list_vt_free (ys)
//
} (* end of [main0] *)
')

関数 #dyncode("cloptr_free") には次のインターフェイスが与えられます:

#atscode('\
fun cloptr_free{a:t0p}(pclo: cloptr (a)):<!wrt> void
')

また、#dyncode("$UNSAFE.castvwtp0{cloptr(void)}(f)") に含まれるキャストは安全なキャストです。

')
")

#langeng("
#para('\

The support for linear closure-functions in ATS1 is crucial in a setting
where higher-order functions are needed but run-time garbage collection
(GC) is not allowed or supported. In ATS2, linear closure-functions become
much less important as programming with higher-order functions in a setting
without GC can be more conveniently achieved through the use of templates.
However, if one wants to store closure-functions in a data structure
without causing memory leaks, it is necessary to use linear closure-functions
unless GC can be relied upon to reclaim memory.\

')
")
#langja("
#para('\

ATS1 での線形クロージャ関数のサポートは、高階関数が必要だけれど実行時のガベージコレクション (GC)
が使えないような場面で重要でした。
ATS2 では、線形クロージャ関数は GC のない高階関数を使ったプログラミングでも重要ではなくなりました。
好都合なことにテンプレートを使うことができるのです。
けれども、もしメモリリークを引き起こさずにデータ構造にクロージャ関数を埋め込みたい場合で、
さらにメモリを再利用するために GC に頼ることもできない場合には、
線形クロージャ関数の使用が必要になります。\

')
")

</sect1>#comment("sect1/id=heap-allocated-linear-closure-functions")

<!-- ****** ****** -->

</chapter>
<!--id="introduction_to_views_and_viewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
