%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="programming_with_theorem-proving">
#langeng("
#title("Programming with Theorem-Proving")
")
#langja("
#title("定理証明によるプログラミング")
")

#langeng("
#para("\

#emphasis("Programming with Theorem-Proving") (PwTP) is a rich and broad
programming paradigm that allows cohesive construction of programs and
proofs in a syntactically intwined manner. The support for PwTP in ATS is a
signatory feature of ATS, and the novelty of ATS largely stems from it. For
people who are familiar with the so-called Curry-Howard isomorphism, I
emphasize that PwTP as is supported in ATS makes little, if any, essential
use of this isomorphism (between proofs and programs): The dynamics of ATS
in which programs are written is certainly not pure and the proofs encoded
in ATS/LF are not required to be constructive, either. However, that proof
construction in ATS can be done in a style of (functional) programming is
fundamentally important in terms of syntax design for ATS, for the need to
combine programs with proofs would otherwise be greatly more challenging.

")
")
#langja("
#para("\

#emphasis("定理証明によるプログラミング - Programming with Theorem-Proving") (PwTP)
は豊かで広いプログラミングパラダイムで、プログラムと証明が構文的に絡み合って密着させることができます。
PwTP をサポートすることは ATS の主要な機能で、ATS の新規性は主にここにあります。
カリー＝ハワード同型対応に馴染んだ人々にとって、少しでも証明とプログラムの間でこの同型を本質的に使ったことがあれば、ATS
でサポートされている PwTP は簡単であることを強調したいです:
書かれた ATS プログラムの動的な部分はもちろん純粋ではありませんし、
ATS/LF にエンコードされた証明は積極的に必要なわけでもありません。
けれども、ATS での関数型プログラミングのスタイルで記述できる証明の構築は ATS
のデザインの観点で根本的に重要です。
プログラムを証明と結合することが必要なのです。

")
")

#langeng("
#para("\
In this chapter, I will present some simple but convincing examples to
illustrate the power and flexibility of PwTP as is supported in
ATS. However, the real showcase for PwTP will not arrive until after the
introduction of linear types in ATS, when linear proofs can be combined
with programs to track and safely manipulate resources such as memory and
objects (e.g, file handles). In particular, PwTP is to form the cornersone
of the support for imperative programming in ATS.
")
")
#langja("
#para("\
この章では、単純だけれど説得力のある例を使って ATS でサポートされる PwTP のパワー柔軟性を説明します。
けれでも、PwTP を使った実用例は ATS の線形型を導入した後まで紹介できません。
線形型の証明はプログラムと結合して、メモリやオブジェクト (例: ファイルハンドル)
のようなリソースを追跡したり安全に操作したりすることができます。
特に、PwTP は ATS における命令型プログラミングをサポートする土台となります。
")
")

#langeng("
#para("\
Please find #mycodelink("CHAP_PRGTHMPRV/", "on-line")
the code employed for illustration in this chapter plus some additional
code for testing.\
")
")
#langja("
#para("\
この章で解説するコードと追加のテストコードは
#mycodelink("CHAP_PRGTHMPRV/", "オンライン")
から入手できます。\
")
")

<!-- ****** ****** -->

<sect1
id="circumventing_nonlinear_constraints">
#langeng("
#title("Circumventing Nonlinear Constraints")
")
#langja("
#title("非線形の制約を回避する")
")

#langeng("
#para("
The constraint-solver of ATS is of rather diminished power. In particular,
constraints containing nonlinear integer terms (e.g., those involving the
use of multiplication (of variables)) are immediately rejected. This
weakness must be properly addressed for otherwise it would become a
crippling limitation on practicality of the type system of ATS. I now use
a simple example to demonstrate how theorem-proving can be employed to
circumvent the need for handling nonlinear constraints directly.
")#comment("para")
")
#langja("
#para("
ATS の制約ソルバはやや非力な力しか持っていません。
特に、非線形の整数項を含む制約 (例: 値の乗法の使用を意味するような制約) はただちに破棄されます。
この非力さは当然対策されるべきです。さもなくば ATS の型システムの実用性における深刻な制限になってしまいます。
ここでは単純な例を使って、非線形の制約を直接扱う必要性を回避して定理証明を使うことができるのか説明します。
")#comment("para")
")

#langeng("
#para("\

A function template #dyncode("list_concat") is implemented as follows:

#atscode("\
//
// [list_concat] does not typecheck!!!
//
fun{
a:t@ype
} list_concat{m,n:nat}
  (xss: list (list (a, n), m)): list (a, m * n) =
  case+ xss of
  | list_cons (xs, xss) => list_append<a> (xs, list_concat xss)
  | list_nil () => list_nil ()
// end of [list_concat]
")

where the interface for #dyncode("list_append") is given below:

#atscode("\
fun{
a:t@ype
} list_append {n1,n2:nat}
  (xs: list (a, n1), ys: list (a, n2)): list (a, n1+n2)
")

Given a list #dyncode("xss") of length #stacode("m") in which each element is of
the type #stacode("list(T,n)") for some type T,
#dyncode("list_concat&lt;T&gt;(xss)") constructs a list of the type
#stacode("list(T,m*n)"). When the first matching clause in the code for
#dyncode("list_concat") is typechecked, a constraint is generated that is
essentially like the following one:

#atscode("\
m = m1 + 1 implying n + (m1 * n) = m * n holds for all natural numbers m, m1 and n.
")

This contraint may look simple, but it was once rejected by the ATS
constraint solver as it contains nonlinear integer terms (e.g.,
#stacode("m1*n") and #stacode("m*n")). In order to overcome (or rather
circumvent) the limitation, we can make use of theorem-proving. Another
implementation of #dyncode("list_concat") is given as follows:

#atscode("\
fun{
a:t@ype
} list_concat{m,n:nat}
(
  xss: list (list (a, n), m)
) : [p:nat] (MUL (m, n, p) | list (a, p)) =
  case+ xss of
  | list_cons (xs, xss) => let
      val (pf | res) = list_concat (xss)
    in
      (MULind pf | list_append<a> (xs, res))
    end
  | list_nil () => (MULbas () | list_nil ())
// end of [list_concat]
")

Given a list #dyncode("xss") of the type #stacode("list(list(T,n),m)"),
#dyncode("list_concat(xss)") now returns a pair #dyncode("(pf | res)") such
that #dyncode("pf") is a proof of the prop-type #stacode("MUL(m,n,p)") for
some natural number #stacode("p") and #dyncode("res") is a list of the type
#stacode("list(T,p)"), where the symbol bar (|) is used to separate proofs
from values. In other words, #dyncode("pf") acts as a witness to the
equality #stacode("p=m*n"). After proof erasure is performed, this
implementation of #dyncode("list_concat") is essentially translated into
the previous one (as far as dynamic semantics is concerned). In particular,
there is no need for proof construction at run-time.\

")#comment("para")
")
#langja("
#para("\

関数テンプレート #dyncode("list_concat") は次のような実装です:

#atscode("\
//
// [list_concat] does not typecheck!!!
//
fun{
a:t@ype
} list_concat{m,n:nat}
  (xss: list (list (a, n), m)): list (a, m * n) =
  case+ xss of
  | list_cons (xs, xss) => list_append<a> (xs, list_concat xss)
  | list_nil () => list_nil ()
// end of [list_concat]
")

#dyncode("list_append") のインターフェイスは次のようになります:

#atscode("\
fun{
a:t@ype
} list_append {n1,n2:nat}
  (xs: list (a, n1), ys: list (a, n2)): list (a, n1+n2)
")

長さ #stacode("m") のリスト #dyncode("xss") が与えられ、その要素がある型 T について型 #stacode("list(T,n)")
である時、#dyncode("list_concat&lt;T&gt;(xss)") は型 #stacode("list(T,m*n)") のリストをコンストラクトします。
#dyncode("list_concat") のコードの最初のマッチ節が型検査されると、本質的に次のような制約が発生します:

#atscode("\
全ての自然数 m, m1, n について、m = m1 + 1 は n + (m1 * n) = m * n を意味している。
")

この制約は単純に見えますが、非線形な整数の項 (例: #stacode("m1*n") や #stacode("m*n"))
を含んでいるので ATS の制約ソルバは破棄してしまいます。
この制限を克服 (もしくは回避) すれば、定理証明を使えるようになるはずです。
#dyncode("list_concat") の別の実装は次のようになります:

#atscode("\
fun{
a:t@ype
} list_concat{m,n:nat}
(
  xss: list (list (a, n), m)
) : [p:nat] (MUL (m, n, p) | list (a, p)) =
  case+ xss of
  | list_cons (xs, xss) => let
      val (pf | res) = list_concat (xss)
    in
      (MULind pf | list_append<a> (xs, res))
    end
  | list_nil () => (MULbas () | list_nil ())
// end of [list_concat]
")

型 #stacode("list(list(T,n),m)") のリスト #dyncode("xss") が与えられた時、
#dyncode("list_concat(xss)") はペア #dyncode("(pf | res)") を返します。
このペアの中で、自然数 #stacode("p") があるとき #dyncode("pf") は prop 型 #stacode("MUL(m,n,p)") の証明で、
#dyncode("res") は型 #stacode("list(T,p)") のリストです。
この記号バー (|) は証明と値を分離するために使われます。
別の言い方をすると、#dyncode("pf") は等式 #stacode("p=m*n") の証拠となります。
証明が削除されると、#dyncode("list_concat") のこの実装は本質に (関係する動的な意味論に関する限りは)
以前のバージョンに変換されます。
特に実行時には証明の構成は不要になります。\

")#comment("para")
")

</sect1><!--"circumventing_nonlinear_constraints"-->

<!-- ****** ****** -->

<sect1
id="example_safe_matrix_subscripting">
#langeng("
#title("Example: Safe Matrix Subscripting")
")
#langja("
#title("例: 安全な行列の添字演算")
")

#langeng("
#para("\

Internally, a matrix of the dimension m by n is represented as an array
of the size m*n. For matrix subscripting, we need to implement a function
template of the following interface:

#atscode("\
extern
fun{
a:t@ype
} matrix_get
  {m,n:int}{i,j:nat | i < m; j < n}
  (A: arrayref (a, m*n), col: int n, i: int i, j: int j): a
// end of [matrix_get]
")

Assume that the matrix is represented in the row-major style. Then the
element indexed by i and j in the matrix is the element indexed by i*n + j
in the array that represents the matrix, where i and j are natural numbers
less than m and n, respectively. However, the following implementation
fails to pass typechecking:

#atscode("\
implement{a}
matrix_get (A, n, i, j) = A[i*n+j] // it fails to typecheck!!!
")#comment("para")

The simple reason for this failure is due to the ATS constraint solver not
being able to automatically verify that i*n+j is a natural number strictly
less than m*n. An implementation of #dyncode("matrix_get") that typechecks
can be given as follows:

#atscode("\
implement
{a}(*tmp*)
matrix_get
  {m,n}{i,j}
  (A, n, i, j) = let
//
  val (pf_i_n | _i_n) = imul2 (i, n)
  prval () = mul_nat_nat_nat (pf_i_n)
  prval () = mul_gte_gte_gte{m-1-i,n} ()
  prval () = mul_elim (pf_i_n)
//
in
  A[_i_n+j]
end // end of [matrix_get]
")

where the functions called in the body of #dyncode("matrix_get")
are assigned the following interfaces:

#atscode("\
fun imul2{i,j:int}
  (i: int i, j: int j): [ij:int] (MUL (i, j, ij) | int ij)

prfun mul_nat_nat_nat
  {i,j:nat}{ij:int} (pf: MUL (i, j, ij)): [ij >= 0] void

prfun mul_gte_gte_gte
  {m,n:int | m >= 0; n >= 0} ((*void*)): [m*n >= 0] void

prfun mul_elim
  {i,j:int}{ij:int} (pf: MUL (i, j, ij)): [i*j==ij] void
")

Assume that m and n are natural numbers and i and j are natural numbers
less than m and n, respectively.  The proof code employed in the
implementation of #dyncode("matrix_get") to show i*n+j &lt; m*n proves
(m-1-i)*n &gt;= 0, which clearly implies m*n >= i*n+n > i*n+j.

")#comment("para")
")
#langja("
#para("\

内部では、次元 m x n の行列はサイズ m*n の配列として表現されます。
行列の添字演算のために、次のインターフェイスの関数テンプレートを実装する必要があります:

#atscode("\
extern
fun{
a:t@ype
} matrix_get
  {m,n:int}{i,j:nat | i < m; j < n}
  (A: arrayref (a, m*n), col: int n, i: int i, j: int j): a
// end of [matrix_get]
")

行列が行優先スタイルで表現されていると仮定しましょう。
すると、その行列の i と j で指定された要素は、その行列を表現する配列では i*n + j で指定されることになります。
ここで、i と j はそれぞれ m と n より小さい自然数です。
けれども、次の実装の型検査には失敗します:

#atscode("\
implement{a}
matrix_get (A, n, i, j) = A[i*n+j] // it fails to typecheck!!!
")#comment("para")

この推論失敗の簡単な理由は、i*n+j が m*n より正確に小さい自然数であることを、
ATS の制約ソルバが自動的に検査できないためです。
型検査を通る #dyncode("matrix_get") の実装は次のようになります:

#atscode("\
implement
{a}(*tmp*)
matrix_get
  {m,n}{i,j}
  (A, n, i, j) = let
//
  val (pf_i_n | _i_n) = imul2 (i, n)
  prval () = mul_nat_nat_nat (pf_i_n)
  prval () = mul_gte_gte_gte{m-1-i,n} ()
  prval () = mul_elim (pf_i_n)
//
in
  A[_i_n+j]
end // end of [matrix_get]
")

#dyncode("matrix_get") の本体から呼び出される関数には次のインターフェイスが割り当てられています:

#atscode("\
fun imul2{i,j:int}
  (i: int i, j: int j): [ij:int] (MUL (i, j, ij) | int ij)

prfun mul_nat_nat_nat
  {i,j:nat}{ij:int} (pf: MUL (i, j, ij)): [ij >= 0] void

prfun mul_gte_gte_gte
  {m,n:int | m >= 0; n >= 0} ((*void*)): [m*n >= 0] void

prfun mul_elim
  {i,j:int}{ij:int} (pf: MUL (i, j, ij)): [i*j==ij] void
")

m と n が自然数で、i と j がそれぞれ m と n より小さい自然数であると仮定します。
i*n+j &lt; m*n を示すために #dyncode("matrix_get") の実装で用いられている証明コードは、
(m-1-i)*n &gt;= 0 を証明しています。
これは明確に m*n >= i*n+n > i*n+j を暗示しています。

")#comment("para")
")

#langeng("
#para("

Note that there are a variety of proof functions declared in
#myatscodelink("prelude/SATS/arith_prf.sats", "arith_prf.sats") for helping prove
theorems involving arithmetic operations. For examples of proof
construction in ATS, please find the implementation of some of these proof
functions in #myatscodelink("prelude/DATS/arith_prf.dats", "arith_prf.dats").\

")#comment("para")
")
#langja("
#para("

様々な証明関数が #myatscodelink("prelude/SATS/arith_prf.sats", "arith_prf.sats")
で宣言されていることに注意してください。
これらの証明は算術演算を含む定理を証明するのに役に立ちます。
ATSにおける証明の構成例として、#myatscodelink("prelude/DATS/arith_prf.dats", "arith_prf.dats")
にある証明関数の実装を参照してください。\

")#comment("para")
")

#langeng("
#para("\

The entirety of the above presented code is available
#mycodelink("CHAP_PRGTHMPRV/matget.dats", "on-line").\

")#comment("para")
")
#langja("
#para("\

この章のコード全体は
#mycodelink("CHAP_PRGTHMPRV/matget.dats", "オンライン")
から入手できます。\

")#comment("para")
")

</sect1><!--"example_safe_matrix_subscripting"-->

<!-- ****** ****** -->

<sect1
id="specifying_with_precision"
xreflabel="specifying with enhanced precision">
#langeng("
#title("Specifying with Enhanced Precision")
")
#langja("
#title("強化された正確性を使って明記する")
")

#langeng("
#para("
The integer addition function can be assigned the following
(dependent) type in ATS to indicate that it returns the sum of
its two integer arguments:

#atscode("\
{i,j:int} (int (i), int (j)) -> int (i+j)
")

This type gives a full specification of integer addition as the only
(terminating) function that can be given the type is the integer addition
function. However, the factorial function, which yields the product of the
first n positive integers when applied to a natural number n, cannot be
given the following type:

#atscode("\
{n:nat} int (n) -> int (fact(n))
")

as #stacode("fact"), which refers to the factorial function, does not exist in
the statics of ATS. Evidently, a highly interesting and relevant question is
whether a type can be formed in ATS that fully captures the functional
relation specified by #stacode("fact")? The answer is affirmative. We can not
only construct such a type but also assign it to a (terminating) function
implemented in ATS.\

")#comment("para")
")
#langja("
#para("
整数の加算関数には ATS では次のような依存型を割り当てることができます。
これはこの関数が2つの整数の引数の和を返すことを示しています:

#atscode("\
{i,j:int} (int (i), int (j)) -> int (i+j)
")

この型は整数の加算に対する完全な仕様です。この型を取るような停止する関数は、整数の加算関数だけです。
けれども、自然数 n に適用すると最初の n 個の正の整数の積を得るような、階乗関数には次のような型を与えることができません:

#atscode("\
{n:nat} int (n) -> int (fact(n))
")

階乗関数を指す #stacode("fact") は ATS の静的な部分には存在しないからです。
明らかに、大変興味深く適切な疑問は次のようなものでしょう。
#stacode("fact") で明記された関数的関係を完全に捕捉するような型を ATS で作れるのでしょうか？
その答は肯定的なものです。
そのような型をコンストラクトできるだけでなく、ATS で実装された停止する関数に適用することもできるのです。\

")#comment("para")
")

#langeng("
#para("\
Let us recall that the factorial function can be defined by the following
two equations:

#atscode("\
fact(0) = 1
fact(n) = n * fact(n-1) (for all n > 0)
")

Naturally, these equations can be encoded by the constructors associated
with the dataprop #stacode("FACT") declared as follows:

#atscode("\
dataprop FACT (int, int) =
  | FACTbas (0, 1)
  | {n:nat}{r1,r:int}
    FACTind (n, r) of (FACT (n-1, r1), MUL (n, r1, r))
// end of [FACT]
")

Note that for any given natural number n and integer r, #stacode("FACT(n,
r)") can be assigned to a proof if and only if #dyncode("fact(n)") equals
r. Therefore, the following type:

#atscode("\
{n:nat} int (n) -> [r:int] (FACT (n, r) | int (r))
")

can only be assigned to a function that, if applied to a natural number n,
returns a proof and an integer such that the proof attests to the integer
being equal to #dyncode("fact(n)"). For instance, the following defined
function #dyncode("ifact") is assigned this type:

#atscode("\
fun ifact
  {n:nat} .<n>.
  (n: int (n)):<> [r:int] (FACT (n, r) | int r) =
(
  if n > 0 then let
    val (pf1 | r1) = ifact (n-1) // pf1: FACT (n-1, r1)
    val (pfmul | r) = imul2 (n, r1) // pfmul: FACT (n, r1, r)
  in (
    FACTind (pf1, pfmul) | r
  ) end else (
    FACTbas () | 1 // the base case
  ) // end of [if]
) (* end of [ifact] *)
")

After proof erasure, #dyncode("ifact") precisely implements the factorial
function.

")#comment("para")
")
#langja("
#para("\
階乗関数は次の2つの等式で定義できることを思い出してみましょう:

#atscode("\
fact(0) = 1
fact(n) = n * fact(n-1) (n > 0 のような全ての n について)
")

当然これらの等式は、次のように宣言される dataprop #stacode("FACT")
に関連したコンストラクタでエンコードできます:

#atscode("\
dataprop FACT (int, int) =
  | FACTbas (0, 1)
  | {n:nat}{r1,r:int}
    FACTind (n, r) of (FACT (n-1, r1), MUL (n, r1, r))
// end of [FACT]
")

与えられたどのような自然数 n と 整数 r についても、
#dyncode("fact(n)") が r に等しいかどうか証明するために #stacode("FACT(n, r)")
を割り当てられることに注意してください。
したがって、次のような型:

#atscode("\
{n:nat} int (n) -> [r:int] (FACT (n, r) | int (r))
")

は自然数 n に適用されると証明と整数を返すような関数にのみ割り当てることができます。
この証明はその整数が #dyncode("fact(n)") に等しいことを立証しています。
例えば、次に定義された関数 #dyncode("ifact") にはこの型が割り当てられています:

#atscode("\
fun ifact
  {n:nat} .<n>.
  (n: int (n)):<> [r:int] (FACT (n, r) | int r) =
(
  if n > 0 then let
    val (pf1 | r1) = ifact (n-1) // pf1: FACT (n-1, r1)
    val (pfmul | r) = imul2 (n, r1) // pfmul: FACT (n, r1, r)
  in (
    FACTind (pf1, pfmul) | r
  ) end else (
    FACTbas () | 1 // the base case
  ) // end of [if]
) (* end of [ifact] *)
")

証明が削除されると、#dyncode("ifact") は階乗関数の正確な実装になります。

")#comment("para")
")

#langeng("
#para("\

Please find the entirety of the above presented code plus some testing code
#mycodelink("CHAP_PRGTHMPRV/ifact.dats", "on-line").

")
")
#langja("
#para("\

この章で紹介したコードの全体とテストのための追加コードは
#mycodelink("CHAP_PRGTHMPRV/ifact.dats", "オンライン")
から入手できます。

")
")

</sect1><!--"specifying_with_precision"-->

<!-- ****** ****** -->

<sect1
id="example_another_verified_factorial">
#title("Example: Another Verified Factorial")

#para("\

The function #dyncode("ifact") presented in the section on <xref
linkend=\"specifying_with_precision\"/> is a verified implementation of
the factorial function as its type guarantees that #dyncode("ifact")
implements the specification of factorial encoded by the dataprop
#stacode("FACT"). Clearly, the implementation of #dyncode("ifact") closely
follows the declaration of #stacode("FACT"). If we think of the latter as a
logic program, then the former is essentially a functional version
extracted from the logic program. However, the implementation of a
specification in practice can often digress far from the specification
algorithmically. For instance, we may want to have a verified
implementation of factorial that is also tail-recursive. This can be done
as follows:

#atscode("\
fun ifact2
  {n:nat} .<>.
(
  n: int (n)
) :<> [r:int] (FACT (n, r) | int r) = let
  fun loop
    {i:nat | i <= n}{r:int} .<n-i>.
  (
    pf: FACT (i, r) | n: int n, i: int i, r: int r
  ) :<> [r:int] (FACT (n, r) | int r) =
    if n - i > 0 then let
      val (pfmul | r1) = (i+1) imul2 r in loop (FACTind (pf, pfmul) | n, i+1, r1)
    end else (pf | r) // end of [if]
  // end of [loop]
in
  loop (FACTbas () | n, 0, 1)
end // end of [ifact2]
")

The function #dyncode("ifact2") is assigned a type indicating that
#dyncode("ifact2") is a verified implementation of factorial, and it is
defined as a call to the inner function #dyncode("loop") that is clearly
tail-recursive.  If we erase types and proofs, the function #dyncode("ifact2")
is essentially defined as follows:

#atscode("\
fun ifact2 (n) = let
  fun loop (n, i, r) =
    if n - i > 0 then let
      val r1 = (i+1) * r in loop (n, i+1, r1)
    end else r
  // end of [loop]
in
  loop (n, 0, 1)
end // end of [ifact2]
")

When the inner function #dyncode("loop") is called on three arguments n, i
and r, the precondition for this call is that i is natural number less than
or equal to n and r equals fact(i), that is, the value of the factorial
function on i. This precondition is captured by the type assigned to
#dyncode("loop") and thus enforced at each call site of #dyncode("loop") in
the implementation of #dyncode("ifact2").

")#comment("para")

#para("\

Please find #mycodelink("CHAP_PRGTHMPRV/ifact23.dats", "on-line")
the entirety of the above presented code plus some testing code.\

")

</sect1><!--"example_another_verified_factorial"-->

<!-- ****** ****** -->

<sect1
id="example_verified_fast_exponentiation">
#title("Example: Verified Fast Exponentiation")

#para("\
Given an integer x, pow(x, n), the nth power of x, can be defined
inductively as follows:

#atscode("\
pow (x, 0) = 1
pow (x, n) = x * pow (x, n-1) (for all n > 0)
")

A direct implementation of this definition is given as follows:

#atscode("\
fun ipow {n:nat} .<n>.
  (x: int, n: int n): int = if n > 0 then x * ipow (x, n-1) else 1
// end of [ipow]
")

which is of time-complexity O(n) (assuming multiplication is O(1)). A
more efficient implmentation can be given as follows:

#atscode("\
fun ifastpow {n:nat} .<n>.
  (x: int, n: int n): int =
  if n > 0 then let
    val n2 = n/2; i = n-(2*n2)
  in
    if i > 0 then ifastpow (x*x, n2) else x * ifastpow (x*x, n2)
  end else 1
// end of [ifastpow]
")

which makes use of the property that pow(x, n) equals pow(x*x, n/2) if n is
even or x * pow(x*x, n/2) if n is odd. This is referred to as fast
exponentiation. Note that #dyncode("ifastpow") is of time-complexity O(log(n)).

")#comment("para")

#para("\

Clearly, what is done above is not restricted to exponentiation on
integers. As long as the underlying multiplication is associative, fast
exponentiation can be employed to compute powers of any given element. In
particular, powers of square matrices can be computed in this way.  I now
present as follows a verified generic implementation of fast exponentiation.

")#comment("para")

#para("\
Handling generic data properly in a verified implementation often requires some
finesse with the type system of ATS. Let us first introduce an abstract type
constructor #stacode("E") as follows:

#atscode("\
sortdef elt = int // [elt] is just an alias for [int]
abst@ype E (a:t@ype, x:elt) = a // [x] is an imaginary stamp
")

This is often referred to as #emphasis("stamping"). For each type T and stamp
x, #stacode("E(T, x)") is just T as far as data representation is concerned.
The stamps are imaginary and they are solely used for the purpose of
specification. We next introduce an abstract prop-type #stacode("MUL") and
a function template #dyncode("mul_elt_elt"):

#atscode("\
absprop MUL (elt, elt, elt) // abstract mul relation

fun{a:t@ype}
mul_elt_elt {x,y:elt}
  (x: E (a, x), y: E (a, y)): [xy:elt] (MUL (x, y, xy) | E (a, xy))
// end of [mul_elt_elt]
")

Please do not confuse #stacode("MUL") with the one of the same name that is
declared in #myatscodelink("prelude/SATS/arith_prf.sats", "arith_prf.sats"). To
state that the encoded multiplication is associative, we can introduce the
following proof function:

#atscode("\
praxi mul_assoc
  {x,y,z:elt}{xy,yz:elt}{xy_z,x_yz:elt}
(
  pf1: MUL (x, y, xy), pf2: MUL (xy, z, xy_z)
, pf3: MUL (y, z, yz), pf4: MUL (x, yz, x_yz)
) : [xy_z==x_yz] void
")

The keyword #keycode("praxi") indicates that #dyncode("mul_assoc") is treated as
a form of axiom, which is not expected to be implemented.

")#comment("para")

#para("
The abstract power function can be readily specified in terms of the
abstract prop-type #stacode("MUL"):

#atscode("\
dataprop POW (
  elt(*base*), int(*exp*), elt(*res*)
) = // res = base^exp
  | {x:elt} POWbas (x, 0, 1(*unit*))
  | {x:elt}{n:nat}{p,p1:elt}
    POWind (x, n+1, p1) of (POW (x, n, p), MUL (x, p, p1))
// end of [POW]
")

As can be expected, generic fast exponentiation is given the following
interface:

#atscode("\
fun{a:t@ype}
fastpow_elt_int{x:elt}{n:nat}
  (x: E (a, x), n: int n): [p:elt] (POW (x, n, p) | E (a, p))
// end of [fastpow_elt_int]
")

")#comment("para")

#para("
With the preparation done above, a straightforward implementation of
#dyncode("fastpow_elt_int") can now be presented as follows:

#atscode("\
implement{a}
fastpow_elt_int (x, n) = let
//
// lemma: (x*x)^n = x^(2n)
//
extern
prfun
lemma{x:elt}{xx:elt}{n:nat}{y:elt}
  (pfxx: MUL (x, x, xx), pfpow: POW (xx, n, y)): POW (x, 2*n, y)
//
in
  if n > 0 then let
    val n2 = n / 2; val i = n - (n2+n2) // i = 0 or 1
    val (pfxx | xx) = mul_elt_elt (x, x) // xx = x*x
    val (pfpow2 | res) = fastpow_elt_int<a> (xx, n2) // xx^n2 = res
    prval pfpow = lemma (pfxx, pfpow2) // pfpow: x^(2*n2) = res
  in
    if i > 0 then let
      val (pfmul | xres) = mul_elt_elt<a> (x, res) // xres = x*res
    in
      (POWind (pfpow, pfmul) | xres)
    end else (pfpow | res)
  end else let
    val res = mulunit<a> () in (POWbas () | res) // res = 1
  end (* end of [if] *)
end // end of [fastpow_elt_int]
")

Note that this implementation of #dyncode("fastpow_elt_int") is not
tail-recursive.  The function template #dyncode("mulunit"), which is called to
produce a unit for the underlying multiplication, is assigned the following
interface:

#atscode("\
fun{a:t@ype} mulunit (): E (a, 1(*stamp*))
")

The proof function #dyncode("lemma") simply establishes that pow(x, 2*n)=
pow(x*x, n) for each natural number n.  I have made an implementation of
#dyncode("lemma") available on-line but I suggest that the interested
reader give it a try first before taking a look. Note that the following
axioms are needed to implement #dyncode("lemma"):

#atscode("\
praxi
mul_istot // [MUL] is total
  {x,y:elt} ((*void*)): [xy:elt] MUL (x, y, xy)
praxi
mul_isfun{x,y:elt}{z1,z2:elt} // MUL is functional
  (pf1: MUL (x, y, z1), pf2: MUL (x, y, z2)): [z1==z2] void
")

Another interesting (and possibly a bit challenging) exercise is to
implement #dyncode("fastpow_elt_int") in a tail-recursive fashion.

")#comment("para")

#para("\

Please find on-line the two files
#mycodelink("CHAP_PRGTHMPRV/fastexp.sats", "fastexp.sats") and
#mycodelink("CHAP_PRGTHMPRV/fastexp.dats", "fastexp.dats") that contain the
entirety of the above presented code.

")

#para("\

Now we have implemented #dyncode("fastpow_elt_int"). How can it be used?
Please find #mycodelink("CHAP_PRGTHMPRV/test_fastexp.dats", "on-line") an
example in which #dyncode("fastpow_elt_int") is called to implement fast
exponentiation on a 2-by-2 matrix so that the Fibonacci numbers can be computed
in a highly efficient manner.

")

</sect1><!--"example_verified_fast_exponentiation"-->

<!-- ****** ****** -->

</chapter><!--"programming_with_theorem-proving"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
