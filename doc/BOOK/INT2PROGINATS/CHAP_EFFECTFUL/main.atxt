%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="effecftul_programming_features">
#langeng("
#title("Effectful Programming Features")
")
#langja("
#title("効果 (effect) を持つプログラミングの機能")
")

#langeng("
#para("\

Effectful programming features are those that can generate effects at
run-time. But what is really an effect? The answer to this question is
rather complex as it depends on the model of evaluation. I will gradually
introduce various kinds of effects in this book. In sequential programming,
that is, constructing programs to be evaluated sequentially (in contrast to
concurrently), an expression is effectless if there exists a value such
that the expression and the value cannot be distinguished as far as
evaluation is concerned. For instance, the expression #dyncode("1+2") is
effectless as it cannot be distinguished from the value #dyncode("3"). An
effectless expression is also said to be pure.  On the other hand, an
effectful expression is one that can be distinguished from any given
values. For instance, the expression #dyncode('print("Hello")') is
effectful as its evaluation results in an observable behavior that
distinguishes the expression from any values.  In this case,
#dyncode('print("Hello")') is said to certain I/O effect.  If the
evaluation of an expression never terminates, then the expression is also
effectul. For instance, let us define a function #dyncode("loop") as
follows:

#atscode("\
fun loop (): void = loop ()
")

Then the expression #dyncode("loop()") can be distinguished from
any values in the following context:

#atscode('\
let val _ = [] in print ("Terminated") end
')

If the hole #dyncode("[]") in the context is replaced with
#dyncode("loop()"), then the evaluation of the resulting expression
continues forever.  If the hole #dyncode("[]") is replaced with any value,
then the evaluation leads to the string \"Terminated\" being printed out.
The expression #dyncode("loop") is said to contain non-termination effect.\

")#comment("para")
")#comment("langeng")
#langja("
#para("\

効果 (effect) を持つプログラミングの機能を使うことで実行時に効果を生成することができます。
ところで効果とは一体何でしょうか？
その答はいくぶん込み入っていて、評価モデルに依存しています。
この本では様々な種類の効果を徐々に説明します。
並行ではなく順番に評価がなされるようなプログラムを作る場合、評価に関してある式とその値が見分けがつかない時、その式は効果を持ちません。
例えば、値 #dyncode("3") と見分けがつかないので、式 #dyncode("1+2") は効果を持ちません。
効果を持たない式は純粋であるとも言えます。
他方、効果を持つ式はいかなる値とも区別ができます。
例えば、式 #dyncode('print("Hello")') は効果を持ちます。
というのもその評価の結果、観測可能な振舞をひきおこすので、式はいかなる値とも見分けがつくからです。
この例では #dyncode('print("Hello")') は I/O に対するある効果を持つと言えます。
もし式の評価が終了しない場合、その式もまた効果を持ちます。
例えば、次のような #dyncode("loop") 関数を定義してみましょう:

#atscode("\
fun loop (): void = loop ()
")

すると次のような文脈で、式 #dyncode("loop()") はいかなる値とも区別ができます:

#atscode('\
let val _ = [] in print ("Terminated") end
')

この文脈の空欄 #dyncode("[]") を #dyncode("loop()") で置き換えると、式の評価は完了しません。
空欄 #dyncode("[]") をなんらかの値に置き換えると、その評価は文字列 \"Terminated\" を印字するでしょう。
式 #dyncode("loop") はある非停止性の効果を持つを言えます。\

")#comment("para")
")#comment("langja")

#langeng("
#para("\

I will cover programming features related to exceptional control-flow,
persistent memory storage and simple I/O in this chapter, which are all of
common use in practical programming.\

")
")
#langja("
#para("\

この章では、例外コントロールフローと永続化メモリ記憶、シンプルな I/O に関連するプログラミングの機能を説明します。
これらは実際のプログラミングで一般的に使われるものです。\

")
")

#langeng("
#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_EFFECTFUL/", "on-line").\

")
")
#langja("
#para("\

この章に出てくるコードとテストのための追加コードは
#mycodelink("CHAP_EFFECTFUL/", "オンライン")
から得られます。\

")
")

<sect1
id="exceptions">
#langeng("
#title("Exceptions")
")
#langja("
#title("例外")
")

#langeng("
#para("\

The exception mechanism provides an efficient means for reporting a special
condition encountered during program evaluation. Often such a special
condition indicates an error, but it is not uncommon to employ exceptions
to address issues that are not related to errors.\

")
")
#langja("
#para("\

例外機構は、プログラムの評価中に発生した特殊な状態を通知するための効果的な方法です。
しばしばそのような特殊な状態はエラーを指しますが、エラーに関連しない事柄を指す例外を使うこともあります。\

")
")

#langeng("
#para("\

The type #stacode("exn") is predefined in ATS. One may think of
#stacode("exn") as an extensible datatype for which new constructors can
always be declared. For instance, two exception constructors are declared
as follows:

#atscode("\
exception FatalError0 of ()
exception FatalError1 of (string)
")

The constructor #dyncode("FatalError0") is nullary while the constructor
#dyncode("FatalError1") is unary.  Exception values, that is, values of
the type #stacode("exn") can be formed by applying exception constructors
to proper arguments. For instance, #dyncode("FatalError0()") and
#dyncode('FatalError1("division-by-zero")') are two exception values (or
simply exceptions). In the following program, a function for integer
division is implemented:

#atscode("\
exception DivisionByZero of ()
fun divexn (x: int, y: int): int =
  if y != 0 then then x / y else $raise DivisionByZero()
// end of [divexn]
")

When the function call #dyncode("divexn(1, 0)") is evaluated, the exception
#dyncode("DivisionByZero()") is raised. The keyword #dyncode("$raise") in ATS
is solely for raising exceptions.\

")#comment("para")
")#comment("langeng")
#langja("
#para("\

ATS では #stacode("exn") 型があらかじめ定義されています。
#stacode("exn") は、新しいコンストラクタによって宣言された拡張データ型であると思うかもしれません。
例えば次のように2つの例外コンストラクタを宣言します:

#atscode("\
exception FatalError0 of ()
exception FatalError1 of (string)
")

#dyncode("FatalError0") コンストラクタは引数を取らず、#dyncode("FatalError1")
コンストラクタは引数を1つ取ります。
例外の値は #stacode("exn") 型の値で、例外コンストラクタを適切な引数に適用することで作られます。
例えば #dyncode("FatalError0()") と #dyncode('FatalError1("division-by-zero")')
は2つとも例外の値です (もしくは単に例外と呼ぶこともあります)。
次のプログラムでは、整数の割り算を関数として実装しています:

#atscode("\
exception DivisionByZero of ()
fun divexn (x: int, y: int): int =
  if y != 0 then then x / y else $raise DivisionByZero()
// end of [divexn]
")

関数呼び出し #dyncode("divexn(1, 0)") が評価されると、例外 #dyncode("DivisionByZero()")
が発生します。
ATS における #dyncode("$raise") キーワードは例外を発生させます。\

")#comment("para")
")#comment("langja")

#langeng("
#para("\

A raise-expression is of the form (#dyncode("$raise") exp) for some
expression exp.  Clearly, if the evaluation of exp returns a value, then
the evaluation of (#dyncode("$raise") exp) leads to a raised
exception. Therefore, the evaluation of a raise-expression can never return
a value, and this justifies that a raise-expression can be given any type.\

")#comment("para")
")
#langja("
#para("\

なんらかの式 exp が与えられとき (#dyncode("$raise") exp) は raise 式です。
式 exp は値を返しますが、(#dyncode("$raise") exp) を評価すると当然、例外が発生してしまいます。
したがって、raise 式は評価されると値を返しません。つまり raise 式はいかなる型も取りうるのです。\

")#comment("para")
")

#langeng("
#para("\

A raised exception can be captured. If it is not captured, the raised
exception aborts the program evaluation that issued it in the first
place. In ATS, a try-expression (or try-with-expression) is of the form
(#dyncode("try") exp #dyncode("with") clseq), where #dyncode("try") is a
keyword, exp is an expression, #dyncode("with") is also a keyword, and
clseq is a sequence of matching clauses. When evaluating such a
try-expression, we first evaluate exp. If the evaluation of exp leads to a
value, then the value is also the value of the try-expression. If the
evaluation of exp leads to a raised exception, then we match the exception
against the guards of the matching clauses in clseq. If there is a match,
the raised exception is caught and we continue to evaluate the body of the
first clause whose guard is matched. If there is no match, the raised
exception is uncaught. In a try-expression, the with-part is often referred
to as an exception-handler.\

")
")
#langja("
#para("\

発生した例外は捕捉することができます。
もし例外が捕捉されない場合、発生した例外はプログラムの評価を実行開始した地点で終了させます。
ATS では、try 式 (もしくは try-with 式) は
(#dyncode("try") exp #dyncode("with") clseq) のように作られます。
この式では #dyncode("try") キーワード、exp は任意の式、#dyncode("with")
もキーワード、そして clseq はマッチング節の列です。
try 式を評価すると、最初に exp が評価されます。
もし exp の評価が値を返したら、その値が try 式の値となります。
もし exp の評価が例外を発生させたら、clseq に列挙されたマッチング節のガードに対してその例外をマッチさせます。
もしマッチすれば、発生した例外は捕捉され、マッチしたガード最初の節の中身から評価が続行します。
もしマッチしなかったら、発生した例外は捕捉されません。
try 式ではしばしば with 部は例外ハンドラと呼ばれます。\

")
")

#langeng("
#para("\
Let us now see an example that involves raising and capturing an
exception. In the following program, three functions are defined to compute
the product of the integers in a given list:

#atscode("\
fun listprod1
(
  xs: list0 (int)
): int =
(
  case+ xs of
  | list0_nil () => 1
  | list0_cons (x, xs) => x * listprod1 (xs)
) (* end of [listprod1] *)

fun listprod2
(
  xs: list0 (int)
) : int =
(
  case+ xs of
  | list0_nil () => 1
  | list0_cons (x, xs) =>
      if x = 0 then 0 else x * listprod2 (xs)
    // end of [list0_cons]
) (* end of [listprod2] *)

fun listprod3
(
  xs: list0 (int)
) : int = let
  exception ZERO of ()
  fun aux (xs: list0 (int)): int =
    case+ xs of
    | list0_cons (x, xs) =>
        if x = 0 then $raise ZERO() else x * aux (xs)
    | list0_nil () => 1
  // end of [aux]
in
  try aux (xs) with ~ZERO () => 0
end // end of [listprod3]
")

While these functions can all be defined tail-recursively, they are not so
as to make a point that should be clear shortly. Undoubtedly, we all know the
following simple fact:

<itemizedlist>

<listitem>
#para("\
If the integer 0 occurs in a given list, then the product
of the integers in the list is 0 regardless what other integers are.
")
</listitem>

</itemizedlist>

The function #dyncode("listprod1") is defined in a standard manner, and it
does not make any use of the stated fact.  The function
#dyncode("listprod2") is defined in a manner that makes only partial use of
the stated fact. To see the reason, let us evaluate a call to
#dyncode("listprod2") on #dyncode("[1, 2, 3, 0, 4, 5, 6]"), which denotes a
list consisting of the 7 mentioned integers. The evaluation of this call
eventually leads to the evaluation of
#dyncode("1*(2*(3*(listprod([0,4,5,6]))))"), which then leads to
#dyncode("1*(2*(3*0))"), and then to #dyncode("1*(2*0)"), and then to
#dyncode("1*0"), and finally to #dyncode("0"). However, what we really want
is for the evaluation to return 0 immediately once the integer 0 is
encountered in the list, and this is accomplished by the function
#dyncode("listprod3"). When evaluating a call to #dyncode("listprod3") on
#dyncode("[1, 2, 3, 0, 4, 5, 6]"), we eventually reach the evaluation of
the following expression:

#atscode("\
try 1*(2*(3*(aux([0,4,5,6])))) with ~ZERO() => 0
")

Evaluating #dyncode("aux([0,4,5,6])") leads to the exception
#dyncode("ZERO()") being raised, and this raised exception is caught and
#dyncode("0") is returned as the value of the call to
#dyncode("listprod3").  Note that the pattern guard of the matching clause
following the keyword #dyncode("with") is #dyncode("~ZERO()").  I will
explain the need for the tilde symbol #dyncode("~") elsewhere. For now, it
suffices to say that #dyncode("exn") is a linear type and each exception
value is a linear value, which must be consumed or re-raised. The tilde
symbol #dyncode("~") indicates that the value matching the pattern
following #dyncode("~") is consumed (and the memory for holding the value
is freed).\

")
")#comment("langeng")
#langja("
#para("\
例外の発生と捕捉をともなう例を見てみましょう。
次のプログラムでは、与えられたリスト中の整数の積を計算する3つの関数が定義されています:

#atscode("\
fun listprod1
(
  xs: list0 (int)
): int =
(
  case+ xs of
  | list0_nil () => 1
  | list0_cons (x, xs) => x * listprod1 (xs)
) (* end of [listprod1] *)

fun listprod2
(
  xs: list0 (int)
) : int =
(
  case+ xs of
  | list0_nil () => 1
  | list0_cons (x, xs) =>
      if x = 0 then 0 else x * listprod2 (xs)
    // end of [list0_cons]
) (* end of [listprod2] *)

fun listprod3
(
  xs: list0 (int)
) : int = let
  exception ZERO of ()
  fun aux (xs: list0 (int)): int =
    case+ xs of
    | list0_cons (x, xs) =>
        if x = 0 then $raise ZERO() else x * aux (xs)
    | list0_nil () => 1
  // end of [aux]
in
  try aux (xs) with ~ZERO () => 0
end // end of [listprod3]
")

これらの関数は末尾再帰で定義されていますが、ここで主張したいポイントは明確ではありません。
次の事実に疑う余地はないでしょう:

<itemizedlist>

<listitem>
#para("\
与えられたリスト中に整数 0 があった場合、その他の整数値によらずリスト中の整数の積は 0 である。
")
</listitem>

</itemizedlist>

#dyncode("listprod1") 関数は通常の作法で定義されていて、先の定理を使っていません。
#dyncode("listprod2") 関数は先の定理を部分的に使っています。
試しに #dyncode("listprod2") を7つの整数からなるリストである #dyncode("[1, 2, 3, 0, 4, 5, 6]")
に対して呼び出してみましょう。
この呼び出しの評価は結局のところ #dyncode("1*(2*(3*(listprod([0,4,5,6]))))") の評価を導きます。
それから #dyncode("1*(2*(3*0))") が得られ、 #dyncode("1*(2*0)") が、さらに #dyncode("1*0")
が、そして最終的に #dyncode("0") が得られます。
けれども、リスト中に整数 0 を見つけたら、即座に 0 を返すように評価したいと思うでしょう。
このような評価は #dyncode("listprod3") 関数であれば実現できます。
#dyncode("listprod3") を #dyncode("[1, 2, 3, 0, 4, 5, 6]")
に呼び出した場合、最終的に次の式を評価することになります:

#atscode("\
try 1*(2*(3*(aux([0,4,5,6])))) with ~ZERO() => 0
")

#dyncode("aux([0,4,5,6])") の評価は #dyncode("ZERO()") 例外の発生を引き起します。
そしてこの例外は捕捉されて #dyncode("0") が #dyncode("listprod3") 呼び出しの値として返ります。
#dyncode("with") キーワードに続くマッチング節のパターンガードは #dyncode("~ZERO()")
であることに注意してください。
別の章でチルダシンボル #dyncode("~") が必要になる理由を説明します。
ここでは、#dyncode("exn") は線形型で、例外の値は線形値であり、その値は消費されるか再度 raise
しなければならないということだけ覚えておいてください。
チルダシンボル #dyncode("~") は、 #dyncode("~")
に続くパターンにマッチした値が消費されることを示しています。
つまり値を保持しているメモリは解放されるということです。\

")
")#comment("langja")

#langeng("
#para("\

Exceptions are not a programming feature that is easy to master, and
misusing exceptions is abundant in practice. So please be patient when
learning the feature and be cautious when using it.\

")
")
#langja("
#para("\

例外は簡単に使いこなせるようなプログラミングの機能ではありません。
また実際、例外の誤用はたくさんあります。
そのため例外を根気強く学び、注意深く使用してください。\

")
")

</sect1><!--id="exceptions"-->

<sect1
id="example_testing_for_braun_trees">
#langeng("
#title("Example: Testing for Braun Trees")
")
#langja("
#title("例: ブラウンツリーの判定")
")

#langeng("
#para("\

Braun trees are special binary trees that can be defined
inductively as follows:

<itemizedlist>

<listitem>
#para("\
If a binary tree is empty, then it is a Braun tree.
")
</listitem>

<listitem>
#para("\
If both children of a binary tree are Braun trees and the
size of the left child minus the size of the right child equals 0 or 1,
then the binary tree is a Braun tree.
")
</listitem>

</itemizedlist>

Given a natural number n, there is exactly one Braun tree of size n.  It is
straightforward to prove that Braun trees are balanced.\

")
")
#langja("
#para("\

ブラウンツリー (Braun Trees) は、次のような再帰的な定義によって導かれる特殊な二分木です:

<itemizedlist>

<listitem>
#para("\
空の二分木があるとき、そのツリーはブラウンツリーです。
")
</listitem>

<listitem>
#para("\
二分木の2つの子がブラウンツリーで、なおかつ左の子のサイズから右の子のサイズを引いたとき
0 もしくは 1 が得られるなら、その二分木はブラウンツリーです。
")
</listitem>

</itemizedlist>

自然数 n が与えられた時、サイズ n のブラウンツリーは唯一1つだけ存在します。
ブラウンツリーが平衡であることは自明でしょう。\

")
")

#langeng("
#para("\

A polymorphic datatype is declared as follows for representing binary trees:

#atscode("\
datatype tree (a:t@ype) =
  | tree_nil of ((*void*))
  | tree_cons of (a, tree(a)(*left*), tree(a)(*right*))
// end of [tree] // end of [datatype]
")

The following defined function #dyncode("brauntest0") tests whether a
given binary tree is a Braun tree:

#atscode("\
fun{
a:t@ype
} size (t: tree a): int = case+ t of
  | tree_nil () => 0
  | tree_cons (_, tl, tr) => 1 + size(tl) + size(tr)
// end of [size]

fun{
a:t@ype
} brauntest0
  (t: tree a): bool =
(
case+ t of
| tree_nil () => true
| tree_cons (_, tl, tr) => let
    val cond1 = brauntest0(tl) andalso brauntest0(tr)
  in
    if cond1 then let
      val df = size(tl) - size(tr) in (df = 0) orelse (df = 1)
    end else false
  end // end of [tree_cons]
) (* end of [brauntest0] *)
")

The implementation of #dyncode("brauntest0") follows the definition of
Braun trees closely. If applied to binary trees of size n, the
time-complexity of the function #dyncode("size") is O(n) and the
time-complexity of the function #dyncode("brauntest0") is O(n(log(n))).\

")#comment("para")
")#comment("langeng")
#langja("
#para("\

次のような二分木を表わす多相データ型を宣言します:

#atscode("\
datatype tree (a:t@ype) =
  | tree_nil of ((*void*))
  | tree_cons of (a, tree(a)(*left*), tree(a)(*right*))
// end of [tree] // end of [datatype]
")

次に宣言する関数 #dyncode("brauntest0") は、与えられた二分木がブラウンツリーかどうか判定します:

#atscode("\
fun{
a:t@ype
} size (t: tree a): int = case+ t of
  | tree_nil () => 0
  | tree_cons (_, tl, tr) => 1 + size(tl) + size(tr)
// end of [size]

fun{
a:t@ype
} brauntest0
  (t: tree a): bool =
(
case+ t of
| tree_nil () => true
| tree_cons (_, tl, tr) => let
    val cond1 = brauntest0(tl) andalso brauntest0(tr)
  in
    if cond1 then let
      val df = size(tl) - size(tr) in (df = 0) orelse (df = 1)
    end else false
  end // end of [tree_cons]
) (* end of [brauntest0] *)
")

#dyncode("brauntest0") の実装はブラウンツリーの定義に厳密に従っています。
サイズ n の二分木を判定すると、関数 #dyncode("size") の時間的計算量は O(n) であり、
関数 #dyncode("brauntest0") の時間的計算量は O(n(log(n))) です。\

")#comment("para")
")#comment("langja")

#langeng("
#para("\

In the following program, the defined function #dyncode("brauntest1") also
tests whether a given binary tree is a Braun tree:

#atscode("\
fun{
a:t@ype
} brauntest1
  (t: tree a): bool = let
  exception Negative of ()
  fun aux (t: tree a): int =
  (
    case+ t of
    | tree_nil () => 0
    | tree_cons (_, tl, tr) => let
        val szl = aux (tl) and szr = aux (tr)
        val df = szl - szr
      in
        if df = 0 orelse df = 1 then 1+szl+szr else $raise Negative()
      end // end of [tree_cons]
  ) (* end of [aux] *)
in
  try let
    val _ = aux (t)
  in
    true // [t] is a Braun tree
  end with
    ~Negative() => false // [t] is not a Braun tree
  // end of [try]
end // end of [brauntest1]
")

Clearly, a binary tree cannot be a Braun tree if one of its subtrees,
proper or improper, is not a Braun tree. The auxiliary function
#dyncode("aux") is defined to return the size of a binary tree if the tree
is a Braun tree or raise an exception otherwise. When the evaluation of the
try-expression in the body of #dyncode("brauntest1") starts, the call to
#dyncode("aux") on a binary tree t is first evaluated. If the evaluation of
this call returns, then t is a Braun tree and the boolean value
#dyncode("true") is returned as the value of the try-expression. Otherwise,
the exception #dyncode("Negative()") is raised and then caught, and the
boolean value #dyncode("false") is returned as the value of the
try-expression.  The time complexity of #dyncode("brauntest1") is the same
as that of #dyncode("aux"), which is O(n).\

")
")
#langja("
#para("\

次のプログラムで定義している #dyncode("brauntest1")
関数もまた与えられた二分木がブラウンツリーか判定しています:

#atscode("\
fun{
a:t@ype
} brauntest1
  (t: tree a): bool = let
  exception Negative of ()
  fun aux (t: tree a): int =
  (
    case+ t of
    | tree_nil () => 0
    | tree_cons (_, tl, tr) => let
        val szl = aux (tl) and szr = aux (tr)
        val df = szl - szr
      in
        if df = 0 orelse df = 1 then 1+szl+szr else $raise Negative()
      end // end of [tree_cons]
  ) (* end of [aux] *)
in
  try let
    val _ = aux (t)
  in
    true // [t] is a Braun tree
  end with
    ~Negative() => false // [t] is not a Braun tree
  // end of [try]
end // end of [brauntest1]
")

子ツリーの内1つでもブラウンツリーでなければ、その二分木はブラウンツリーでないことは明確です。
補助関数 #dyncode("aux") は、ツリーがブラウンツリーである場合には二分木のサイズを返し、そうでない場合には例外を発生させるために定義されています。
#dyncode("brauntest1") の中身にある try 式の評価が開始すると、まずはじめに二分木に対して #dyncode("aux") を呼び出します。
もしこの呼び出しの評価が返れば t はブラウンツリーであるので、try 式の値としてブール値
#dyncode("true") が返ります。
そうでなければ、#dyncode("Negative()") 例外が発生して捕捉され、try 式の値としてブール値
#dyncode("false") が返ります。
#dyncode("brauntest1") と #dyncode("aux") の時間的計算量はどちらも O(n) です。\

")
")

#langeng("
#para("\

The use of the exception mechanism in the implementation of
#dyncode("brauntest1") is a convincing one because the range between the
point where an exception is raised and the point where the raised exception
is captured can span many function calls. If this range is short (e.g.,
spanning only one function call) in a case, then the programmer should
probably investigate whether it is a sensible use of the exception
mechanism. For instance, the use of exception in the following example may
seem interesting but it actually leads to very inefficient code:


#atscode('\
fun{
a:t@ype
} list0_length
  (xs: list0 (a)): int =
  try 1 + list0_length (xs.tail) with ~ListSubscriptExn() => 0
// end of [list0_length]
')

Therefore, making use of exceptions in this style should be avoided.

")
")
#langja("
#para("\

#dyncode("brauntest1") の実装における例外機構の使い方は妥当なものです。
なぜなら例外が発生するポイントから例外が捕捉されるポイントまでの範囲に多くの関数呼び出しがあるからです。
もしこの範囲が短かい場合
(例えばたった1つの関数しか呼び出さないなど)、おそらくプログラマは例外機構を使うべきか吟味すべきでしょう。
例えば、次の例における例外の使い方は興味深いものですが、実際には役に立ちません：

#atscode('\

fun{
a:t@ype
} list0_length
  (xs: list0 (a)): int =
  try 1 + list0_length (xs.tail) with ~ListSubscriptExn() => 0
// end of [list0_length]

')

そのため、このような例外の使い方は避けるべきでしょう。

")
")

#langeng("
#para("\

Please find the entirety of the code in this section plus some additional
code for testing #mycodelink("CHAP_EFFECTFUL/brauntest.dats", "on-line").\

")
")
#langja("
#para("\

この章に出てくるコードの全体とテストのための追加コードは
#mycodelink("CHAP_EFFECTFUL/brauntest.dats", "オンライン")
から得られます。\

")
")

</sect1><!--id="example_testing_for_braun_trees"-->

<sect1
id="references">
#langeng("
#title("References")
")
#langja("
#title("参照")
")

#langeng("
#para("\

A reference is just a singleton array, that is, an array containing one
element.  Given a type T, a reference for storing a value of the type T is
given the type ref(T).  The following simple program makes use of all the
essential functionalities on references:

#atscode("\
val intr = ref<int> (0) // create a ref and init. it with 0
val () = !intr := !intr + 1 // increase the integer at [intr] by 1
")

The first line creates a reference for storing an integer and initializes
it with the value 0 and then names it #dyncode("intr"). Note that this
style of reference creation cannot be separated from its
initialization. The second line updates the reference #dyncode("intr") with
its current value plus 1. In general, given a reference r of type ref(T)
for some T, the expression !r means to fetch the value stored at r, which
is of the type T. However, !r can also be used as a left-value. For
instance, the assignment (!r := exp) means to evaluate exp into a value and
then store the value into r. Therefore, the value stored in
#dyncode("intr") is 1 after the second line in the above program is
evaluated.\

")#comment("para")
")
#langja("
#para("\

参照はたった1つの要素を持つ配列です。
ある型Tが与えられた時、型Tの値を保管する参照は型 ref(T) になります。
次のプログラムは参照の本質的な機能をすべて利用しています:

#atscode("\
val intr = ref<int> (0) // create a ref and init. it with 0
val () = !intr := !intr + 1 // increase the integer at [intr] by 1
")

最初の行では、1つの整数値を保存する参照を作成し、その参照を値0で初期化した後、
その参照に #dyncode("intr") という名前をつけています。
このスタイルでは、参照の生成と初期化を分離できないことに注意してください。
2番目の行では、現状の値に1を足した値で参照 #dyncode("intr") を更新しています。
一般に、型 T と r と名付けられた参照 ref(T) が与えられた時、
式 !r は r に保存されている型 T の値を取得する意味しています。
しかしながら !r は左辺値にも使うことができます。
例えば (!r := exp) という代入は exp を評価して値にしてから r に保存することを意味しています。
そのため、上記のプログラムの2行目を評価した後では、 #dyncode("intr") に保存されている値は 1 になります。\

")#comment("para")
")

#langeng("
#para("\

Various functions and function templates on references are declared in the
file #myatscodelink("prelude/SATS/reference.sats", "reference.sats"), which
is automatically loaded by <command>atsopt</command>. In particular, it is
also possible to read from and write to a reference by using the function
templates #dyncode("ref_get_elt") and #dyncode("ref_set_elt") of the following
interfaces, respectively:

#atscode("\
fun{a:t@ype} ref_get_elt (r: ref a): a // !r
fun{a:t@ype} ref_set_elt (r: ref a, x: a): void // !r := x
")

")#comment("para")
")
#langja("
#para("\

#myatscodelink("prelude/SATS/reference.sats", "reference.sats")
ファイルでは、参照にまつわる様々な関数と関数テンプレートが宣言されています。
このファイルは <command>atsopt</command> によって自動的に読み込まれます。
特に、次のインターフェイスの関数テンプレート #dyncode("ref_get_elt") と #dyncode("ref_set_elt") を使うことで、
参照の読み書きをすることもできます:

#atscode("\
fun{a:t@ype} ref_get_elt (r: ref a): a // !r
fun{a:t@ype} ref_set_elt (r: ref a, x: a): void // !r := x
")

")#comment("para")
")

#langeng("
#para("\

References are often misused in practice, especially, by beginners of
functional programming who had some previous exposure to imperative
programming languages such C and Java. Such programmers often think that
they can just \"translate\" their programs in C or Java into functional
programs. For example, the following defined function #dyncode("sumup") is
such an example, which sums up all the integers between 1 and a given
integer, inclusive:

#atscode("\
fun sumup
  (n: int): int = let
  val i = ref<int> (1)
  val res = ref<int> (0)
  fun loop (): void =
    if !i <= n then (!res := !res + !i; !i := !i + 1; loop ())
  // end of [loop]
in
  loop (); !res
end // end of [sumup]
")

This is a correct but poor implementation, and its style, though not the
worst of its kind, is deplorable. As references are allocated in heap,
reading from or writing to a reference can be much more time-consuming than
reading from or writing to a register. So, this implementation of
#dyncode("sumup") is unlikely to be time-efficient.  Every call to
#dyncode("sumup") creates two references in heap and leaves them there when
it returns, and the memory allocated for such references can only be
reclaimed through garbage collection (GC). So, this implementation of
#dyncode("sumup") is not memory-efficient.  More importantly, a program
making heavy use of references is often difficult to reason about.\

")#comment("para")
")#comment("langeng")
#langja("
#para("\

実際には参照は誤用されがちです。
とりわけC言語やJavaのような命令型プログラミング言語に成熟した関数型プログラミングの初心者に見られます。
そのようなプログラマはしばしばC言語やJavaで書かれたプログラムを、
関数型プログラムに単に \"翻訳\" しようと考えます。
次で定義している #dyncode("sumup") はそのような例です。
この関数1から与えられた整数までの整数値をすべて加算します:

#atscode("\
fun sumup
  (n: int): int = let
  val i = ref<int> (1)
  val res = ref<int> (0)
  fun loop ():<cloref1> void =
    if !i <= n then (!res := !res + !i; !i := !i + 1; loop ())
  // end of [loop]
in
  loop (); !res
end // end of [sumup]
")

このプログラムは正常ですが良い実装とスタイルではありません。
最悪とまでは言えませんが、ひどいものです。
参照はヒープに確保されるので、参照の読み書きはレジスタの読み書きよりもより多く時間を消費します。
そのため、この #dyncode("sumup") の実装は時間効率が悪いことになります。
#dyncode("sumup") が呼び出されるたびに、2つの参照がヒープに生成されて関数が返るまで放置されています。
参照のために割り当てられたメモリはガベージコレクション(GC)によってのみ回収されます。
つまり、この #dyncode("sumup") の実装は空間効率も悪いことにります。
もっと重要なことに、参照を多用するプログラムは論証することがしばしば困難です。\

")#comment("para")
")#comment("langja")

#langeng("
#para("\

I consider references a dangerous feature in functional
programming. If you want to run your program without GC, please do not
create references in the body of a function (besides many other
restrictions). If you find that you are in need of references to
\"translate\" imperative programs into functional ones, then it is most
likely that you are lost and you have not learned well to program in a
functional style yet.

")#comment("para")
")
#langja("
#para("\

関数型プログラミングにおける参照は危険な機能であると、私は考えています。
もしGCを使わないプログラムを実行したいのであれば、
関数の中で参照を生成してはいけません(その他にも多くの制約があります)。
もし手続型のプログラムを関数型のプログラムに \"翻訳\" する際に参照が必要になってしまったら、
多くの場合あなたは迷子になっており、関数型スタイルのプログラミングをまだよく学習していないことになります。

")#comment("para")
")

</sect1><!--id="references"-->

<sect1
id="example_counter_implementation">
#langeng("
#title("Example: A Counter Implementation")
")
#langja("
#title("例: カウンタの実装")
")

#langeng("
#para("\

Let us see as follows the implementation of a counter-like object in the
style of object-oriented programming (OOP).  The type #stacode("counter")
for counters is defined as follows:

#atscode("\
typedef
counter = '{
  get= () -<cloref1> int
, inc= () -<cloref1> void
, reset= () -<cloref1> void
} // end of [counter]
")

The three fields of #stacode("counter") are closure functions that
correspond to methods associated with an object: getting the count of the
counter, increasing the count of the counter by 1 and resetting the count
of the counter to 0. The following defined function #dyncode("newCounter")
is for creating a counter object (represented as a boxed record of closure
functions):

#atscode("\
fun newCounter
(
// argumentless
) : counter = let
  val count = ref<int> (0)
in '{
  get= lam () => !count
, inc= lam () => !count := !count + 1
, reset= lam () => !count := 0
} end // end of [newCounter]
")

The state of each created counter object is stored in a reference, which
can only be accessed by the three closure functions in the record that
represents the object. This is often referred to as state encapsulation
in OOP.\

")
")
#langja("
#para("\

次のようなオブジェクト指向プログラミング(OOP)スタイルのカウンタオブジェクトの実装を見てみましょう。
カウンタのために型 #stacode("counter") を次のように定義します:

#atscode("\
typedef
counter = '{
  get= () -<cloref1> int
, inc= () -<cloref1> void
, reset= () -<cloref1> void
} // end of [counter]
")

#stacode("counter") の3つのフィールドはクロージャ関数で、オブジェクトと関連したメソッドに対応しています。
すなわち、カウンタの数値の取得、カウンタの数値を1加算、カウンタの数値を0にリセットします。
次にカウンタオブジェクトを生成するために、関数 #dyncode("newCounter") を定義します。
このオブジェクトはクロージャ関数群を格納したボックス化レコードとして表わされます:

#atscode("\
fun newCounter
(
// argumentless
) : counter = let
  val count = ref<int> (0)
in '{
  get= lam () => !count
, inc= lam () => !count := !count + 1
, reset= lam () => !count := 0
} end // end of [newCounter]
")

それぞれ生成されたカウンタオブジェクトの状態は参照に保存されます。
その参照は対応するオブジェクトを表現するレコードの中の3つのクロージャ関数によってのみアクセスできます。
これはOOPにおけるカプセル化に対応しています。\

")
")

#langeng("
#para("\

I myself think that the above counter implementation is of rather
a poor style.  It is also possible to protect the integrity of a state by
simply making it abstract.  I will present elsewhere another counter
implementation based on a linear abstract type (that is, abstract viewtype
in ATS), where counters can be created and then safely freed.\

")
")
#langja("
#para("\

上記のカウンタ実装はどちらかというと良いスタイルではないと、私自身は考えています。
単純な抽象化することで状態の整合性を保護することも可能です。
これより後の章にて、線形抽象型(ATSでは抽象viewtypeと呼ばれます)を使った別のカウンタ実装を説明します。
この実装で生成されたカウンタは安全に解放されます。

")
")

</sect1><!--id="example_counter_implementation"-->

<!-- ****** ****** -->

<sect1
id="arrays">

#langeng("
#title("Arrays")
")
#langja("
#title("配列")
")

#langeng("
#para("\

I mentioned earlier that a reference is just an array of size 1.  I would
now like to state that an array of size n is just n references allocated
consecutively.  These references can also be called cells, and they are
numbered from 0 until n-1, inclusive.\

")
")
#langja("
#para("\

前の章で、参照はサイズが1の配列であると説明しました。
サイズnの配列とは連続して確保されたn個の参照であると言うこともできます。
これらの参照はセルとも呼ばれ、それらは 0 から n-1 までの番号が付けられています。\

")
")

#langeng("
#para("\

Given an array of size n, an integer is a valid index for this array if it
is a natural number strictly less than n. Otherwise, the integer is out of
the bounds of the array.  For an array named A, the expression A[i] means
to fetch the content of the cell in A that is numbered i if i is a valid
index for A. The expression A[i] can also be used as a left value. For
instance, the assignment (A[i] := exp) means to evaluate exp to a value and
then store the value into the cell in A that is numbered i if i is a valid
index.\

")
")
#langja("
#para("\

サイズnの配列が与えられた時、
nよりも小さい自然数であれば、その整数値はこの配列に対する有効なインデックスです。
そうでない場合、その整数値は配列の範囲の外を指すことになります。
Aという名前のついた配列について、iがAに対する有効なインデックスである場合、
A[i] 式はAのi番目のセルの中身を取り出します。
A[i] 式は左辺値として使うこともできます。
例えば (A[i] := exp) という代入は
exp を評価して値にした後、iが有効なインデックスであればその値をAのi番目のセルに書き込みます。\

")
")

#langeng("
#para("\

What happens if the index i in A[i] is invalid, that is, it is out of the
bounds of the array A?  In this case, A[i] is referred to as out-of-bounds
array subscription and evaluating A[i] leads to a raised exception where
the exception is #dyncode("ArraySubscriptExn()").  One simple and reliable
way to tell whether an integer is a valid index for a given array is to
compare it with the size of the array at run-time.  Given a type T, the
type #stacode("arrszref(T)") is for an array paired with its size in which
elements of the type T are stored. I will loosely refer to values of the
type #stacode("arrszref(T)") as arrays from now on.  In case there is a
clear need to avoid potential confusion, I may also refer to them as
array0-values.\

")
")
#langja("
#para("\

もしA[i]のインデックスiが有効でなかったら、つまり配列Aの範囲外であったら何が起きるのでしょうか？
この場合、A[i]は out-of-bounds array subscription と呼ばれ、
A[i]の評価は #dyncode("ArraySubscriptExn()") 例外を引き起こします。
与えられた配列に対して整数値が有効なインデックスであるかどうか判定する簡単で確実な方法の一つは、
実行時に配列 のサイズと比較することです。
型Tが与えられた時、型 #stacode("arrszref(T)") は配列と型Tの要素が収められているサイズのペアです。
これ以降、 #stacode("arrszref(T)") 型の値のことを漠然と配列を呼びます。
また、混乱する可能性を避けるために、array0値と呼ぶこともあります。\

")
")

#langeng("
#para("\

Various functions and function templates on array0-values are declared in
the file #myatscodelink("prelude/SATS/arrayref.sats", "arrayref.sats"),
which is automatically loaded by <command>atsopt</command>. For instance,
three function templates and one polymorphic function on arrays are
depicted by the following interfaces:

#atscode("\
fun{a:t@ype} // a template
arrszref_make_elt
  (asz: size_t, x: a): arrszref a // array creation

// a polymorphic function
fun arrszref_get_size
  {a:t@ype} (A: arrszref a): size_t // size of an array

fun{a:t@ype} // a template
arrszref_get_elt_at (A: arrszref a, i: size_t): a // A[i]

fun{a:t@ype} // a template
arrszref_set_elt_at (A: arrszref a, i: size_t, x: a): void // A[i] := x
")

As for programming with arrays that carry no size information,
it is a topic to be covered after dependent types are introduced.

")#comment("para")
")
#langja("
#para("\

array0値に関する様々な関数と関数テンプレートが
#myatscodelink("prelude/SATS/arrayref.sats", "arrayref.sats") ファイルで宣言されています。
このファイルは <command>atsopt</command> によって自動的に読み込まれます。
例えば、配列に関する3つの関数テンプレートと1つの多相関数が次のインターフェイスで表現されます:

#atscode("\
fun{a:t@ype} // a template
arrszref_make_elt
  (asz: size_t, x: a): arrszref a // array creation

// a polymorphic function
fun arrszref_get_size
  {a:t@ype} (A: arrszref a): size_t // size of an array

fun{a:t@ype} // a template
arrszref_get_elt_at (A: arrszref a, i: size_t): a // A[i]

fun{a:t@ype} // a template
arrszref_set_elt_at (A: arrszref a, i: size_t, x: a): void // A[i] := x
")

サイズ情報をともなわない配列を使ったプログラミングは、
依存型が導入された後に話題にすることにします。

")#comment("para")
")

#langeng("
#para("\

Like in C, there are many types of integer values in ATS. The type
#stacode("size_t") is essentially for unsigned long integers. The functions
for converting between the type #stacode("int") and the type
#stacode("size_t") are #dyncode("g0int2uint_int_size") and
#dyncode("g0uint2int_size_int").  Given a type T and two values
#dyncode("asz") and #dyncode("init") of the types #dyncode("size_t") and T,
respectively, #dyncode("arrszref_make_elt&lt;T&gt; (asz, init)") returns an
array of the type #stacode("arrszref(T)") such that the size of the array
is #dyncode("asz") and each cell in the array is initialized with the value
#dyncode("init"). Given an array A of the type #stacode("arrszref(T)") for
some T, #dyncode("arrszref_get_size(A)") returns the size of A, which is of
the type #stacode("size_t"). For convenience,
#dyncode("arrszref_get_size(A)") can be written as #dyncode("A.size").  As
for array access and update, the functions #dyncode("arrszref_get_elt_at")
and #dyncode("arrszref_set_elt_at") can be called. For convenience, the
bracket notation can be used to call these functions.  \

")
")
#langja("
#para("\

C言語と同じように、ATS言語には多くの整数型があります。
#stacode("size_t") 型は本質的に unsigned long の整数です。
#stacode("int") と #stacode("size_t") を相互に変換する関数は
#dyncode("g0int2uint_int_size") と #dyncode("g0uint2int_size_int") です。
型 T と型 #dyncode("size_t") と T の値としてそれぞれ #dyncode("asz") と #dyncode("init") が与えられたとき、
#dyncode("arrszref_make_elt&lt;T&gt; (asz, init)") は #stacode("arrszref(T)") 型の配列を返します。
この配列のサイズは #dyncode("asz") で、それぞれのセルは値 #dyncode("init") で初期化されます。
型Tと型 #stacode("arrszref(T)") の配列Aが与えられた時、
#dyncode("arrszref_get_size(A)") はAのサイズを型 #stacode("size_t") で返します。
利便性のために #dyncode("arrszref_get_size(A)") は #dyncode("A.size") と書くこともできます。
配列へのアクセスと更新のために、
関数 #dyncode("arrszref_get_elt_at") と #dyncode("arrszref_set_elt_at") を呼び出すことができます。
利便性のために、これらの関数を角括弧表記で呼び出すこともできます。\

")
")

#langeng("
#para("\

In the following program, the function template
#dyncode("insertion_sort") implements the standard insertion sort on
arrays:

#atscode("\
fun{
a:t@ype
} insertion_sort
(
  A: arrszref (a)
, cmp: (a, a) -> int
) : void = let
  val n = g0uint2int_size_int (A.size)
  fun ins (x: a, i: int):<cloref1> void =
    if i >= 0 then
    (
      if cmp (x, A[i]) < 0
        then (A[i+1] := A[i]; ins (x, i-1)) else A[i+1] := x
      // end of [if]
    ) else A[0] := x // end of [if]
  // end of [ins]
  fun loop (i: int):<cloref1> void =
    if i < n then (ins (A[i], i-1); loop (i+1)) else ()
  // end of [loop]
in
  loop (1)
end // end of [insertion_sort]
")

The comparison function #dyncode("cmp") should return 1, -1, and 0 if its
first argument is greater than, less than and equal to its second one,
respectively.

")#comment("para")
")
#langja("
#para("\

次のプログラムでは、
一般的な配列の挿入ソートを関数テンプレート #dyncode("insertion_sort") として実装しています:

#atscode("\
fun{
a:t@ype
} insertion_sort
(
  A: arrszref (a)
, cmp: (a, a) -> int
) : void = let
  val n = g0uint2int_size_int (A.size)
  fun ins (x: a, i: int):<cloref1> void =
    if i >= 0 then
    (
      if cmp (x, A[i]) < 0
        then (A[i+1] := A[i]; ins (x, i-1)) else A[i+1] := x
      // end of [if]
    ) else A[0] := x // end of [if]
  // end of [ins]
  fun loop (i: int):<cloref1> void =
    if i < n then (ins (A[i], i-1); loop (i+1)) else ()
  // end of [loop]
in
  loop (1)
end // end of [insertion_sort]
")

比較関数 #dyncode("cmp") は1、-1、0のいずれかを返します。
それぞれ1番目の引数が2番目の引数よりも大きいか、小さいか、等しいことを表わします。

")#comment("para")
")

#langeng("
#para("\

Note that the entire code in this section plus some additional code
for testing is available #mycodelink("CHAP_EFFECTFUL/insort.dats", "on-line").\

")
")
#langja("
#para("\

この章に出てくるコードの全体とテストのための追加コードは
#mycodelink("CHAP_EFFECTFUL/insort.dats", "オンライン")
から得られます。\

")
")

</sect1><!--id="arrays"-->

<!-- ****** ****** -->

<sect1
id="example_ordering_permutations">

#langeng("
#title("Example: Ordering Permutations")
")
#langja("
#title("例: 順序をつけた置換 (Ordering Permutations)")
")

#langeng("
#para("\
Given a natural number n, we want to print out all the permutations
consisting of integers ranging from 1 to n, inclusive. In addition, we
want to print them out according to the lexicographic ordering on integer
sequences. For instance, we want the following output to be generated when
n is 3:

#atscode("\
1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
")
")

<!--
#para("\
#atscode("\
1, 2, 3, 4
1, 2, 4, 3
1, 3, 2, 4
1, 3, 4, 2
1, 4, 2, 3
1, 4, 3, 2
2, 1, 3, 4
2, 1, 4, 3
2, 3, 1, 4
2, 3, 4, 1
2, 4, 1, 3
2, 4, 3, 1
3, 1, 2, 4
3, 1, 4, 2
3, 2, 1, 4
3, 2, 4, 1
3, 4, 1, 2
3, 4, 2, 1
4, 1, 2, 3
4, 1, 3, 2
4, 2, 1, 3
4, 2, 3, 1
4, 3, 1, 2
4, 3, 2, 1
")
")
-->
")
#langja("
#para("\
自然数nが与えられた時、1からnまでの整数からなる置換(permutation)をすべて印字することを考えます。
さらに、整数列を辞書順で印字したいとしましょう。
例えば、nが3の時次のような出力が得られることを期待しています：

#atscode("\
1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
")
")

<!--
#para("\
#atscode("\
1, 2, 3, 4
1, 2, 4, 3
1, 3, 2, 4
1, 3, 4, 2
1, 4, 2, 3
1, 4, 3, 2
2, 1, 3, 4
2, 1, 4, 3
2, 3, 1, 4
2, 3, 4, 1
2, 4, 1, 3
2, 4, 3, 1
3, 1, 2, 4
3, 1, 4, 2
3, 2, 1, 4
3, 2, 4, 1
3, 4, 1, 2
3, 4, 2, 1
4, 1, 2, 3
4, 1, 3, 2
4, 2, 1, 3
4, 2, 3, 1
4, 3, 1, 2
4, 3, 2, 1
")
")
-->
")

#langeng("
#para("\
Let us first define a function as follows for printing out an array
of integers:

#atscode('
fun print_intarray
  (A: arrszref (int)): void = let
  val asz = g0uint2int_size_int (A.size)
//
// The integers are to be separated by the string [sep]
//
  fun loop (i: int, sep: string): void =
    if i < asz then
      (if i > 0 then print sep; print A[i]; loop (i+1, sep))
    // end of [if]
in
  loop (0, ", ")
end // end of [print_intarray]
')
")#comment("para")
")
#langja("
#para("\
次のような整数の配列を印字する関数を定義しましょう:

#atscode('
fun print_intarray
  (A: arrszref (int)): void = let
  val asz = g0uint2int_size_int (A.size)
//
// The integers are to be separated by the string [sep]
//
  fun loop (i: int, sep: string):<cloref1> void =
    if i < asz then
      (if i > 0 then print sep; print A[i]; loop (i+1, sep))
    // end of [if]
in
  loop (0, ", ")
end // end of [print_intarray]
')
")#comment("para")
")

#langeng("
#para("\

We next implement two functions #dyncode("lrotate") and #dyncode("rrotate")
for rearranging the elements in a given integer array:

#atscode("\
fun lrotate (
  A: arrszref int, i: int, j: int
) : void = let
  fun lshift (
    A: arrszref int, i: int, j: int
  ) : void =
  if i < j then (A[i] := A[i+1]; lshift (A, i+1, j))
in
  if i < j then let
    val tmp = A[i] in lshift (A, i, j); A[j] := tmp
  end // end of [if]
end // end of [lrotate]

fun rrotate (
  A: arrszref int, i: int, j: int
) : void = let
  fun rshift (
    A: arrszref int, i: int, j: int
  ) : void =
  if i < j then (A[j] := A[j-1]; rshift (A, i, j-1))
in
  if i < j then let
    val tmp = A[j] in rshift (A, i, j); A[i] := tmp
  end // end of [if]
end // end of [rrotate]
")

When applied to an array and two valid indexes i and j for the array such
that i is less than or equal to j, #dyncode("lrotate") moves simultaneously
the content of cell i into cell j and the content of cell k to cell k-1 for
k ranging from i+1 to j, inclusive. The function #dyncode("rrotate") is
similar to #dyncode("lrotate") but shuffles elements in the opposite
direction.\

")#comment("para")
")
#langja("
#para("\

次に、与えられた配列の要素を再配置するために、
2つの関数 #dyncode("lrotate") と #dyncode("rrotate") を実装します:

#atscode("\
fun lrotate (
  A: arrszref int, i: int, j: int
) : void = let
  fun lshift (
    A: arrszref int, i: int, j: int
  ) : void =
  if i < j then (A[i] := A[i+1]; lshift (A, i+1, j))
in
  if i < j then let
    val tmp = A[i] in lshift (A, i, j); A[j] := tmp
  end // end of [if]
end // end of [lrotate]

fun rrotate (
  A: arrszref int, i: int, j: int
) : void = let
  fun rshift (
    A: arrszref int, i: int, j: int
  ) : void =
  if i < j then (A[j] := A[j-1]; rshift (A, i, j-1))
in
  if i < j then let
    val tmp = A[j] in rshift (A, i, j); A[i] := tmp
  end // end of [if]
end // end of [rrotate]
")

配列と2つの有効なインデックスiとjに適用され、iがj以下であるとき、
#dyncode("lrotate") はいっせいにセルiの中身をセルjへ移動し、セルkの中身をセルk-1へ移動します。
このときkはi+1からjの範囲の数値です。
#dyncode("rrotate") 関数は要素を反対方向に移すことを除いて、 #dyncode("lrotate") に似ています。\

")#comment("para")
")

#langeng("
#para("\
Given a natural number n, the following defined function
#dyncode("permute") prints out all the permutations consisting of integers
ranging from 1 to n, inclusive while arranging the output according to
the lexicographic ordering on integer sequences.

#atscode("\

fun permute
  (n: int): void = let
//
  \#define i2sz g0int2uint_int_size
//
// Creating array A of size n
//
  val A = arrszref_make_elt<int> (i2sz(n), 0)
//
// Initializing A with integers from 1 to n, inclusive
//
  val () = init(0) where
  {
    fun init (i: int): void =
      if i < n then (A[i] := i+1; init (i+1))
  } // end of [where] // end of [val]
//
  fun aux
    (i: int): void =
  (
    if i <= n
      then aux2 (i, i)
      else (
        print_intarray (A); print_newline ()
      ) (* end of [else] *)
  ) (* end of [aux] *)
//
  and aux2
    (i: int, j: int): void =
  (
    if j <= n then let
      val () = (
        rrotate (A, i-1, j-1); aux (i+1); lrotate (A, i-1, j-1)
      ) // end of [val]
    in
      aux2 (i, j+1)
    end // end of [if]
  ) (* end of [aux2] *)
//
in
  aux (1)
end // end of [permute]
")

Note that #dyncode("where") is a keyword, and the expression
(exp #dyncode("where") #dyncode("{") decseq #dyncode("}"))
for some expression exp and declaration sequence decseq is equivalent to
the let-expression of the form (#dyncode("let") decseq #dyncode("in") exp
#dyncode("end")). To understand the behavior of the function
#dyncode("aux"), let us evaluate #dyncode("aux(1)") while assuming that
#dyncode("n") is 4 and the 4 elements of the array #dyncode("A") are 1, 2,
3, and 4. It should be fairly straightforward to see that this evaluation
leads to the evaluation of #dyncode("aux(2)") for 4 times: the array
#dyncode("A") contains (1, 2, 3, 4) for the first time, and (2, 1, 3, 4)
for the second time, and (3, 1, 2, 4) for the third time, and (4, 1, 2, 3)
for the fourth time. With some inductive reasoning, it should not be
difficult to see that evaluating #dyncode("aux(1)") indeed leads to all the
permutations being output according to the lexicographic ordering on
integer sequences.\

")#comment("para")
")
#langja("
#para("\
自然数nが与えられたとき、
次に定義する関数 #dyncode("permute") は1からnまでの整数からなるすべての置換を印字します。
このとき出力は整数列の辞書順で並べられます。

#atscode("\

fun permute
  (n: int): void = let
//
  \#define i2sz g0int2uint_int_size
//
// Creating array A of size n
//
  val A = arrszref_make_elt<int> (i2sz(n), 0)
//
// Initializing A with integers from 1 to n, inclusive
//
  val () = init (0) where
  {
    fun init (i: int):<cloref1> void =
      if i < n then (A[i] := i+1; init (i+1))
  } // end of [where] // end of [val]
//
  fun aux
    (i: int):<cloref1> void =
  (
    if i <= n
      then aux2 (i, i) else (
      print_intarray (A); print_newline ()
    ) // end of [if]
  ) (* end of [aux] *)
//
  and aux2
    (
      i: int, j: int
    ) :<cloref1> void =
  (
    if j <= n then let
      val () = (
        rrotate (A, i-1, j-1); aux (i+1); lrotate (A, i-1, j-1)
      ) // end of [val]
    in
      aux2 (i, j+1)
    end // end of [if]
  ) (* end of [aux2] *)
//
in
  aux (1)
end // end of [permute]
")

#dyncode("where") はキーワードで、なんらかの式 exp と宣言の列 decseq があるとき
式 (exp #dyncode("where") #dyncode("{") decseq #dyncode("}"))
はlet式 (#dyncode("let") decseq #dyncode("in") exp #dyncode("end")) と等価であることに注意してください。
関数 #dyncode("aux") の挙動を理解するために、
#dyncode("n") が 4 で、配列 #dyncode("A") の4つの要素が 1, 2, 3, 4 であるとき、
#dyncode("aux(1)") を評価してみましょう。

この評価によって #dyncode("aux(2)") の評価が4回起きることは簡単に理解できるでしょう:
1度目では配列 #dyncode("A") は (1, 2, 3, 4) を含み、
2度目では (2, 1, 3, 4)、
3度目では (3, 1, 2, 4)、
4度目では (4, 1, 2, 3) を含みます。
再帰呼び出しによって、
#dyncode("aux(1)") の評価が、すべての置換を整数列の辞書順で印字するのを理解するのは難しくないでしょう。\

")#comment("para")
")

#langeng("
#para("\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_EFFECTFUL/permord.dats", "on-line").\

")
")
#langja("
#para("\

この章に出てくるコードの全体とテストのための追加コードは
#mycodelink("CHAP_EFFECTFUL/permord.dats", "オンライン")
から得られます。\

")
")

</sect1><!--id="example_ordering_permutations"-->

<!-- ****** ****** -->

<sect1
id="matrices">

#langeng("
#title("Matrices")
")
#langja("
#title("行列")
")

#langeng("
#para("\

A matrix in ATS is just a two-dimensional array but it is represented by a
one-dimensional array and the representation is of the row-major style (in
contrast to the column-major style).  Given a type T, the type
#stacode("mtrxszref(T)") is for a matrix combined with its number of rows
and number of columns such that each element stored in the matrix is of the
type T. I will loosely refer to values of the type #stacode("mtrxszref(T)")
as matrices from now on.  If there is a clear need to avoid potential
confusion, I may also refer to them as matrix0-values.\

")#comment("para")
")
#langja("
#para("\

ATSにおける行列とは単に2次元の配列です。
それは1次元の配列と列優先(row-major)スタイルで表現されます
(行優先(column-major)スタイルではありません)。
型Tが与えられたとき、型 #stacode("mtrxszref(T)") は、
固有の列と行の数によって構成された行列で、行列中の要素は型Tです。
これ以降、型 #stacode("mtrxszref(T)") の値をおおざっぱに行列を呼びます。
混乱する可能性を明示的に避ける必要がある場合には、matrix0値と呼ぶこともあります。\

")#comment("para")
")

#langeng("
#para("\

Given a matrix M of dimension m by n, the expression M[i,j] means to
fetch the content of the cell in M that is indexed by (i, j), where i and j
are natural numbers strictly less than m and n, respectively.  The
expression M[i,j] can also be used as a left value. For instance, the
assignment (M[i,j] := exp) means to evaluate exp to a value and then store
the value into the cell in M that is indexed by (i, j).\

")#comment("para")
")
#langja("
#para("\

次元m,nの行列Mが与えられたとき、
式 M[i,j] は (i, j) をインデックスとするMのセルの中身を取り出します。
このときiとjは自然数で、それぞれmとnよりも小さい値でなければなりません。
式 M[i,j] は左辺値としても使うことができます。
例えば (M[i,j] := exp) という代入は、式expを評価して値にした後、
その値をインデックス(i, j)で指し示したMのセルに書き込みます。\

")#comment("para")
")

#langeng("
#para("\

Various functions and function templates on matrix0-values are declared in
the file #myatscodelink("prelude/SATS/matrixref.sats", "matrixref.sats"),
which is automatically loaded by <command>atsopt</command>. For instance,
three function templates and two polymorphic functions on matrices are
depicted by the following interfaces:

#atscode("\
fun{a:t@ype}
mtrxszref_make_elt // template
  (row: size_t, col: size_t, x: a): mtrxszref (a)

fun mtrxszref_get_nrow{a:t@ype} (M: mtrxszref a): size_t // polyfun
fun mtrxszref_get_ncol{a:t@ype} (M: mtrxszref a): size_t // polyfun

fun{a:t@ype}
mtrxszref_get_elt_at // template
  (M: mtrxszref a, i: size_t, j: size_t): a // M[i,j]
fun{a:t@ype}
mtrxszref_set_elt_at // template
  (M: mtrxszref a, i: size_t, j: size_t, x: a): void // M[i,j] := x
")

")#comment("para")
")
#langja("
#para("\

matrix0値に関する様々な関数と関数テンプレートが
#myatscodelink("prelude/SATS/matrixref.sats", "matrixref.sats") ファイルで宣言されています。
このファイルは <command>atsopt</command> によて自動的に読み込まれます。
例えば、行列に関する3つの関数テンプレートと2つの多相関数が次のようなインターフェイスで表現されています:

#atscode("\
fun{a:t@ype}
mtrxszref_make_elt // template
  (row: size_t, col: size_t, x: a): mtrxszref (a)

fun mtrxszref_get_nrow{a:t@ype} (M: mtrxszref a): size_t // polyfun
fun mtrxszref_get_ncol{a:t@ype} (M: mtrxszref a): size_t // polyfun

fun{a:t@ype}
mtrxszref_get_elt_at // template
  (M: mtrxszref a, i: size_t, j: size_t): a // M[i,j]
fun{a:t@ype}
mtrxszref_set_elt_at // template
  (M: mtrxszref a, i: size_t, j: size_t, x: a): void // M[i,j] := x
")

")#comment("para")
")

#langeng("
#para("\

Given a type T and three values #dyncode("nrow"), #dyncode("ncol") and
#dyncode("init") of the types #stacode("size_t"), #stacode("size_t") and T,
respectively, #dyncode("mtrxszref_make_elt&lt;T&gt; (row, col, init)")
returns a matrix of the type #stacode("mtrxszref(T)") such that the
dimension of the matrix is #dyncode("nrow") by #dyncode("ncol") and each
cell in the matrix is initialized with the value #dyncode("init"). Given a
matrix M of the type #stacode("mtrxszref(T)") for some T,
#dyncode("mtrxszref_get_nrow(M)") and #dyncode("mtrxszref_get_ncol(M)")
return the number of rows and the number of columns of M, respectively,
which are both of the type #stacode("size_t"). For convenience,
#dyncode("mtrxszref_get_nrow(M)") and #dyncode("mtrxszref_get_ncol(M)") can
also be written as #dyncode("M.nrow") and #dyncode("M.ncol"), respectively.
As for matrix access and update, the function templates
#dyncode("mtrxszref_get_elt_at") and #dyncode("mtrxszref_set_elt_at") can
be called, respectively. For convenience, bracket notation can used for
these functions.\

")#comment("para")
")
#langja("
#para("\

型Tと3つの値 #dyncode("nrow"), #dyncode("ncol"), #dyncode("init") がそれぞれ
型 #stacode("size_t"), #stacode("size_t"), T で与えられた時、
#dyncode("mtrxszref_make_elt&lt;T&gt; (row, col, init)") は型 #stacode("mtrxszref(T)") の行列を返します。
この行列の次元は #dyncode("nrow") x #dyncode("ncol") で、それぞれのセルは値 #dyncode("init") で初期化されます。
型Tと型 #stacode("mtrxszref(T)") の行列Mが与えられたとき、
#dyncode("mtrxszref_get_nrow(M)") と #dyncode("mtrxszref_get_ncol(M)")
はMの列の数と行数を型 #stacode("size_t") でそれぞれ返します。
利便性のために #dyncode("mtrxszref_get_nrow(M)") と #dyncode("mtrxszref_get_ncol(M)")
はそれぞれ #dyncode("M.nrow") と #dyncode("M.ncol") と書くこともできます。
行列へのアクセスと更新のために、 #dyncode("mtrxszref_get_elt_at") と #dyncode("mtrxszref_set_elt_at") 
をそれぞれ呼び出すことができます。
利便性のために、これらの関数のかわりに角括弧表記を使うことができます。\

")#comment("para")
")

#langeng("
#para("\

Let us now take a look at an example. The following defined function
#dyncode("mtrxszref_transpose") turns a given matrix into its transpose:

#atscode("\
fun{a:t@ype}
mtrxszref_transpose
  (M: mtrxszref a): void = let
//
val nrow = mtrxszref_get_nrow (M)
//
fnx loop1
  (i: size_t): void =
  if i < nrow then loop2 (i, 0) else ()
//
and loop2
  (i: size_t, j: size_t): void =
  if j < i then let
    val tmp = M[i,j]
  in
    M[i,j] := M[j,i]; M[j,i] := tmp; loop2 (i, j+1)
  end else
    loop1 (i+1)
  // end of [if]
//
in
  loop1 (0)
end // end of [mtrxszref_transpose]
")

The matrix M is assumed to be a square, that is, its number of rows equals
its number of columns. Note that the two functions #dyncode("loop1") and
#dyncode("loop2") are defined mutually tail-recursively, and the keyword
#dyncode("fnx") indicates the need to combine the bodies of
#dyncode("loop1") and #dyncode("loop2") so that mutual recursive tail-calls
in these function bodies can be compiled into direct local jumps.\

")#comment("para")
")
#langja("
#para("\

例を見てみましょう。
次に定義する関数 #dyncode("mtrxszref_transpose") は与えられた行列を転置行列にします:

#atscode("\
fun{a:t@ype}
mtrxszref_transpose
  (M: mtrxszref a): void = let
//
val nrow = mtrxszref_get_nrow (M)
//
fnx loop1
  (i: size_t):<cloref1> void =
  if i < nrow then loop2 (i, 0) else ()
//
and loop2
  (i: size_t, j: size_t):<cloref1> void =
  if j < i then let
    val tmp = M[i,j]
  in
    M[i,j] := M[j,i]; M[j,i] := tmp; loop2 (i, j+1)
  end else
    loop1 (i+1)
  // end of [if]
//
in
  loop1 (0)
end // end of [mtrxszref_transpose]
")

行列Mは正方形、つまり列と行の数が等しいことを仮定しています。
2つの関数 #dyncode("loop1") と #dyncode("loop2") は相互末尾再帰で定義されていて、
キーワード #dyncode("fnx") は
#dyncode("loop1") と #dyncode("loop2") の中身を連結する必要があることを示していることに注意してください。
これらの関数の中にある相互末尾再帰呼び出しを、ローカルへの直接ジャンプへコンパイルすることができます。\

")#comment("para")
")

</sect1><!--id="matrices"-->

<!-- ****** ****** -->

<sect1
id="example_estimating_the_constant_pi">

#langeng("
#title("Example: Estimating the Constant Pi")
")
#langja("
#title("例: 定数Piの推量")
")

#langeng("
#para("\

I present as follows a Monte Carlo approach to estimating the constant Pi,
the ratio of the circumference of a circle over its diameter.\

")#comment("para")
")
#langja("
#para("\

モンテカルロ法を使って、円周の直径に対する比率である定数Piを推量します。\

")#comment("para")
")

#langeng("
#para("\

Assume that we have a square of the dimension N by N, where N is a
relatively large natural number (e.g., 1000), and a disk of radius 1 that
is contained in the square. Let N2 stand for N*N, that is, the square of N.
If we randomly choose a point inside the square, then the probability for
the point to hit the disk is Pi/N2.\

")#comment("para")
")
#langja("
#para("\

次元 N x N の正方形があるとしましょう。
このNは比較的大きな自然数(例えば1000)で、半径1の円盤がこの正方形に入っているとします。
N*N、つまりNの平方にN2という名前をつけます。
この正方形の内側の点をランダムに選択すると、
その点が円盤に当たる確率は Pi/N2 です。\

")#comment("para")
")

#langeng("
#para("\

The experiment we use to estimate the constant Pi can be described as
follows.  Given a natural number K, let us randomly choose K points inside
the square in K rounds. In each round, we choose exactly one point. If the
point chosen in round k hits on the disk centered at a previously chosen
point, then we record one hit. Clearly, the expected number of hits
recorded in round k is (k-1)*Pi/N2 as k-1 points have already being chosen
in the previous rounds. Therefore, in K rounds, the expected total number
of hits is (K*(K-1)/2)*Pi/N2. If K is fixed to be N2, then the expected
total number of hits is (N2-1)*Pi/2. It can be proven that the total number
of hits divided by N2 converges to Pi/2 (with probability 1) as N
approaches infinity.\

")#comment("para")
")
#langja("
#para("\

定数Piを推量する方法は次のようなものです。
自然数Kが与えられたとき、その正方形の内側にあるK個の点をランダムに、K回選択します。
それぞれの回において、きっちり1度だけ点を選びます。
前回選んだ点を中心とする円盤にk回目に選択した点が当っていたら、1度当ったことを記録します。
k回目における記録された当った回数は、直前の回までにk-1点選んだとき、 (k-1)*Pi/N2 であることが期待できます。
そのため、K回試行して当った合計回数は、理想的には (K*(K-1)/2)*Pi/N2 であることになります。
もしKがN2に到達すれば、期待される当った合計回数は (N2-1)*Pi/2 になります。
Nが無限大に近付くと、当った合計回数をN2で割った数が Pi/2 に収束することが証明できます。\

")#comment("para")
")

#langeng("
#para("\

If we implement the above experiment directly based on the given
description, the time-complexity of the implementation is evidently
proportional to N2*N2 as the time spent in round k is proportional to k,
where k ranges from 1 to N2. An implementation as such is simply
impractical for handling N around the order 1000 (and thus N2 around the
order of 1,000,000). To address the issue, we can impose a grid on the
square, dividing it into N2 unit squares (of the dimension 1 by 1).  We
then associate with each unit square a list of chosen points that are
inside it. In each round, we first choose a point randomly inside the
original square; we next locate the unit square that contains this point;
we then only search the lists associated with the unit square or any of its
neighbors to count the number of hits generated by the point chosen in this
round as this point cannot hit any disks centered at points that are not on
these lists.  As each unit square can have at most 8 neighbors and the
average length of the list associated with each square is less than 1
during the experiment, the time spent during each round is O(1), that is,
bounded by a constant. Hence, the time taken by the entire experiment is
O(N2).\

")#comment("para")
")
#langja("
#para("\

もし上記の試行を与えられた説明の通りに実装してしまうと、
その実装の時間効率は、kが1からN2までの範囲を取るときk回目にかかる時間がkに比例するので、
明らかに N2*N2 に比例してしまいます。
1000のオーダーのNを取り扱うことを考えると(つまりN2は1,000,000のオーダーになります)、
そのような実装は実用的ではありません。
この問題に対処するために、この正方形にN2ユニットの正方形に分割するグリッド(次元は 1 x 1 です)を導入します。
それからそれぞれのユニット正方形とその内側にある選んだ点のリストを関連させます。
それぞれの回において、まず元の正方形の内側からランダムに点を選択します;
次にこの点を含むユニット正方形を見つけます;
その後、当該ユニット正方形もしくは隣接するユニット正方形に関連するリストを探索して、
この回で選択した点によって生成された当った回数を数えます。
これらのリスト中に存在しない点を中心とする円盤をこの点が当たることはありません。
それぞれのユニット正方形は最大8つの隣接するユニット正方形を取ることができ、
試行最中におけるそれぞれの正方形に関連するリストの平均の長さは1未満なので、
それぞれの回にかかる時間は O(1) つまり定数に抑えられます。
それゆえ全体の試行にかかる時間は O(N2) になります。\

")#comment("para")
")

#langeng("
#para("\

An implementation that precisely matches the above description plus some
testing code is available #mycodelink("CHAP_EFFECTFUL/montecarlo.dats", "on-line").\

")
")
#langja("
#para("\

上記に示した実装とテストのための追加コードは
#mycodelink("CHAP_EFFECTFUL/montecarlo.dats", "オンライン")
から得られます。\

")
")

</sect1><!--id="example_estimating_the_constant_pi"-->

<!-- ****** ****** -->

<sect1
id="basic_input_and_output">
#langeng("
#title("Simple Input and Output")
")
#langja("
#title("単純な入力と出力")
")

#langeng("
#para("\

Handling I/O in ATS properly requires the availability of both dependent
types and linear types, which I will cover elsewhere. In this section, I
only present a means for allowing the programmer to access certain very
basic I/O functionalities.\

")#comment("para")
")
#langja("
#para("\

ATS言語でI/Oを扱うには依存型と線形型を使う必要があり、これは別の章で解説します。
この章では、プログラマが使うことのできる基本的なI/Oへのアクセス手段を解説します。\

")#comment("para")
")

#langeng("
#para("\

A file handle essentially associates a stream (of bytes) with a file
identifier (represented as an integer).  In ATS, the type for file handles
is #stacode("FILEref"). There are three standard file handles, which are
listed as follows:

")
")
#langja("
#para("\

ファイルハンドルは本質的には(バイト列としての)ストリームと(整数値として表現される)ファイル識別子を結び付けます。
ATSでは、ファイルハンドルの型は #stacode("FILEref") です。
次に挙げるような3つの標準ファイルハンドルがあります:

")
")

<itemizedlist>

<listitem>
#langeng("
#para("\
#dyncode("stdin_ref"): standard input
")
")
#langja("
#para("\
#dyncode("stdin_ref"): 標準入力
")
")
</listitem>

<listitem>
#langeng("
#para("\
#dyncode("stdout_ref"): standard output
")
")
#langja("
#para("\
#dyncode("stdout_ref"): 標準出力
")
")
</listitem>

<listitem>
#langeng("
#para("\
#dyncode("stderr_ref"): standard error output
")
")
#langja("
#para("\
#dyncode("stderr_ref"): 標準エラー出力
")
")
</listitem>

</itemizedlist>

#langeng("
#para("\

Various functions on file handles are declared in the file
#myatscodelink("prelude/SATS/filebas.sats", "filebas.sats"), which is
automatically loaded by <command>atsopt</command>. For instance, the
functions for opening and closing file handles have the following
interfaces:\

#atscode("\
fun fileref_open_exn
(
  path: string, fm: file_mode
) : FILEref // endfun

fun fileref_close (fil: FILEref): void
")

Note that these two functions abort immediately whenever an error occurs.
The following function is an optional version of
#dyncode("fileref_open_exn"), and the caller needs to inspect the value
returned by a call to #dyncode("fileref_open_opt") to see if a file handle
is actually obtained.\

#atscode("\
fun fileref_open_opt
  (path: string, fm: file_mode) : Option_vt (FILEref)
")

")
")
#langja("
#para("\

ファイルハンドルに関連する様々な関数が #myatscodelink("prelude/SATS/filebas.sats", "filebas.sats")
ファイルで宣言されています。
このファイルは <command>atsopt</command> で自動的に読み込まれます。
例えば、
ファイルハンドルのオープンとクローズを行なう関数は次のようなインターフェイスを持っています:\

#atscode("\
fun fileref_open_exn
(
  path: string, fm: file_mode
) : FILEref // endfun

fun fileref_close (fil: FILEref): void
")

これらの2つの関数はエラーが発生した時点で即座に中断することに注意してください。
次の関数は #dyncode("fileref_open_exn") の別バージョンで、
ファイルハンドルが実際に得られたかどうか、
#dyncode("fileref_open_opt") の呼び出し元が返値を検査する必要があります。\

#atscode("\
fun fileref_open_opt
  (path: string, fm: file_mode) : Option_vt (FILEref)
")

")
")

#langeng("
#para("\
The type #stacode("file_mode") is for values representing file modes,
which are listed as follows:
")
")
#langja("
#para("\
型 #stacode("file_mode") は次に挙げるようなファイルモードを表わす値です:
")
")

<itemizedlist>

<listitem>

#langeng("
#para("\
#dyncode("file_mode_r"): opening a file for reading and
positioning the associated stream at the beginning of the file.
")
")
#langja("
#para("\
#dyncode("file_mode_r"): ファイルを読み出しモードで開き、ファイル先頭にストリームを配置します。
")
")

</listitem>

<listitem>

#langeng("
#para("\
#dyncode("file_mode_rr"): opening a file for both reading and and
writing and positioning the associated stream at the beginning of the file.
")
")
#langja("
#para("\
#dyncode("file_mode_rr"): ファイルを読み書きモードで開き、ファイル先頭にストリームを配置します。
")
")

</listitem>

<listitem>

#langeng("
#para("\

#dyncode("file_mode_w"): truncating a given file to zero length or creating
a new one for writing and positioning the associated stream at the
beginning of the file.\

")
")
#langja("
#para("\

#dyncode("file_mode_w"): 与えられたファイルを長さゼロに切り詰めるか、書き込みのために新しいファイルを生成し、
ファイル先頭にストリームを配置します。\

")
")

</listitem>

<listitem>

#langeng("
#para("\

#dyncode("file_mode_ww"): truncating a given file to zero length or
creating a new one for both reading and writing and positioning the
associated stream at the beginning of the file.\

")
")
#langja("
#para("\

#dyncode("file_mode_ww"): 与えられたファイルを長さゼロに切り詰めるか、読み書きのために新しいファイルを生成し、
ファイル先頭にストリームを配置します。\

")
")

</listitem>

<listitem>

#langeng("
#para("\

#dyncode("file_mode_a"): opening a file for writing and positioning the
associated stream at the end of the file.\

")
")
#langja("
#para("\

#dyncode("file_mode_a"): ファイルを書き込みモードで開き、ファイル末尾にストリームを配置します。\

")
")

</listitem>

<listitem>

#langeng("
#para("\

#dyncode("file_mode_aa"): opening a file for both reading and writing and
positioning the associated stream at the beginning of the file for reading
and at the end for writing.\

")
")
#langja("
#para("\

#dyncode("file_mode_aa"): ファイルを読み書きモードで開き、読み出しストリームをファイル先頭に、
書き込みストリームをファイル末尾に配置します。\

")
")

</listitem>

</itemizedlist>

#langeng("
#para("\

As an example, the following short program opens a file handle, outputs the
string \"Hello, world!\" plus a newline into the stream associated with the
file handle and then closes the file handle:

#atscode('\
implement
main0 () =
{
val out =
  fileref_open_exn ("hello.txt", file_mode_w)
val () = fprint_string (out, "Hello, world!\\\n")
val () = fileref_close (out)
//
} (* end of [main0] *)
')

After executing the program, we obtain a file of the name \"hello.txt\" in
the current working directory containing the expected content. There are
various fprint-functions in ATS for printing out data into the stream
associated with a given file handle. Often the programmer can simply use
the name #dyncode("fprint") to refer to these functions due to the support
for overloading in ATS.\

")
")
#langja("
#para("\

例として、次の短かいプログラムはファイルハンドルを開き、
文字列 \"Hello, world!\" と改行をファイルハンドルに関連するストリームに出力し、
最後にファイルハンドルを閉じます:

#atscode('\
implement
main0 () =
{
val out =
  fileref_open_exn ("hello.txt", file_mode_w)
val () = fprint_string (out, "Hello, world!\\\n")
val () = fileref_close (out)
//
} (* end of [main0] *)
')

このプログラムを実行した後、
現在のワーキングディレクトリに期待される内容を含む \"hello.txt\" と名前のついたファイルが得られます。
与えられたファイルハンドル関連するストリームへデータを印字するような、様々なfprint関数がATSにはあります。
ATSではオーバーロードがサポートされているため、
しばしばプログラマはこれらの関数を参照するために単純に #dyncode("fprint") という名前を使うことができます。\

")
")

#langeng("
#para("\

Another common I/O function is given the following interface:

#atscode("\
fun fileref_get_line_string (fil: FILEref): Strptr1
")

The function #dyncode("fileref_get_line_string") reads a line from the
stream associated with a given file handle, and it returns a value of the
type #stacode("Strptr1"). For the moment, I will simply say that such a
value is just like a string except that it needs to be freed explicitly. As
an example, the following short program echos onto the standard output each
line read from the standard input:


#atscode('\
implement
main0 (
// argumentless
) = loop () where
{
//
fun loop (): void = let
  val isnot = fileref_isnot_eof (stdin_ref)
in
//
if isnot then let
  val line =
    fileref_get_line_string (stdin_ref)
  val ((*void*)) = fprintln! (stdout_ref, line)
  val ((*void*)) = strptr_free (line)
in
  loop ()
end else ((*loop exits as the end-of-file is reached*))
//
end (* end of [loop] *)
//
} (* end of [main0] *)
')

Note that the function #dyncode("strptr_free") is called to free a linear
string (of the type #stacode("Strptr1")). Often, typing the CTRL-D
character can terminate the above program for echoing each line of input.\

")#comment("para")
")
#langja("
#para("\

別の一般的なI/O関数として次のようなインターフェイスがあります:

#atscode("\
fun fileref_get_line_string (fil: FILEref): Strptr1
")

関数 #dyncode("fileref_get_line_string") は与えられたファイルハンドルに対応するストリームから1行読み込みます。
そしてその返値は #stacode("Strptr1") 型になります。
さしあたり、このような値は明示的に解放しなければならない文字列のようなものであると、
単純に説明することにとどめます。
例として、次の短かいプログラムは、標準入力から一行読み込み標準出力にエコー書き出します:

#atscode('\
implement
main0 (
// argumentless
) = loop () where
{
//
fun loop (): void = let
  val isnot = fileref_isnot_eof (stdin_ref)
in
//
if isnot then let
  val line =
    fileref_get_line_string (stdin_ref)
  val ((*void*)) = fprintln! (stdout_ref, line)
  val ((*void*)) = strptr_free (line)
in
  loop ()
end else ((*loop exits as the end-of-file is reached*))
//
end (* end of [loop] *)
//
} (* end of [main0] *)
')

(#stacode("Strptr1") 型の)線形文字列を解放するために、
関数 #dyncode("strptr_free") が呼び出されていることに注意してください。
CTRL-Dを入力することで入力の行をエコーしている上記のプログラムを終了することができます。\

")#comment("para")
")

</sect1><!--id="basic_input_and_output"-->

<!-- ****** ****** -->

</chapter><!--id="effectful_programming_features"-->

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
