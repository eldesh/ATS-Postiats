%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="abstract_views_viewtypes">
#langeng("
#title("Abstract Views and Viewtypes")
")
#langja("
#title("抽象 view と viewtype")
")

#langeng("
#para('\

I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view-changes). Often what the programmer really needs is to
figure out #emphasis("conceptually") whether abstractly defined views and
proof functions for manipulating them actually make sense. This is a bit
like arguing whether a function is computable: There is rarely a need, if
at all, to actually encode the function as a Turing-machine to prove its
being computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

')
")
#langja("
#para('\

今までは、at-view と at-view の上に構築された view にもっぱら注目した view の表現を見てきました。
at-view が実際にもっとも広く使われる view の形であり、また ATS がサポートした view
の最初の形であることが、その大きな理由です。
けれども、抽象的な view の他の形を ATS に導入することができます。
view を at-view (もしくは view の他の形) を元にして定義できる場合においてさえ、(view
変更する証明関数をともなう) 抽象 view として導入したいと思うかもしれません。
しばしばプログラマが本当に必要とすることは、抽象的に定義された view
とそれらを操作する証明関数が実際に意味をなすかどうか、#emphasis("概念的に") 理解することです。
これは関数が計算可能かどうか根拠を示すことに少し似ています:
例え、計算可能であることを立証するためにチューリングマシンに関数を実際にエンコードするとしても、まれにその必要があります。
私見ですが、抽象 view と抽象 viewtype の適切な使い方を学ぶことは、実際にリソースに関連するプログラミングの問題に取り組むために、効果的に線形型を使うのに必要なステップです。

')
")

<!-- ****** ****** -->

<sect1
id="simple-linear-objects">
#langeng("
#title("Simple Linear Objects")
")
#langja("
#title("単純な線形オブジェクト")
")

#langeng("
#para("\

Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name #emphasis("simple linear object") here to refer
to a linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.\

")
")
#langja("
#para("\

物理世界のオブジェクトが線形であることははっきりしています:
それらは無から生成することはできませんし、単に消し去って無へと帰すこともできません。
従って、物理オブジェクトを表現する値に線形型を割り当てることは極めて自然です。
継承をサポートするビルトインの仕組みを含まないようなある種のオブジェクトを表わす線形値を参照するのに、ここでは
#emphasis("単純な線形オブジェクト") という名前を使います。\

")
")

#langeng("
#para('\

Let us now take a look at a concrete example of simple linear object.
The following code presents an interface for a timer (that is, stopwatch):

#atscode('\
absvtype timer_vtype
vtypedef timer = timer_vtype

fun timer_new (): timer
fun timer_free (x: timer): void
fun timer_start (x: !timer): void
fun timer_finish (x: !timer): void
fun timer_pause (x: !timer): void
fun timer_resume (x: !timer): void
fun timer_get_ntick (x: !timer): uint
fun timer_reset (x: !timer): void
')

The state of a timer is given the
record type #stacode("timer_struct") defined as follows:

#atscode('\
typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded when the timer
, ntick_beg= uint // was turned on last time
, ntick_acc= uint // the number of accumulated ticks
} (* end of [timer_struct] *)
')

The following linear datatype #stacode("timer")
is declared for timers, and the abstract type #stacode("timer_vtype")
is assumed to equal #stacode("timer"):

#atscode('\
//
datavtype timer =
  TIMER of (timer_struct)
//
assume timer_vtype = timer
//
')

')
")
#langja("
#para('\

単純な線形オブジェクトの具体的な例を見てみましょう。
次のコードは、タイマー (つまりストップウォッチです) のインターフェイスを表わしています:

#atscode('\
absvtype timer_vtype
vtypedef timer = timer_vtype

fun timer_new (): timer
fun timer_free (x: timer): void
fun timer_start (x: !timer): void
fun timer_finish (x: !timer): void
fun timer_pause (x: !timer): void
fun timer_resume (x: !timer): void
fun timer_get_ntick (x: !timer): uint
fun timer_reset (x: !timer): void
')

次に定義されるレコード型 #stacode("timer_struct") によってタイマーの状態が与えられます:

#atscode('\
typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded when the timer
, ntick_beg= uint // was turned on last time
, ntick_acc= uint // the number of accumulated ticks
} (* end of [timer_struct] *)
')

次の線形 datatype #stacode("timer") はタイマーのために宣言され、また抽象型 #stacode("timer_vtype") は
#stacode("timer") に等しいと見なされています:

#atscode('\
//
datavtype timer =
  TIMER of (timer_struct)
//
assume timer_vtype = timer
//
')

')
")

#langeng("
#para('\

Various functions on timers can now be readily implemented.
Let us first see the code for creating and freeing timers:

#atscode('\

implement
timer_new () = let
//
val timer = TIMER (_)
val TIMER (x) = timer
//
val () = x.started := false
val () = x.running := false
val () = x.ntick_beg := 0u
val () = x.ntick_acc := 0u
//
prval () = fold@ (timer)
//
in
  timer
end // end of [timer_new]

implement
timer_free (timer) =
  let val ~TIMER _ = timer in (*nothing*) end
// end of [timer_free]
')

')
")
#langja("
#para('\

タイマーに関する各種の関数をこれですぐに実装できます。
はじめにタイマーの生成と解放をするコードを見てみましょう:

#atscode('\

implement
timer_new () = let
//
val timer = TIMER (_)
val TIMER (x) = timer
//
val () = x.started := false
val () = x.running := false
val () = x.ntick_beg := 0u
val () = x.ntick_acc := 0u
//
prval () = fold@ (timer)
//
in
  timer
end // end of [timer_new]

implement
timer_free (timer) =
  let val ~TIMER _ = timer in (*nothing*) end
// end of [timer_free]

')

')
")

#langeng("
#para('\

The function for starting a timer can be implemented as follows:

#atscode('\
implement
timer_start
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := true
  val () = x.running := true
  val () = x.ntick_beg := the_current_tick_get ()
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_start]
')

where #dyncode("the_current_tick_get") is a function for
reading the current time (represented as a number of ticks):

#atscode('\
extern fun the_current_tick_get (): uint
')

')
")
#langja("
#para('\

タイマーを開始する関数は次のように実装できます:

#atscode('\
implement
timer_start
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := true
  val () = x.running := true
  val () = x.ntick_beg := the_current_tick_get ()
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_start]
')

このとき #dyncode("the_current_tick_get") は (ティックの数として表現される) 現在時間を読む関数です:

#atscode('\
extern fun the_current_tick_get (): uint
')

')
")

#langeng("
#para('\

A timer can be stopped or paused. The function for stopping a timer can be
implemented as follows:

#atscode('\
implement
timer_finish
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_finish]
')

')
")
#langja("
#para('\

タイマーは停止したり休止したりすることができます。
タイマーを停止させる関数は次のように実装できます:

#atscode('\
implement
timer_finish
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_finish]
')

')
")

#langeng("
#para('\
A timer can be paused and then resumed.
The following code implements the functions for pausing and resuming a
timer:

#atscode('\
implement
timer_pause
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_pause]

implement
timer_resume
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.started && ~(x.running) then
  {
    val () = x.running := true
    val () = x.ntick_beg := the_current_tick_get ()
  } (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_resume]
')

As can be expected, the amount of time between the point
where a timer is paused and the point where the timer is resumed
is not counted.

')
")
#langja("
#para('\
タイマーは休止した後に再開することができます。
次のコードはタイマーの休止と再開の関数を実装しています:

#atscode('\

implement
timer_pause
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_pause]

implement
timer_resume
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.started && ~(x.running) then
  {
    val () = x.running := true
    val () = x.ntick_beg := the_current_tick_get ()
  } (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_resume]
')

予想できることですが、タイマーが休止してから再開するまでの時間の総計はカウントされません。

')
")

#langeng("
#para('\

It is also possible to reset a timer by calling the function
#dyncode("timer_reset"):

#atscode('\
implement
timer_reset
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () = x.running := false
  val () = x.ntick_beg := 0u
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_reset]
')

')
")
#langja("
#para('\

関数 #dyncode("timer_reset") を呼び出すことでタイマーをリセットすることもまた可能です:

#atscode('\
implement
timer_reset
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () = x.running := false
  val () = x.ntick_beg := 0u
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_reset]
')

')
")

#langeng("
#para('\

In order to read the time accumulated by a timer,
the function #dyncode("timer_get_ntick") can be called:

#atscode('\
implement
timer_get_ntick
  (timer) = let
  val+@TIMER(x) = timer
  var ntick: uint = x.ntick_acc
  val () =
  if x.running then (
    ntick := ntick + the_current_tick_get () - x.ntick_beg
  ) (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  ntick
end // end of [timer_get_ntick]
')

')
")
#langja("
#para('\

関数 #dyncode("timer_get_ntick") を呼び出すことで、
タイマーにたまった時間を読み出すことができます:

#atscode('\
implement
timer_get_ntick
  (timer) = let
  val+@TIMER(x) = timer
  var ntick: uint = x.ntick_acc
  val () =
  if x.running then (
    ntick := ntick + the_current_tick_get () - x.ntick_beg
  ) (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  ntick
end // end of [timer_get_ntick]
')

')
")

#langeng("
#para('\

A straightforward approach to
implementing #dyncode("the_current_tick_get")
can be based directly on the function #dyncode("clock_gettime"):

#atscode('\
local

staload "libc/SATS/time.sats"

in (* in-of-local *)

implement
the_current_tick_get () = let
  var tv: timespec // uninitialized
  val err = clock_gettime (CLOCK_REALTIME, tv)
  val ((*void*)) = assertloc (err >= 0)
  prval ((*void*)) = opt_unsome{timespec}(tv)
in
  $UNSAFE.cast2uint(tv.tv_sec)
end // end of [the_current_tick_get]

end // end of [local]
')

Note that the library flag #dyncode("-lrt") may be needed in order to
have link-time access to #dyncode("clock_gettime") as the function is in
#dyncode("librt").

')
")
#langja("
#para('\

#dyncode("the_current_tick_get") を実装するわかりやすいアプローチは、関数
#dyncode("clock_gettime") を直接用いることでしょう:

#atscode('\
local

staload "libc/SATS/time.sats"

in (* in-of-local *)

implement
the_current_tick_get () = let
  var tv: timespec // uninitialized
  val err = clock_gettime (CLOCK_REALTIME, tv)
  val ((*void*)) = assertloc (err >= 0)
  prval ((*void*)) = opt_unsome{timespec}(tv)
in
  $UNSAFE.cast2uint(tv.tv_sec)
end // end of [the_current_tick_get]

end // end of [local]
')

リンク時に #dyncode("librt") に含まれる関数 #dyncode("clock_gettime") にアクセスするために、ライブラリフラグ
#dyncode("-lrt") が必要になることに注意してください。

')
")

#langeng("
#para('\

Please find #mycodelink("CHAP_ABSVTYPE/timer.dats", "on-line") the
entirety of the code presented in this section plus some testing code.

')
")
#langja("
#para('\

この章で紹介したコード全体とテストコードは
#mycodelink("CHAP_ABSVTYPE/timer.dats", "オンライン")
から入手できます。

')
")

</sect1><!--id="simple-linear-objects"-->

<!-- ****** ****** -->

<sect1 id="array-based-circular-buffer">
#langeng("
#title("\
Example: An Array-Based Circular Buffer\
")
")
#langja("
#title("\
例: 配列を用いたリングバッファ\
")
")

#langeng("
#para("\

Array-based circular buffers are of common use in practice. For instance,
in a typical client/server model, a circular buffer can be employed to hold
requests issued by multiple clients that are then processed by the server
according to the first-in-first-out (FIFO) policy. In a case where each
request needs to be given a priority (chosen from a fixed set), a circular
buffer can be created for each priority to hold requests of that particular
priority.\

")
")
#langja("
#para("\

配列を用いたリングバッファは実用でも一般的に使われます。
例えば、典型的なクライアントサーバモデルにおいて、first-in-first-out (FIFO)
に従ってサーバが処理するべき複数のクライアントによる要求を保持するためにリングバッファを用いることができます。
それぞれの要求に (決まった範囲から選択することで) 優先度をつける必要がある場合、
特定の優先度の要求を保持するためにそれぞれの優先度にリングバッファを生成することができます。\

")
")

#langeng("
#para("\

Let us declare a linear abstract type (that is, abstract viewtype) as
follows for values representing circular buffers:

#atscode('\
absvtype
cbufObj (a:vt@ype+, m:int, n: int) = ptr
')

Such values are considered simple linear objects (as inheritance is not an
issue to be dealt with in this setting). Given a viewtype VT and two
integers M and N, the viewtype #stacode("cbufObj(VT, M, N)") is for a given
buffer of maximal capacity M that currently holds N elements of the type
VT.

")
")
#langja("
#para("\

リングバッファを表現する値のために、次のような線形抽象型 (つまり抽象 viewtype) を宣言してみましょう:

#atscode('\
absvtype
cbufObj (a:vt@ype+, m:int, n: int) = ptr
')

このような値は (状態を継承によって扱わない) 単純な線形オブジェクトであると考えられます。
viewtype VT と2つの整数 M と N が与えられた時、viewtype #stacode("cbufObj(VT, M, N)")
は型 VT の要素を N 個 持つ最大容量 M のバッファを表わします。

")
")

#langeng("
#para("\

Some properties on the parameters of #stacode("cbufObj") can be captured
by introducing the following proof function:

#atscode('\
prfun
lemma_cbufObj_param
  {a:vt0p}{m,n:int}
  (buf: !cbufObj (a, m, n)): [m>=n; n>=0] void
')

The interface for the following two function templates indicates that they
can be called to compute the capacity and current size of a buffer:

#atscode('\
fun{a:vt0p}
cbufObj_get_cap
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (m)

fun{a:vt0p}
cbufObj_get_size
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (n)
')

")
")
#langja("
#para("\

#stacode("cbufObj") のパラメータの性質のいくつかは、次の証明関数を導入することで捕捉できます:

#atscode('\
prfun
lemma_cbufObj_param
  {a:vt0p}{m,n:int}
  (buf: !cbufObj (a, m, n)): [m>=n; n>=0] void
')

次の2つの関数テンプレートのインターフェイスは、それらが容量とバッファの現在のサイズを算出するために呼び出されることを示しています:

#atscode('\
fun{a:vt0p}
cbufObj_get_cap
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (m)

fun{a:vt0p}
cbufObj_get_size
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (n)
')

")
")

#langeng("
#para("\

While it is straightforward to use #dyncode("cbufObj_get_cap") and
#dyncode("cbufObj_get_size") to tell whether a buffer is currently empty or
full, a direct approach is likely to be more efficient. The following two
function templates check for the emptiness and fullness of a given circular
buffer:

#atscode('\
//
fun{a:vt0p}
cbufObj_is_empty
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (n==0)
//
fun{a:vt0p}
cbufObj_is_full
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (m==n)
//
')

")
")
#langja("
#para("\

現在のバッファが空か満杯であるかを判定するのに #dyncode("cbufObj_get_cap") と #dyncode("cbufObj_get_size")
を単純に使うこともできますが、直接的なアプローチがより効率的です。
次の2つの関数テンプレートは、与えられたリングバッファが空であるか満杯であるかを判定します:

#atscode('\
//
fun{a:vt0p}
cbufObj_is_empty
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (n==0)
//
fun{a:vt0p}
cbufObj_is_full
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (m==n)
//
')

")
")

#langeng("
#para("\

The functions for creating and destroying circular buffers are named
#dyncode("cbufObj_new") and #dyncode("cbufObj_free"), respectively:

#atscode('\
fun{a:vt0p}
cbufObj_new
  {m:pos} (m: size_t m): cbufObj (a, m, 0)
//
fun cbufObj_free
  {a:vt0p}{m:int} (buf: cbufObj (a, m, 0)): void
')

Note that a buffer can be freed only if it contains no elements as
an element (of some viewtype) may contain resources. If elements in
a buffer are of some (non-linear) type, then the following function
can be called to clear out all the elements stored in the buffer:

#atscode('\
fun cbufObj_clear
  {a:t@ype}{m,n:int}
  (buf: !cbufObj (a, m, n) >> cbufObj (a, m, 0)): void
// end of [cbufObj_clear]
')

")
")
#langja("
#para("\

リングバッファの生成と解放を行なう関数はそれぞれ #dyncode("cbufObj_new") と #dyncode("cbufObj_free")
という名前です:

#atscode('\
fun{a:vt0p}
cbufObj_new
  {m:pos} (m: size_t m): cbufObj (a, m, 0)
//
fun cbufObj_free
  {a:vt0p}{m:int} (buf: cbufObj (a, m, 0)): void
')


バッファがリソースを含む可能性がある (なんらかの viewtype の)
要素を含まない時に限って、そのバッファを解放できることに注意してください。
バッファ中の要素がなんらかの線形でない型である場合、次の関数を呼び出してバッファ中に保管されている全ての要素を捨てることができます:

#atscode('\
fun cbufObj_clear
  {a:t@ype}{m,n:int}
  (buf: !cbufObj (a, m, n) >> cbufObj (a, m, 0)): void
// end of [cbufObj_clear]
')

")
")

#langeng("
#para("\

The next two functions are for inserting/removing an element into/from a
given buffer, which are probably the most frequently used operations on
buffers:

#atscode('\
//
fun{a:vt0p}
cbufObj_insert
  {m,n:int | n < m}
(
  buf: !cbufObj (a, m, n) >> cbufObj (a, m, n+1), x: a
) : void // end of [cbufObj_insert]
//
fun{a:vt0p}
cbufObj_remove
  {m,n:int | n > 0}
  (buf: !cbufObj (a, m, n) >> cbufObj (a, m, n-1)) : (a)
//
')

")
")
#langja("
#para("\

次の2つの関数は、与えられたバッファに対する要素の挿入と削除を行ないます。
おそらくこれらはバッファに対して最も頻繁に使われる操作でしょう:

#atscode('\
//
fun{a:vt0p}
cbufObj_insert
  {m,n:int | n < m}
(
  buf: !cbufObj (a, m, n) >> cbufObj (a, m, n+1), x: a
) : void // end of [cbufObj_insert]
//
fun{a:vt0p}
cbufObj_remove
  {m,n:int | n > 0}
  (buf: !cbufObj (a, m, n) >> cbufObj (a, m, n-1)) : (a)
//
')

")
")

#langeng("
#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
containing the entirety of the interface for functions creating, destroying
and manipulating circular buffers.\

")
")
#langja("
#para("\

リングバッファの生成/削除/操作の関数インターフェイス全体を含むファイルは
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
から入手できます。\

")
")

#langeng("
#para("\

There are many simple and practical ways to implement the abstract type
#stacode("cbufObj") and the functions declared in
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats").  In the file
#mycodelink("CHAP_ABSVTYPE/circbuf.dats", "circbuf.dats"), I give an
implementation that employs four pointers p_beg, p_end, p_frst and p_last
to represent a circular buffer: p_beg and p_end are the starting and
finishing addresses of the underline array, respectively, and p_frst and
p_last are the starting addresses of the occupied and unoccupied segments
(in the array), respectively. What is special about this implementation is
its employing a style of programming that deliberately eschews the need for
proof construction. While code written in this style is not guaranteed to
be type-safe, the style can nonetheless be of great practical value in a
setting where constructing formal proofs is deemed too costly a requirement
to be fully fulfilled. Anyone who tries to give a type-safe implementation
for the functions declared in #mycodelink("CHAP_ABSVTYPE/circbuf.sats",
"circbuf.sats") should likely find some genuine appreciation for this
point.

")
")
#langja("
#para("\

抽象型 #stacode("cbufObj") と #mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
で宣言されている関数を実装する簡単で実用的な方法はたくさんあります。
ファイル #mycodelink("CHAP_ABSVTYPE/circbuf.dats", "circbuf.dats")
では、リングバッファを表現するのに4つのポインタ p_beg, p_end, p_frst, p_last を用いる実装を与えました:
p_beg と p_end はそれぞれ下敷にする配列の開始と終了アドレスで、p_frst と p_last はそれぞれ (その配列中の)
占有している部分と空いている部分の開始アドレスです。
この実装の特殊な点は、証明の構築を意識的に避けたプログラミングスタイルであることです。
このスタイルで書かれたコードは型安全が保証されていませんが、正式な証明を構築することが高コストであるような状況下では、このスタイルにも大きな実用上の価値があります。
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
で宣言された関数について型安全な実装を得ようと試してみれば、この点において誠実な評価を実感できるはずです。

")
")

#langeng("
#para("\

In the file #mycodelink("CHAP_ABSVTYPE/circbuf2.dats", "circbuf2.dats"), I
give another implementation in which a circular buffer is represented as a
pointer p_beg plus three integers m, n and f: p_beg points to the starting
location of the underline array, m is the size of the array (that is, the
capacity of the buffer), n is the number of elements currently stored in
the buffer and f is the total number of elements that have so far been
removed from the buffer. Again, proof construction is delibrately eschewed
in this implementation.

")
")
#langja("
#para("\

ファイル #mycodelink("CHAP_ABSVTYPE/circbuf2.dats", "circbuf2.dats") では、ポインタ p_beg
と3つの整数 m, n, f によってリングバッファを表現する別の実装を与えています:
p_beg は下敷にする配列の開始位置を指し、m は配列のサイズ (つまりバッファの容量)、n
はバッファに現在保存されている要素の数、f は今までにバッファから削除された要素の総数です。
繰り返しますが、この実装でも故意に証明の構築をしていません。

")
")

</sect1><!--id="array-based-circular-buffer"-->

<!-- ****** ****** -->

<sect1
id="memory-allocation-deallocation">
#langeng("
#title("Memory Allocation and Deallocation")
")
#langja("
#title("メモリの確保と解放")
")

#langeng("
#para("\

The issue of memory allocation and deallocation is of paramount importance
in systems programming, where garabage collection (GC) at run-time may not
even be allowed.  Handling memory management safely and efficiently is a long
standing problem of great challenge in programming, and its novel solution
in ATS is firmly rooted in the paradigm of programming with theorem-proving
(PwTP).

")
")
#langja("
#para("\

メモリの確保と解放にまつわる問題は、実行時のガベージコレクション (GC)
が許されないシステムプログラミングにおいて最重要です。
メモリ管理を安全にかつ効率よく扱うことは、プログラミングの挑戦において長期にわたる未解決問題です。
そして ATS におけるその新しい解決策は、定理証明によるプログラミング (PwTP) のパラダイムに堅く根差しています。

")
")

#langeng("
#para('\

The following function #dyncode("malloc_gc") is available in ATS for memory
allocation:

#atscode("\
fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
")

The sort #stacode("agz") is a subset sort defined for addresses that are not
null:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

Given an integer N, the type #stacode("b0ytes(N)") is a shorthand for
#stacode("@[byte?][N]"), which is for an array of N uninitialized
bytes. Therefore, the at-view #stacode("b0ytes(N)@L") is the same as the
array-view #stacode("array_v(byte?, L, N)"), where L is a memory location.
The view constructor #stacode("mfree_gc_v") is abstract. For a given
location L, the view #stacode("mfree_gc_v(L)") stands for a form of
capability that allows allocated memory at location L to be freed (or
reclaimed) by the following function #dyncode("mfree_gc"):

#atscode("\
fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
")

Note that #stacode("mfree_gc_v(L)") is so far the first form of view we
have encountered that is not built on top of any at-views.

')
")
#langja("
#para('\

次の関数 #dyncode("malloc_gc") がメモリ確保のために ATS では用意されています:

#atscode("\
fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
")

種 #stacode("agz") は NULL でないアドレスとして定義されたサブセット種です:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

整数 N が与えられた時、
型 #stacode("b0ytes(N)") は N バイトの未初期化の配列を表わす #stacode("@[byte?][N]") の略記です
従って、at-view #stacode("b0ytes(N)@L") は L をメモリ位置とすると、配列 view
#stacode("array_v(byte?, L, N)") と同じです。
view コンストラクタ #stacode("mfree_gc_v") は抽象的です。
与えられた位置 L について、view #stacode("mfree_gc_v(L)") は次の関数 #dyncode("mfree_gc") によって解放されるべき位置 L に確保したメモリを許可する能力を表わします:

#atscode("\
fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
")

今まで紹介してきた中では、#stacode("mfree_gc_v(L)") はどのような at-view 上にも構築されていないはじめての
view の形であることに注意してください。

')
")

#langeng("
#para('\

In practice, it is rather cumbersome to deal with bytes directly.  The
function #dyncode("ptr_alloc") is available for allocating memory to store
a single value (of certain type) and the function #dyncode("ptr_free") for
deallocating such memory:

#atscode('\
fun{a:vt0p}
ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]
')

In addition, the function #dyncode("array_ptr_alloc") is for allocating
memory to store an array of values (of certain type), and the function
#dyncode("array_ptr_free") is for deallocating such memory:

#atscode('\
fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
')

')
")
#langja("
#para('\

実際には、バイト数を直接扱うのはいくぶん面倒です。
(ある型の) 単一の値を保管するメモリを確保する関数 #dyncode("ptr_alloc") と、そのようなメモリを解放する関数
#dyncode("ptr_free") が用意されています:

#atscode('\
fun{a:vt0p}
ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]
')

さらに、(ある型の) 値の配列を格納するメモリを確保する関数 #dyncode("array_ptr_alloc")
と、そのようなメモリを解放する関数 #dyncode("array_ptr_free") があります:

#atscode('\
fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
')

')
")

#langeng("
#para('\

I now give a realistic and interesting example involving both array
allocation and deallocation. The following two functions templates
#dyncode("msort1") and #dyncode("msort2") perform merge-sort on a given array:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

It is well-known that merging two sorted segments of a given array requires
additional space. When #dyncode("msort1") is called on arrays A and B, the
array A is the one to be sorted and the array B is some kind of scratch
area needed to perform merging (of sorted array segments). When a call to
#dyncode("msort1") returns, the sorted version of A is still sotred in
A. What #dyncode("msort2") does is similar but the sorted version of A is
stored in B when a call to #dyncode("msort2") returns.  As a good exercise,
I suggest that the interested reader take the effort to give a mutually
recursive implementation of #dyncode("msort1") and #dyncode("msort2").  An
implementation of merge-sort based on #dyncode("msort1") can be readily
given as follows:

#atscode('\
extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc<a> (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
')

Clearly, an array is first allocated (to be used as a scratch area) and
then deallocated after it is no longer needed.

')
")
#langja("
#para('\

ここで配列の確保と解放の両方を必要とする現実的で興味深い例を紹介します。
次の2つの関数テンプレート #dyncode("msort1") と #dyncode("msort2") は与えられた配列をマージソートします:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

与えられた配列の2つのソート済み部分をマージするには追加領域が必要になることがよく知られています。
#dyncode("msort1") が配列 A と B に対して呼び出された時、配列 A はソートされる対象で、配列 B
は (ソート済みの配列の領域の) マージを行なうのに必要なスクラッチ領域の一種です。
#dyncode("msort1") 呼び出しが返ると、A のソートされたバージョンはまだ A に保管されています。
#dyncode("msort2") が行なうことも同様ですが、#dyncode("msort2") 呼び出しが返ると A のソートされたバージョンは
B に保管されます。
興味を持った読者には、良い練習問題として #dyncode("msort1") と #dyncode("msort2")
の相互再帰的な実装をしてみることをおすすめします。
#dyncode("msort1") を用いたマージソートの実装は次のようにたやすく与えることができます:

#atscode('\
extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc<a> (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
')

明確に、配列は (スクラッチ領域として使われるために) はじめに確保され、それからもはや使わなくなった後に解放されます。

')
")

#langeng("
#para('\

It is also allowed for a function to allocate memory on its call-stack
by calling a special function #dyncode("alloca"), which is given the
following type in ATS:

#atscode('\
(*
staload "libc/SATS/alloa.sats"
*)
fun alloca
  {dummy:addr}{n:int} (
  pf: void@dummy | n: size_t (n)
) : [l:addr] (bytes(n) @ l, bytes(n) @ l -> void@dummy | ptr(l))
')

The type assigned to
#dyncode("alloca") makes it extremely unlikely for someone to
unintentionally write well-typed code in ATS that may erroneourly attempt
to access memory obtained from calling #dyncode("alloca") after the calling
function has returned.

')
")
#langja("
#para('\

また、特殊な関数 #dyncode("alloca") を呼び出すことでコールスタックにメモリを確保する関数も作ることができます。それには ATS では次のような型が与えられます:

#atscode('\
(*
staload "libc/SATS/alloa.sats"
*)
fun alloca
  {dummy:addr}{n:int} (
  pf: void@dummy | n: size_t (n)
) : [l:addr] (bytes(n) @ l, bytes(n) @ l -> void@dummy | ptr(l))
')

#dyncode("alloca") に割り当てられた型は、型付けされた ATS コードが #dyncode("alloca") 関数呼び出しが返った後に誤ってその関数呼び出しから得られたメモリにアクセスすることを防止します。

')
")

#langeng("
#para('\

The following function #dyncode("array_ptr_alloca_tsz") is the
same as #dyncode("alloca") dynamically but it is given a type that
is often more convenient to use:

#atscode('\
fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l))
')

As an example, the function template #dyncode("mergeSort") implemented
above can also be implemented as follows:

#atscode('\
implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val tsz = sizeof<a>
  var dummy: void = ()
  prval pf = view@dummy
  val (
    pfat, fpfat | p
  ) = array_ptr_alloca_tsz{a}(pf | n, tsz)
  val ((*void*)) = msort1<a> (A, n, !p, cmp)
  prval ((*void*)) = view@dummy := fpfat (pfat)
in
  // nothing
end // end of [mergeSort]
')

where the array used as a scratch area during merge-sort is allocated on
the call-stack of #dyncode("mergeSort"). While this implementation of
#dyncode("mergeSort") may seem interesting, it is actually inferior to the
previous implementation as calling #dyncode("alloca") to allocate a large
chunk of memory can readily lead to a crash for which the cause is often
very difficult to determine. In general, choosing #dyncode("alloca") over
#dyncode("malloc") is difficult to justify, and any call to the former
should be scrutinized.

')
")
#langja("
#para('\

次の関数 #dyncode("array_ptr_alloca_tsz") は動的には #dyncode("alloca") と同じです。しかしより便利な型が付けられています:

#atscode('\
fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l))
')

例として、上記で実装された関数テンプレート #dyncode("mergeSort") 次のように実装することもできます:

#atscode('\
implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val tsz = sizeof<a>
  var dummy: void = ()
  prval pf = view@dummy
  val (
    pfat, fpfat | p
  ) = array_ptr_alloca_tsz{a}(pf | n, tsz)
  val ((*void*)) = msort1<a> (A, n, !p, cmp)
  prval ((*void*)) = view@dummy := fpfat (pfat)
in
  // nothing
end // end of [mergeSort]
')

ここではマージを行なうのに必要なスクラッチ領域として使われる配列を #dyncode("mergeSort") のコールスタックに確保しています。この #dyncode("mergeSort") の実装は興味深いものですが、実際には以前の実装より劣っています。多きなメモリチャンクを確保する #dyncode("alloca") 呼び出しはクラッシュをたやすく引き起こし、その原因を見つけ出すのはしばしば困難です。一般に、#dyncode("malloc") よりも #dyncode("alloca") を使うことは正当化しずらく、前者に対する呼び出しは綿密に精査すべきです。

')
")

#langeng("
#para('\

The entire implementation of merge-sort on arrays plus some testing code
is available #mycodelink("CHAP_ABSVTYPE/mergeSort.dats", "on-line").

')
")
#langja("
#para('\

配列に対するマージソートの実装全体とテストコードは
#mycodelink("CHAP_ABSVTYPE/mergeSort.dats", "オンライン")
から入手できます。

')
")

</sect1><!--id="memory-allocation-deallocation"-->

<!-- ****** ****** -->

<sect1
id="locking-and-unlocking-shared-resources">
#title("Locking and Unlocking Shared Resources")

#para("\

In concurrent programming, the issue of safely locking and unlocking shared
resources is both essential and challenging.

")

</sect1><!--id="locking-and-unlocking-shared-resources"-->

<!-- ****** ****** -->

</chapter><!--id="abstract_views_viewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
