%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="abstract_views_viewtypes">
#langeng("
#title("Abstract Views and Viewtypes")
")
#langja("
#title("抽象観と観型 (viewtype)")
")

#langeng("
#para('\

I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view-changes). Often what the programmer really needs is to
figure out #emphasis("conceptually") whether abstractly defined views and
proof functions for manipulating them actually make sense. This is a bit
like arguing whether a function is computable: There is rarely a need, if
at all, to actually encode the function as a Turing-machine to prove its
being computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

')
")
#langja("
#para('\

今までは、駐観と駐観の上に構築された観にもっぱら注目して観の表現を見てきました。
駐観が実際にもっとも広く使われる観の形であり、また ATS がサポートした観の最初の形であることが、その大きな理由です。
けれども、抽象的な観の他の形を ATS に導入することもできます。
観を駐観 (もしくは観の他の形) を元にして定義できる場合においてさえ、(観変化する証明関数をともなう)
抽象観として導入したいと思うかもしれません。
しばしばプログラマが本当に必要とすることは、抽象的に定義された観とそれらを操作する証明関数が実際に意味をなすかどうか、#emphasis("概念的に") 理解することです。
これは関数が計算可能かどうか根拠を示すことに少し似ています:
例え、計算可能であることを立証するためにチューリングマシンに関数を実際にエンコードするとしても、まれにその必要があります。
私見ですが、抽象観と抽象的な観型 (viewtype) の適切な使い方を学ぶことは、実際にリソースに関連するプログラミングの問題に取り組むために、効果的に線形型を使うのに必要なステップです。

')
")

<!-- ****** ****** -->

<sect1
 id="simple-linear-objects">
#langeng("
#title("Simple Linear Objects")
")
#langja("
#title("単純な線形オブジェクト")
")

#langeng("
#para("\

Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name #emphasis("simple linear object") here to refer
to a linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.\

")
")
#langja("
#para("\

物理世界のオブジェクトが線形であることははっきりしています:
それらは無から生成することはできませんし、単に消し去って無へと帰すこともできません。
従って、物理オブジェクトを表現する値に線形型を割り当てることは極めて自然です。
継承をサポートするビルトインの仕組みを含まないようなある種のオブジェクトを表わす線形値を表わすのに、ここでは
#emphasis("単純な線形オブジェクト (simple linear object)") という名前を使います。\

")
")

#langeng("
#para('\

Let us now take a look at a concrete example of simple linear object.
The following code presents an interface for a timer (that is, stopwatch):

#atscode('\
//
absvtype timer_vtype
vtypedef timer = timer_vtype
//
fun timer_new (): timer
fun timer_free (x: timer): void
fun timer_start (x: !timer): void
fun timer_finish (x: !timer): void
fun timer_pause (x: !timer): void
fun timer_resume (x: !timer): void
fun timer_get_ntick (x: !timer): uint
fun timer_reset (x: !timer): void
//
')

The state of a timer is given the
record type #stacode("timer_struct") defined as follows:

#atscode('\
//
typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded when the timer
, ntick_beg= uint // was turned on last time
, ntick_acc= uint // the number of accumulated ticks
} (* end of [timer_struct] *)
//
')

The following linear datatype #stacode("timer")
is declared for timers, and the abstract type #stacode("timer_vtype")
is assumed to equal #stacode("timer"):

#atscode('\
//
datavtype timer =
  TIMER of (timer_struct)
//
assume timer_vtype = timer
//
')

')
")
#langja("
#para('\

単純な線形オブジェクトの具体的な例を見てみましょう。
次のコードは、タイマー (つまりストップウォッチです) のインターフェイスを表わしています:

#atscode('\
absvtype timer_vtype
vtypedef timer = timer_vtype

fun timer_new (): timer
fun timer_free (x: timer): void
fun timer_start (x: !timer): void
fun timer_finish (x: !timer): void
fun timer_pause (x: !timer): void
fun timer_resume (x: !timer): void
fun timer_get_ntick (x: !timer): uint
fun timer_reset (x: !timer): void
')

次に定義されるレコード型 #stacode("timer_struct") によってタイマーの状態が与えられます:

#atscode('\
typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded when the timer
, ntick_beg= uint // was turned on last time
, ntick_acc= uint // the number of accumulated ticks
} (* end of [timer_struct] *)
')

次の線形データ型 #stacode("timer") はタイマーのために宣言され、また抽象型 #stacode("timer_vtype") は
#stacode("timer") に等しいと見なされています:

#atscode('\
//
datavtype timer =
  TIMER of (timer_struct)
//
assume timer_vtype = timer
//
')

')
")

#langeng("
#para('\

Various functions on timers can now be readily implemented.
Let us first see the code for creating and freeing timers:

#atscode('\
implement
timer_new () = let
//
val timer = TIMER (_)
val TIMER (x) = timer
//
val () = x.started := false
val () = x.running := false
val () = x.ntick_beg := 0u
val () = x.ntick_acc := 0u
//
prval () = fold@ (timer)
//
in
  timer
end // end of [timer_new]

implement
timer_free (timer) =
  let val ~TIMER _ = timer in (*nothing*) end
// end of [timer_free]
')

')
")
#langja("
#para('\

タイマーに関する各種の関数をこれですぐに実装できます。
はじめにタイマーの生成と解放をするコードを見てみましょう:

#atscode('\

implement
timer_new () = let
//
val timer = TIMER (_)
val TIMER (x) = timer
//
val () = x.started := false
val () = x.running := false
val () = x.ntick_beg := 0u
val () = x.ntick_acc := 0u
//
prval () = fold@ (timer)
//
in
  timer
end // end of [timer_new]

implement
timer_free (timer) =
  let val ~TIMER _ = timer in (*nothing*) end
// end of [timer_free]

')

')
")

#langeng("
#para('\

The function for starting a timer can be implemented as follows:

#atscode('\
implement
timer_start
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := true
  val () = x.running := true
  val () = x.ntick_beg := the_current_tick_get ()
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_start]
')

where #dyncode("the_current_tick_get") is a function for
reading the current time (represented as a number of ticks):

#atscode('\
extern fun the_current_tick_get (): uint
')

')
")
#langja("
#para('\

タイマーを開始する関数は次のように実装できます:

#atscode('\
implement
timer_start
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := true
  val () = x.running := true
  val () = x.ntick_beg := the_current_tick_get ()
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_start]
')

このとき #dyncode("the_current_tick_get") は (ティックの数で表わされた) 現在時間を読む関数です:

#atscode('\
extern fun the_current_tick_get (): uint
')

')
")

#langeng("
#para('\

A timer can be stopped or paused. The function for stopping a timer can be
implemented as follows:

#atscode('\
implement
timer_finish
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_finish]
')

')
")
#langja("
#para('\

タイマーは停止したり休止したりすることができます。
タイマーを停止させる関数は次のように実装できます:

#atscode('\
implement
timer_finish
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_finish]
')

')
")

#langeng("
#para('\

A timer can be paused and then resumed.
The following code implements the functions for pausing and resuming a
timer:

#atscode('\
implement
timer_pause
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_pause]

implement
timer_resume
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.started && ~(x.running) then
  {
    val () = x.running := true
    val () = x.ntick_beg := the_current_tick_get ()
  } (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_resume]
')

As can be expected, the amount of time between the point
where a timer is paused and the point where the timer is resumed
is not counted.

')
")
#langja("
#para('\
タイマーは休止した後に再開することができます。
次のコードはタイマーの休止と再開の関数を実装しています:

#atscode('\

implement
timer_pause
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_pause]

implement
timer_resume
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.started && ~(x.running) then
  {
    val () = x.running := true
    val () = x.ntick_beg := the_current_tick_get ()
  } (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_resume]
')

予想できることですが、タイマーが休止してから再開するまでの時間の総計はカウントされません。

')
")

#langeng("
#para('\

It is also possible to reset a timer by calling the function
#dyncode("timer_reset"):

#atscode('\
implement
timer_reset
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () = x.running := false
  val () = x.ntick_beg := 0u
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_reset]
')

')
")
#langja("
#para('\

関数 #dyncode("timer_reset") を呼び出すことでタイマーをリセットすることもまた可能です:

#atscode('\
implement
timer_reset
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () = x.running := false
  val () = x.ntick_beg := 0u
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_reset]
')

')
")

#langeng("
#para('\

In order to read the time accumulated by a timer,
the function #dyncode("timer_get_ntick") can be called:

#atscode('\
implement
timer_get_ntick
  (timer) = let
  val+@TIMER(x) = timer
  var ntick: uint = x.ntick_acc
  val () =
  if x.running then (
    ntick := ntick + the_current_tick_get () - x.ntick_beg
  ) (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  ntick
end // end of [timer_get_ntick]
')

')
")
#langja("
#para('\

関数 #dyncode("timer_get_ntick") を呼び出すことで、
タイマーにたまった時間を読み出すことができます:

#atscode('\
implement
timer_get_ntick
  (timer) = let
  val+@TIMER(x) = timer
  var ntick: uint = x.ntick_acc
  val () =
  if x.running then (
    ntick := ntick + the_current_tick_get () - x.ntick_beg
  ) (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  ntick
end // end of [timer_get_ntick]
')

')
")

#langeng("
#para('\

A straightforward approach to
implementing #dyncode("the_current_tick_get")
can be based directly on the function #dyncode("clock_gettime"):

#atscode('\
local

staload "libc/SATS/time.sats"

in (* in-of-local *)

implement
the_current_tick_get () = let
  var tv: timespec // uninitialized
  val err = clock_gettime (CLOCK_REALTIME, tv)
  val ((*void*)) = assertloc (err >= 0)
  prval ((*void*)) = opt_unsome{timespec}(tv)
in
  $UNSAFE.cast2uint(tv.tv_sec)
end // end of [the_current_tick_get]

end // end of [local]
')

Note that the library flag #dyncode("-lrt") may be needed in order to
have link-time access to #dyncode("clock_gettime") as the function is in
#dyncode("librt").

')
")
#langja("
#para('\

#dyncode("the_current_tick_get") を実装するわかりやすいアプローチは、関数
#dyncode("clock_gettime") を直接用いることでしょう:

#atscode('\
local

staload "libc/SATS/time.sats"

in (* in-of-local *)

implement
the_current_tick_get () = let
  var tv: timespec // uninitialized
  val err = clock_gettime (CLOCK_REALTIME, tv)
  val ((*void*)) = assertloc (err >= 0)
  prval ((*void*)) = opt_unsome{timespec}(tv)
in
  $UNSAFE.cast2uint(tv.tv_sec)
end // end of [the_current_tick_get]

end // end of [local]
')

リンク時に #dyncode("librt") に含まれる関数 #dyncode("clock_gettime") にアクセスするために、ライブラリフラグ
#dyncode("-lrt") が必要になることに注意してください。

')
")

#langeng("
#para('\

Please find #mycodelink("CHAP_ABSVTYPE/timer.dats", "on-line") the
entirety of the code presented in this section plus some testing code.

')
")
#langja("
#para('\

この章で紹介したコード全体とテストコードは
#mycodelink("CHAP_ABSVTYPE/timer.dats", "オンライン")
から入手できます。

')
")

</sect1><!--id="simple-linear-objects"-->

<!-- ****** ****** -->

<sect1
 id="memory-allocation-deallocation">
#langeng("
#title("Memory Allocation and Deallocation")
")
#langja("
#title("メモリの確保と解放")
")

#langeng("
#para("\

The issue of memory allocation and deallocation is of paramount importance
in systems programming, where garabage collection (GC) at run-time may not
even be allowed.  Handling memory management safely and efficiently is a long
standing problem of great challenge in programming, and its novel solution
in ATS is firmly rooted in the paradigm of programming with theorem-proving
(PwTP).

")
")
#langja("
#para("\

メモリの確保と解放にまつわる問題は、実行時のガベージコレクション (GC)
が許されないシステムプログラミングにおいて最重要です。
メモリ管理を安全にかつ効率よく扱うことは、プログラミングの挑戦において長期にわたる未解決問題です。
そして ATS におけるその新しい解決策は、定理証明によるプログラミング (PwTP) のパラダイムに堅く根差しています。

")
")

#langeng("
#para('\

The following function #dyncode("malloc_gc") is available in ATS for memory
allocation:

#atscode("\
fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
")

The sort #stacode("agz") is a subset sort defined for addresses that are not
null:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

Given an integer N, the type #stacode("b0ytes(N)") is a shorthand for
#stacode("@[byte?][N]"), which is for an array of N uninitialized
bytes. Therefore, the at-view #stacode("b0ytes(N)@L") is the same as the
array-view #stacode("array_v(byte?, L, N)"), where L is a memory location.
The view constructor #stacode("mfree_gc_v") is abstract. For a given
location L, the view #stacode("mfree_gc_v(L)") stands for a form of
capability that allows allocated memory at location L to be freed (or
reclaimed) by the following function #dyncode("mfree_gc"):

#atscode("\
fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
")

Note that #stacode("mfree_gc_v(L)") is so far the first form of view we
have encountered that is not built on top of any at-views.

')
")
#langja("
#para('\

次の関数 #dyncode("malloc_gc") がメモリ確保のために ATS では用意されています:

#atscode("\
fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
")

種 #stacode("agz") は NULL でないアドレスとして定義されたサブセット種です:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

整数 N が与えられた時、
型 #stacode("b0ytes(N)") は N バイトの未初期化の配列を表わす #stacode("@[byte?][N]") の略記です
従って、駐観 #stacode("b0ytes(N)@L") は L をメモリ位置とすると、配列観
#stacode("array_v(byte?, L, N)") と同じです。
観コンストラクタ #stacode("mfree_gc_v") は抽象的です。
与えられた位置 L について、観 #stacode("mfree_gc_v(L)") は次の関数 #dyncode("mfree_gc") によって解放されるべき位置 L に確保したメモリを許可する能力を表わします:

#atscode("\
fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
")

今まで紹介してきた中では、#stacode("mfree_gc_v(L)") はどのような駐観の上にも構築されていないはじめての観の形であることに注意してください。

')
")

#langeng("
#para('\

In practice, it is rather cumbersome to deal with bytes directly.  The
function #dyncode("ptr_alloc") is available for allocating memory to store
a single value (of certain type) and the function #dyncode("ptr_free") for
deallocating such memory:

#atscode('\
fun{a:vt0p}
ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]
')

In addition, the function #dyncode("array_ptr_alloc") is for allocating
memory to store an array of values (of certain type), and the function
#dyncode("array_ptr_free") is for deallocating such memory:

#atscode('\
fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
')

')
")
#langja("
#para('\

実際には、バイト数を直接扱うのはいくぶん面倒です。
(ある型の) 単一の値を保管するメモリを確保する関数 #dyncode("ptr_alloc") と、そのようなメモリを解放する関数
#dyncode("ptr_free") が用意されています:

#atscode('\
fun{a:vt0p}
ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]
')

さらに、(ある型の) 値の配列を格納するメモリを確保する関数 #dyncode("array_ptr_alloc")
と、そのようなメモリを解放する関数 #dyncode("array_ptr_free") があります:

#atscode('\
fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
')

')
")

#langeng("
#para('\

I now give a realistic and interesting example involving both array
allocation and deallocation. The following two functions templates
#dyncode("msort1") and #dyncode("msort2") perform merge-sort on a given array:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

It is well-known that merging two sorted segments of a given array requires
additional space. When #dyncode("msort1") is called on arrays A and B, the
array A is the one to be sorted and the array B is some kind of scratch
area needed to perform merging (of sorted array segments). When a call to
#dyncode("msort1") returns, the sorted version of A is still sotred in
A. What #dyncode("msort2") does is similar but the sorted version of A is
stored in B when a call to #dyncode("msort2") returns.  As a good exercise,
I suggest that the interested reader take the effort to give a mutually
recursive implementation of #dyncode("msort1") and #dyncode("msort2").  An
implementation of merge-sort based on #dyncode("msort1") can be readily
given as follows:

#atscode('\
extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort
  (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc<a> (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
')

Clearly, an array is first allocated (to be used as a scratch area) and
then deallocated after it is no longer needed.

')
")
#langja("
#para('\

ここで配列の確保と解放の両方を必要とする現実的で興味深い例を紹介します。
次の2つの関数テンプレート #dyncode("msort1") と #dyncode("msort2") は与えられた配列をマージソートします:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

与えられた配列の2つのソート済み部分をマージするには追加領域が必要になることがよく知られています。
#dyncode("msort1") が配列 A と B に対して呼び出された時、配列 A はソートされる対象で、配列 B
は (ソート済みの配列の領域の) マージを行なうのに必要なスクラッチ領域の一種です。
#dyncode("msort1") 呼び出しが返ると、A のソートされたバージョンはまだ A に保管されています。
#dyncode("msort2") が行なうことも同様ですが、#dyncode("msort2") 呼び出しが返ると A のソートされたバージョンは
B に保管されます。
興味を持った読者には、良い練習問題として #dyncode("msort1") と #dyncode("msort2")
の相互再帰的な実装をしてみることをおすすめします。
#dyncode("msort1") を用いたマージソートの実装は次のようにたやすく与えることができます:

#atscode('\
extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc<a> (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
')

明確に、配列は (スクラッチ領域として使われるために) はじめに確保され、それからもはや使わなくなった後に解放されます。

')
")

#langeng("
#para('\

It is also allowed for a function to allocate memory on its call-stack
by calling a special function #dyncode("alloca"), which is given the
following type in ATS:

#atscode('\
(*
staload "libc/SATS/alloa.sats"
*)
fun alloca
  {dummy:addr}{n:int} (
  pf: void@dummy | n: size_t (n)
) : [l:addr] (bytes(n) @ l, bytes(n) @ l -> void@dummy | ptr(l))
')

The type assigned to
#dyncode("alloca") makes it extremely unlikely for someone to
unintentionally write well-typed code in ATS that may erroneourly attempt
to access memory obtained from calling #dyncode("alloca") after the calling
function has returned.

')
")
#langja("
#para('\

また、特殊な関数 #dyncode("alloca") を呼び出すことでコールスタックにメモリを確保する関数も作ることができます。それには ATS では次のような型が与えられます:

#atscode('\
(*
staload "libc/SATS/alloa.sats"
*)
fun alloca
  {dummy:addr}{n:int} (
  pf: void@dummy | n: size_t (n)
) : [l:addr] (bytes(n) @ l, bytes(n) @ l -> void@dummy | ptr(l))
')

#dyncode("alloca") に割り当てられた型は、型付けされた ATS コードが #dyncode("alloca") 関数呼び出しが返った後に誤ってその関数呼び出しから得られたメモリにアクセスすることを防止します。

')
")

#langeng("
#para('\

The following function #dyncode("array_ptr_alloca_tsz") is the
same as #dyncode("alloca") dynamically but it is given a type that
is often more convenient to use:

#atscode('\
fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l))
')

As an example, the function template #dyncode("mergeSort") implemented
above can also be implemented as follows:

#atscode('\
implement
{a}(*tmp*)
mergeSort
  (A, n, cmp) = let
  val tsz = sizeof<a>
  var dummy: void = ()
  prval pf = view@dummy
  val (
    pfat, fpfat | p
  ) = array_ptr_alloca_tsz{a}(pf | n, tsz)
  val ((*void*)) = msort1<a> (A, n, !p, cmp)
  prval ((*void*)) = view@dummy := fpfat (pfat)
in
  // nothing
end // end of [mergeSort]
')

where the array used as a scratch area during merge-sort is allocated on
the call-stack of #dyncode("mergeSort"). While this implementation of
#dyncode("mergeSort") may seem interesting, it is actually inferior to the
previous implementation as calling #dyncode("alloca") to allocate a large
chunk of memory can readily lead to a crash for which the cause is often
very difficult to determine. In general, choosing #dyncode("alloca") over
#dyncode("malloc") is difficult to justify, and any call to the former
should be scrutinized.

')
")
#langja("
#para('\

次の関数 #dyncode("array_ptr_alloca_tsz") は動的には #dyncode("alloca") と同じです。しかしより便利な型が付けられています:

#atscode('\
fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l))
')

例として、上記で実装された関数テンプレート #dyncode("mergeSort") 次のように実装することもできます:

#atscode('\
implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val tsz = sizeof<a>
  var dummy: void = ()
  prval pf = view@dummy
  val (
    pfat, fpfat | p
  ) = array_ptr_alloca_tsz{a}(pf | n, tsz)
  val ((*void*)) = msort1<a> (A, n, !p, cmp)
  prval ((*void*)) = view@dummy := fpfat (pfat)
in
  // nothing
end // end of [mergeSort]
')

ここではマージを行なうのに必要なスクラッチ領域として使われる配列を #dyncode("mergeSort") のコールスタックに確保しています。この #dyncode("mergeSort") の実装は興味深いものですが、実際には以前の実装より劣っています。大きなメモリチャンクを確保する #dyncode("alloca") 呼び出しはクラッシュをたやすく引き起こし、その原因を見つけ出すのはしばしば困難です。一般に、#dyncode("malloc") よりも #dyncode("alloca") を使うことは正当化しずらく、後者に対する呼び出しは綿密に精査すべきです。

')
")

#langeng("
#para('\

The entire implementation of merge-sort on arrays plus some testing code
is available #mycodelink("CHAP_ABSVTYPE/mergeSort.dats", "on-line").

')
")
#langja("
#para('\

配列に対するマージソートの実装全体とテストコードは
#mycodelink("CHAP_ABSVTYPE/mergeSort.dats", "オンライン")
から入手できます。

')
")

</sect1><!--id="memory-allocation-deallocation"-->

<!-- ****** ****** -->

<sect1
 id="array-based-circular-buffers">
#langeng("
#title("\
Example: Array-Based Circular Buffers\
")
")
#langja("
#title("\
例: 配列を用いたリングバッファ\
")
")

#langeng("
#para("\

Array-based circular buffers are of common use in practice. For instance,
in a typical client/server model, a circular buffer can be employed to hold
requests issued by multiple clients that are then processed by the server
according to the first-in-first-out (FIFO) policy. In a case where each
request needs to be given a priority (chosen from a fixed set), a circular
buffer can be created for each priority to hold requests of that particular
priority.\

")
")
#langja("
#para("\

配列を用いたリングバッファは実用でも一般的に使われます。
例えば、典型的なクライアントサーバモデルにおいて、first-in-first-out (FIFO)
に従ってサーバが処理するべき複数のクライアントによる要求を保持するためにリングバッファを用いることができます。
それぞれの要求に (決まった範囲から選択することで) 優先度をつける必要がある場合、
特定の優先度の要求を保持するためにそれぞれの優先度にリングバッファを生成することができます。\

")
")

#langeng("
#para("\

Let us declare a linear abstract type (that is, abstract viewtype) as
follows for values representing circular buffers:

#atscode('\
absvtype
cbufObj (a:vt@ype+, m:int, n: int) = ptr
')

Such values are considered simple linear objects (as inheritance is not an
issue to be dealt with in this setting). Given a viewtype VT and two
integers M and N, the viewtype #stacode("cbufObj(VT, M, N)") is for a given
buffer of maximal capacity M that currently holds N elements of the type
VT.

")
")
#langja("
#para("\

リングバッファを表現する値のために、次のような線形抽象型 (つまり抽象観型) を宣言してみましょう:

#atscode('\
absvtype
cbufObj (a:vt@ype+, m:int, n: int) = ptr
')

このような値は (状態を継承によって扱わない) 単純な線形オブジェクトであると考えられます。
観型 VT と2つの整数 M と N が与えられた時、観型 #stacode("cbufObj(VT, M, N)")
は型 VT の要素を N 個 持つ最大容量 M のバッファを表わします。

")
")

#langeng("
#para("\

Some properties on the parameters of #stacode("cbufObj") can be captured
by introducing the following proof function:

#atscode('\
//
prfun
lemma_cbufObj_param
  {a:vt0p}{m,n:int}
  (buf: !cbufObj(a, m, n)): [m>=n; n>=0] void
//
')

The interface for the following two function templates indicates that they
can be called to compute the capacity and current size of a buffer:

#atscode('\
//
fun{a:vt0p}
cbufObj_get_cap
  {m,n:int} (buf: !cbufObj(a, m, n)): size_t(m)
//
fun{a:vt0p}
cbufObj_get_size
  {m,n:int}(buf: !cbufObj(a, m, n)): size_t(n)
//
')

")
")
#langja("
#para("\

#stacode("cbufObj") のパラメータの性質のいくつかは、次の証明関数を導入することで捕捉できます:

#atscode('\
prfun
lemma_cbufObj_param
  {a:vt0p}{m,n:int}
  (buf: !cbufObj (a, m, n)): [m>=n; n>=0] void
')

次の2つの関数テンプレートのインターフェイスは、それらが容量とバッファの現在のサイズを算出するために呼び出されることを示しています:

#atscode('\
fun{a:vt0p}
cbufObj_get_cap
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (m)

fun{a:vt0p}
cbufObj_get_size
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (n)
')

")
")

#langeng("
#para("\

While it is straightforward to use #dyncode("cbufObj_get_cap") and
#dyncode("cbufObj_get_size") to tell whether a buffer is currently empty or
full, a direct approach is likely to be more efficient. The following two
function templates check for the emptiness and fullness of a given circular
buffer:

#atscode('\
//
fun{a:vt0p}
cbufObj_is_empty
  {m,n:int}(buf: !cbufObj(a, m, n)): bool(n==0)
//
fun{a:vt0p}
cbufObj_is_full
  {m,n:int}(buf: !cbufObj(a, m, n)): bool(m==n)
//
')

")
")
#langja("
#para("\

現在のバッファが空か満杯であるかを判定するのに #dyncode("cbufObj_get_cap") と #dyncode("cbufObj_get_size")
を単純に使うこともできますが、直接的なアプローチがより効率的です。
次の2つの関数テンプレートは、与えられたリングバッファが空であるか満杯であるかを判定します:

#atscode('\
//
fun{a:vt0p}
cbufObj_is_empty
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (n==0)
//
fun{a:vt0p}
cbufObj_is_full
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (m==n)
//
')

")
")

#langeng("
#para("\

The functions for creating and destroying circular buffers are named
#dyncode("cbufObj_new") and #dyncode("cbufObj_free"), respectively:

#atscode('\
//
fun{a:vt0p}
cbufObj_new
  {m:pos}(m: size_t(m)): cbufObj(a, m, 0)
//
fun cbufObj_free
  {a:vt0p}{m:int}(buf: cbufObj(a, m, 0)): void
//
')

Note that a buffer can be freed only if it contains no elements as
an element (of some viewtype) may contain resources. If elements in
a buffer are of some (non-linear) type, then the following function
can be called to clear out all the elements stored in the buffer:

#atscode('\
fun
cbufObj_clear
  {a:t@ype}{m,n:int}
  (buf: !cbufObj(a, m, n) >> cbufObj(a, m, 0)): void
// end of [cbufObj_clear]
')

")
")
#langja("
#para("\

リングバッファの生成と解放を行なう関数はそれぞれ #dyncode("cbufObj_new") と #dyncode("cbufObj_free")
という名前です:

#atscode('\
//
fun{a:vt0p}
cbufObj_new
  {m:pos}(m: size_t(m)): cbufObj(a, m, 0)
//
fun cbufObj_free
  {a:vt0p}{m:int}(buf: cbufObj(a, m, 0)): void
//
')

バッファがリソースを含む可能性がある (なんらかの観型の)
要素を含まない時に限って、そのバッファを解放できることに注意してください。
バッファ中の要素がなんらかの線形でない型である場合、次の関数を呼び出してバッファ中に保管されている全ての要素を捨てることができます:

#atscode('\
fun
cbufObj_clear
  {a:t@ype}{m,n:int}
  (buf: !cbufObj(a, m, n) >> cbufObj(a, m, 0)): void
// end of [cbufObj_clear]
')

")
")

#langeng("
#para("\

The next two functions are for inserting/removing an element into/from a
given buffer, which are probably the most frequently used operations on
buffers:

#atscode('\
//
fun{a:vt0p}
cbufObj_insert
  {m,n:int | n < m}
(
  buf: !cbufObj(a, m, n) >> cbufObj(a, m, n+1), x: a
) : void // end of [cbufObj_insert]
//
fun{a:vt0p}
cbufObj_remove
  {m,n:int | n > 0}
  (buf: !cbufObj(a, m, n) >> cbufObj(a, m, n-1)): (a)
//
')

")
")
#langja("
#para("\

次の2つの関数は、与えられたバッファに対する要素の挿入と削除を行ないます。
おそらくこれらはバッファに対して最も頻繁に使われる操作でしょう:

#atscode('\
//
fun{a:vt0p}
cbufObj_insert
  {m,n:int | n < m}
(
  buf: !cbufObj (a, m, n) >> cbufObj (a, m, n+1), x: a
) : void // end of [cbufObj_insert]
//
fun{a:vt0p}
cbufObj_remove
  {m,n:int | n > 0}
  (buf: !cbufObj (a, m, n) >> cbufObj (a, m, n-1)) : (a)
//
')

")
")

#langeng("
#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
containing the entirety of the interface for functions creating, destroying
and manipulating circular buffers.\

")
")
#langja("
#para("\

リングバッファの生成/削除/操作の関数インターフェイス全体を含むファイルは
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
から入手できます。\

")
")

#langeng("
#para("\

There are many simple and practical ways to implement the abstract type
#stacode("cbufObj") and the functions declared in
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats").  In the file
#mycodelink("CHAP_ABSVTYPE/circbuf.dats", "circbuf.dats"), I give an
implementation that employs four pointers p_beg, p_end, p_frst and p_last
to represent a circular buffer: p_beg and p_end are the starting and
finishing addresses of the underline array, respectively, and p_frst and
p_last are the starting addresses of the occupied and unoccupied segments
(in the array), respectively. What is special about this implementation is
its employing a style of programming that deliberately eschews the need for
proof construction. While code written in this style is not guaranteed to
be type-safe, the style can nonetheless be of great practical value in a
setting where constructing formal proofs is deemed too costly a requirement
to be fully fulfilled. Anyone who tries to give a type-safe implementation
for the functions declared in #mycodelink("CHAP_ABSVTYPE/circbuf.sats",
"circbuf.sats") should likely find some genuine appreciation for this
point.

")
")
#langja("
#para("\

抽象型 #stacode("cbufObj") と #mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
で宣言されている関数を実装する簡単で実用的な方法はたくさんあります。
ファイル #mycodelink("CHAP_ABSVTYPE/circbuf.dats", "circbuf.dats")
では、リングバッファを表現するのに4つのポインタ p_beg, p_end, p_frst, p_last を用いる実装を与えました:
p_beg と p_end はそれぞれ下敷にする配列の開始と終了アドレスで、p_frst と p_last はそれぞれ (その配列中の)
占有している部分と空いている部分の開始アドレスです。
この実装の特殊な点は、証明の構築を意識的に避けたプログラミングスタイルであることです。
このスタイルで書かれたコードは型安全が保証されていませんが、正式な証明を構築することが高コストであるような状況下では、このスタイルにも大きな実用上の価値があります。
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
で宣言された関数について型安全な実装を得ようと試してみれば、この点において誠実な評価を実感できるはずです。

")
")

#langeng("
#para("\

In the file #mycodelink("CHAP_ABSVTYPE/circbuf2.dats", "circbuf2.dats"), I
give another implementation in which a circular buffer is represented as a
pointer p_beg plus three integers m, n and f: p_beg points to the starting
location of the underline array, m is the size of the array (that is, the
capacity of the buffer), n is the number of elements currently stored in
the buffer and f is the total number of elements that have so far been
removed from the buffer. Again, proof construction is delibrately eschewed
in this implementation.

")
")
#langja("
#para("\

ファイル #mycodelink("CHAP_ABSVTYPE/circbuf2.dats", "circbuf2.dats") では、ポインタ p_beg
と3つの整数 m, n, f によってリングバッファを表現する別の実装を与えています:
p_beg は下敷にする配列の開始位置を指し、m は配列のサイズ (つまりバッファの容量)、n
はバッファに現在保存されている要素の数、f は今までにバッファから削除された要素の総数です。
繰り返しますが、この実装でも故意に証明の構築をしていません。

")
")

</sect1><!--id="array-based-circular-buffers"-->

<!-- ****** ****** -->

<sect1
 id="locking-and-unlocking">
#langeng("
#title("Locking and Unlocking")
")
#langja("
#title("ロックとアンロック")
")

#langeng("
#para("\

In concurrent programming, the issue of safely locking and unlocking
shared resources is both essential and challenging. I am to demonstrate
in this section concretely and convincingly that linear types can be used
with great effectiveness to address this issue.

")
")
#langja("
#para("\

並行プログラミングでは、共有リソースに対する安全なロックとアンロックは本質的で意欲的な課題です。
この章では、線形型がこの課題を解決するのに有効であることを具体的に説明します。

")
")

#langeng("
#para("\

Let us first introduce a linear abstract type #stacode("shared")
as follows:

#atscode('\
absvtype shared(a:vtype) = ptr
')

Given a viewtype VT (for some resources), a value of the type
#stacode("shared(VT)") is essentially a boxed record containing a resource
of the type VT plus a lock (or several) of some kind. The following
function #dyncode("shared_make") is called to turn a resource into a shared
resource:

#atscode('\
fun shared_make{a:vtype}(x: a): shared(a)  
')

Notice that the type #stacode("shared(VT)") itself is linear. In terms of
implementation, there is usually a reference count inside a linear shared
resource that is protected by a spin-lock. The functions
#dyncode("shared_ref") and #dyncode("shared_unref") are for increasing and
descreasing the reference count inside a shared resource:

#atscode('\
fun shared_ref{a:vtype}(!shared(a)): shared(a)
fun shared_unref{a:vtype}(shared(a)): Option_vt(a)
')

If the reference count of a shared resource is 1, then calling
#dyncode("shared_unref") on the shared resource frees the memory used in
its representation and then returns the resource stored inside it.

")
")
#langja("
#para("\

はじめに、次のような線形抽象型 #stacode("shared") を導入しましょう:

#atscode('\
absvtype shared(a:vtype) = ptr
')

(なんらかのリソースに対する) 観型 VT が与えられたとき、型 #stacode("shared(VT)") の値は、本質的に、型 VT のリソースとなんらかのロックを含んだボックス化レコードです。
リソースを共有リソースにするために、次のような関数 #dyncode("shared_make") が呼ばれます。

#atscode('\
fun shared_make{a:vtype}(x: a): shared(a)  
')

型 #stacode("shared(VT)") それ自身が線形であることに注意してください。
実装では、スピンロックで保護された線形共有リソースにはリファレンスカウントが内在しています。
関数 #dyncode("shared_ref") と #dyncode("shared_unref") は共有リソース内のリファレンスカウントを増減させます:

#atscode('\
fun shared_ref{a:vtype}(!shared(a)): shared(a)
fun shared_unref{a:vtype}(shared(a)): Option_vt(a)
')

もし共有リソースのリファレンスカウントが 1 であったら、その共有リソースへの #dyncode("shared_unref") 呼び出しはそれらの表現で使われていたメモリを解放し、その共有リソースに保存されていたリソースを返します。

")
")

#langeng("
#para("\

The function #dyncode("shared_lock") acquires the resource from a
given shared resource and the function #dyncode("shared_unlock") does
the opposite:

#atscode('\
//
absview locked_v
//
fun shared_lock{a:vtype}(!shared(a)): (locked_v | a)
fun shared_unlock{a:vtype}(locked_v | !shared(a), x: a): void
//
')

Note that the abstract view #stacode("locked_v") is introduced for linear
proofs that are meant to remind the programmer that a shared resoure needs
to be released after it is acquired.

")
")
#langja("
#para("\

関数 #dyncode("shared_lock") は与えられた共有リソースからリソースを獲得し、関数 #dyncode("shared_unlock") はその反対です:

#atscode('\
//
absview locked_v
//
fun shared_lock{a:vtype}(!shared(a)): (locked_v | a)
fun shared_unlock{a:vtype}(locked_v | !shared(a), x: a): void
//
')

抽象観 #stacode("locked_v") が線形証明として導入されていることに注意してください。この線形証明は共有リソースは獲得の後に解放しなければならないことを、プログラマに気付かせます。

")
")

#langeng("
#para("\

As can be expected, a shared resource can be implemented as a boxed tuple
consisting of a spin-lock, a reference count and a pointer (referring to
the stored resource):

#atscode('\
//
datavtype
shared_ (a:vtype) =
  SHARED of (spin1_vt(*lock*), int(*count*), ptr)
//
assume shared = shared_
//
')

Note that the type #stacode("spin1_vt") is for linear spin-locks. The
function #dyncode("shared_ref") is implemented as follows:

#atscode('\
implement
shared_ref
  {a}(sh) = let
//
val+@SHARED
  (spin, count, _) = sh
//
val
spin = // for temp. use
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
val c0 = count
val () = count := c0 + 1
val ((*void*)) = spin_unlock(pf | spin)
prval ((*void*)) = fold@sh
//
in
  $UN.castvwtp1{shared(a)}(sh)
end // end of [shared_ref]
')

Clearly, the implementation makes use of several unsafe casts.  An
implementation without such casts would be highly involved even if it could
be done.  The spin-lock must be acquired before the binding between
#dyncode("c0") and the integer stored in #dyncode("count") is formed for
otherwise a race condition can appear. The function #dyncode("shared_unref")
is implemented as follows:

#atscode('\
implement
shared_unref
  {a}(sh) = let
//
val+@SHARED
  (spin, count, _) = sh
//
val
spin = // for temp. use
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
val c0 = count
val () = count := c0 - 1
val ((*void*)) = spin_unlock(pf | spin)
prval ((*void*)) = fold@sh
//
in
//
if
c0 <= 1
then let
  val+~SHARED(spin, _, x) = sh
  val ((*freed*)) = spin_vt_destroy(spin)
in
  Some_vt($UN.castvwtp0{a}(x))
end // end of [then]
else let
  prval () = $UN.cast2void(sh) in None_vt()
end // end of [else]
//
end // end of [shared_unref]
')

In the case where the reference count is 1,
then the shared resource is freed, the spin-lock in it
is destroyed, and the resource in it is returned.

")
")
#langja("
#para("\

予想できることですが共有リソースは、スピンロック、リファレンスカウントと (保管されたリソースを差す) ポインタから成る、ボックス化タプルとして実装できます:

#atscode('\
//
datavtype
shared_ (a:vtype) =
  SHARED of (spin1_vt(*lock*), int(*count*), ptr)
//
assume shared = shared_
//
')

型 #stacode("spin1_vt") は線形スピンロックを表わすことに注意してください。関数 #dyncode("shared_ref") は次のように実装されます:

#atscode('\
implement
shared_ref
  {a}(sh) = let
//
val+@SHARED
  (spin, count, _) = sh
//
val
spin = // for temp. use
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
val c0 = count
val () = count := c0 + 1
val ((*void*)) = spin_unlock(pf | spin)
prval ((*void*)) = fold@sh
//
in
  $UN.castvwtp1{shared(a)}(sh)
end // end of [shared_ref]
')

この実装が安全でないキャストをいくつか使っていることは明白です。そのようなキャストを使わない実装は可能だとしてもとても複雑になるでしょう。
そのとき #dyncode("c0") と #dyncode("count") に保管された整数の間に束縛を作る前にスピンロックを獲得しなければなりません。
そうでなければレースコーンディションの原因になります。
関数 #dyncode("shared_unref") は次のように実装されます:

#atscode('\
implement
shared_unref
  {a}(sh) = let
//
val+@SHARED
  (spin, count, _) = sh
//
val
spin = // for temp. use
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
val c0 = count
val () = count := c0 - 1
val ((*void*)) = spin_unlock(pf | spin)
prval ((*void*)) = fold@sh
//
in
//
if
c0 <= 1
then let
  val+~SHARED(spin, _, x) = sh
  val ((*freed*)) = spin_vt_destroy(spin)
in
  Some_vt($UN.castvwtp0{a}(x))
end // end of [then]
else let
  prval () = $UN.cast2void(sh) in None_vt()
end // end of [else]
//
end // end of [shared_unref]
')

リファレンスカウントが 1 である場合、共有リソースが解放され、その中のスピンロックが破棄され、そして共有リソースの中にあったリソースが返ります。

")
")

#langeng("
#para("\

The functions
#dyncode("shared_lock")
and
#dyncode("shared_unlock")
are implemented as follows:

#atscode('\
implement
shared_lock
  {a}(sh) = let
//
val+@SHARED(spin, _, x) = sh
//
val
spin =
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
//
val x0 = $UN.castvwtp0{a}(x)
//
prval () = fold@sh
//
in
  ($UN.castview0(pf) | x0)
end // end of [shared_lock]
')

#atscode('\
implement
shared_unlock
  {a}(pf | sh, x0) = let
//
val+@SHARED(spin, _, x) = sh
//
val
spin =
  unsafe_spin_vt2t(spin)
//
val () = x := $UN.castvwtp0{ptr}(x0)
//
val () =
  spin_unlock($UN.castview0(pf) | spin)
//
prval () = fold@sh
//
in
  // nothing
end // end of [shared_unlock]
')

In the case of #dyncode("shared_lock"), please notice that the content
stored in the variable #dyncode("x") is read out after the spin-lock is
acquired. This is crucial for otherwise a race condition can readily
appear. In the case of #dyncode("shared_unlock"), the content of the
variable #dyncode("x") is updated before the acquired spin-lock is
released.\

")
")
#langja("
#para("\

関数 #dyncode("shared_lock") と #dyncode("shared_unlock") は次のように実装されます:

#atscode('\
implement
shared_lock
  {a}(sh) = let
//
val+@SHARED(spin, _, x) = sh
//
val
spin =
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
//
val x0 = $UN.castvwtp0{a}(x)
//
prval () = fold@sh
//
in
  ($UN.castview0(pf) | x0)
end // end of [shared_lock]
')

#atscode('\
implement
shared_unlock
  {a}(pf | sh, x0) = let
//
val+@SHARED(spin, _, x) = sh
//
val
spin =
  unsafe_spin_vt2t(spin)
//
val () = x := $UN.castvwtp0{ptr}(x0)
//
val () =
  spin_unlock($UN.castview0(pf) | spin)
//
prval () = fold@sh
//
in
  // nothing
end // end of [shared_unlock]
')

#dyncode("shared_lock") において、値 #dyncode("x") の中身はスピンロック獲得後に読み出されていることに注目してください。
これは重要な点で、さもなくばレースコンディションを引き起こします。
#dyncode("shared_unlock") においては、獲得されたスピンロックを解放する前に、値 #dyncode("x") の中身を更新しています。\

")
")

#langeng("
#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/shared_vt.dats", "shared_vt.dats")
containing the entirety of the code presented in this section. In addition,
the file also contains an implementation of three threads that move in
locked steps: thread 0 moves; thread 1 moves; thread 2 moves; thread 0
moves; thread 1 moves; thread 2 moves; etc.\

")
")
#langja("
#para("\

この章で紹介したコード全体を含む #mycodelink("CHAP_ABSVTYPE/shared_vt.dats", "shared_vt.dats")
ファイルはオンラインから入手できます。
また、このファイルはロックを保持した動作が: スレッド0が動作し; スレッド1が動作し; スレッド2が動作し; スレッド0が動作し; スレッド1が動作し; スレッド2が動作し; というように動く3つのスレッドの実装も含んでいます。\

")
")

</sect1><!--id="locking-and-unlocking"-->

<!-- ****** ****** -->

<sect1
 id="linear-channels-for-async-ipc">
#langeng("
#title("Linear Channels for Asynchronous IPC")
")
#langja("
#title("非同期 IPC のための線形チャネル")
")

#langeng("
#para("\

In this section, I will present an implementation of
linear channels to support asynchronous communication between threads. This
is also a very fitting occasion for me to advocate what I often refer to as
#emphasis("programmer-centric") program verification.\

")
")
#langja("
#para("\

この章では、スレッド間の非同期通信をサポートする、線形チャネルの実装を示します。
これはまた、#emphasis("プログラマ中心") のプログラム検証を主張する良い機会でもあります。\

")
")

#langeng("
#para("\

A communication channel between threads is essentially
a queue wrapped in some kind of protection mechanism needed for guarding
against race conditions.  Assume that a queue is of a fixed capacity, that
is, the capacity of the queue is fixed after its creation. If the queue is
full, then inserting an element into it results in a failure.  If the queue
is empty, then removing an element from it results in a failure. In order
to prevent inserting into a full queue or removing from an empty queue, I
could first introduce a linear abstract type for queues as follows:

#atscode("\
absvtype
queue_vtype(a:vt@ype+, int(*m*), int(*n*))
vtypedef queue(a:vt@ype,m:int,n:int) = queue_vtype(a,m,n)
")

where the type #stacode("queue(VT,M,N)") is for a queue of capacity M that
currently contains N elements of type VT. Then the functions for inserting
into and removing from a queue are expected to be given the following
interface:

#atscode("\
//
fun{a:vt0p}
queue_insert
  {m,n:nat | m > n}
  (!queue(a, m, n) >> queue(a, m, n+1), a): void
//
fun{a:vt0p}
queue_remove
  {m,n:nat | n > 0}(!queue(a, m, n) >> queue(a, m, n-1)): (a)
//
")

The presented abstract type #stacode("queue") can indeed work very well for
the task of implementing linear channels. However, I will not continue with
this version of #stacode("queue") further for I intend to present a style of
program verification that is less rigorous but far more flexible.

")
")
#langja("
#para("\

本質的にスレッド間の通信チャネルは、レースコンディションをに対して必要ななんらかの保護メカニズムで包んだキューです。
容量固定のキュー、すなわち生成されたら容量が変わらないようなキューを仮定しましょう。
もしそのキューが満杯なら、そのキューへの要素の挿入は失敗します。
もしそのキューが空なら、そのキューからの要素の削除は失敗します。
満杯のキューへの挿入や空のキューからの削除を防ぐために、まず次のようなキューに対する線形抽象型を導入しましょう:

#atscode("\
absvtype
queue_vtype(a:vt@ype+, int(*m*), int(*n*))
vtypedef queue(a:vt@ype,m:int,n:int) = queue_vtype(a,m,n)
")

このとき、型 #stacode("queue(VT,M,N)") は、型 VT の N 個の要素を含んでいる容量 M のキューを表わします。
それから、挿入と削除を表わす関数には次のようなインターフェイスが割り当てられるでしょう:

#atscode("\
//
fun{a:vt0p}
queue_insert
  {m,n:nat | m > n}
  (!queue(a, m, n) >> queue(a, m, n+1), a): void
//
fun{a:vt0p}
queue_remove
  {m,n:nat | n > 0}(!queue(a, m, n) >> queue(a, m, n-1)): (a)
//
")

示した抽象型 #stacode("queue") は線形チャネルを実装として機能します。
けれども、私はこのバージョンの #stacode("queue") を採用できません。
私は、厳密でより柔軟なプログラム検証のスタイルを示したいのです。

")
")

#langeng("
#para("\

Following is another version of abstract type #stacode("queue"):

#atscode("\
//
absvtype
queue_vtype(a:vt@ype+, int(*id*)) = ptr
//
vtypedef
queue(a:vt0p, id:int) = queue_vtype(a, id)
vtypedef queue(a:vt0p) = [id:int] queue(a, id)
//
")

Given a viewtype VT and an integer ID, #stacode("queue(VT,ID)") is for a
queue containing elements of the type VT that can be uniquely identified
with the integer ID. So one may think of ID as some form of stamp. The
following declared function #dyncode("queue_isnil") is for testing whether
a given queue is empty:


#atscode("\
//
absprop ISNIL(id:int, b:bool)
//
fun
{a:vt0p}
queue_isnil{id:int}(!queue(a, id)): [b:bool] (ISNIL(id, b) | bool(b))
//
")

Given an integer ID, a proof of the prop #stacode("ISNIL(ID,true)")
(#stacode("ISNIL(ID,false)")) means that the queue uniquely identified by
ID is (not) empty. Similarly, the following declared function
#dyncode("queue_isful") is for testing whether a given queue is full:

#atscode("\
//
absprop ISFUL(id:int, b:bool)
//
fun
{a:vt0p}
queue_isful{id:int}(!queue(a, id)): [b:bool] (ISFUL(id, b) | bool(b))
//
")

Given an integer ID, a proof of the prop #stacode("ISFUL(ID,true)")
(#stacode("ISFUL(ID,false)")) means that the queue uniquely identified by
ID is (not) full.

")
")
#langja("
#para("\

次のコードは抽象型 #stacode("queue") の別バージョンです:

#atscode("\
//
absvtype
queue_vtype(a:vt@ype+, int(*id*)) = ptr
//
vtypedef
queue(a:vt0p, id:int) = queue_vtype(a, id)
vtypedef queue(a:vt0p) = [id:int] queue(a, id)
//
")

観型 VT と整数 ID が与えられたとき、#stacode("queue(VT,ID)") は、整数 ID で一意に識別される型 VT の要素を含むキューを表わします。
そのため ID はスタンプの一種と考えることができます。
次に表わされた関数 #dyncode("queue_isnil") は与えられたキューが空であるかどうか調べます:


#atscode("\
//
absprop ISNIL(id:int, b:bool)
//
fun
{a:vt0p}
queue_isnil{id:int}(!queue(a, id)): [b:bool] (ISNIL(id, b) | bool(b))
//
")

整数 ID が与えられたとき、命題 #stacode("ISNIL(ID,true)") (もしくは #stacode("ISNIL(ID,false)")) の証明は、ID で同定されたキューが空である (もしくは空でない) ことを意味しています。
同様に、次に表わされた関数 #dyncode("queue_isful") は与えられたキューが満杯であるかどうか調べます:

#atscode("\
//
absprop ISFUL(id:int, b:bool)
//
fun
{a:vt0p}
queue_isful{id:int}(!queue(a, id)): [b:bool] (ISFUL(id, b) | bool(b))
//
")

整数 ID が与えられたとき、命題 #stacode("ISFUL(ID,true)") (もしくは #stacode("ISFUL(ID,false)")) の証明は、ID で同定されたキューが満杯である (もしくは満杯でない) ことを意味しています。

")
")

#langeng("
#para("\

The functions #dyncode("queue_insert") and #dyncode("queue_remove")
for inserting into and removing from a given queue can now be given the
following interface:

#atscode("\
//
extern
fun
{a:vt0p}
queue_insert
  {id:int}
(
  ISFUL(id, false)
| xs: !queue(a, id) >> queue(a, id2), x: a
) : #[id2:int] void
//
extern
fun
{a:vt0p}
queue_remove
  {id:int}
(
  ISNIL(id, false) | xs: !queue(a, id) >> queue(a, id2)
) : #[id2:int] a // end-of-fun
//
")

Note that either inserting an element into a queue or removing an element
from a queue assigns a new stamp to the queue.  This is essential for
interpreting #stacode("ISNIL") and #stacode("ISFUL") in the manner presented
above.

")
")
#langja("
#para("\

これで、与えられたキューへの挿入と削除を表わす関数 #dyncode("queue_insert") と #dyncode("queue_remove") には次のインターフェイスを割り当てることができます:

#atscode("\
//
extern
fun
{a:vt0p}
queue_insert
  {id:int}
(
  ISFUL(id, false)
| xs: !queue(a, id) >> queue(a, id2), x: a
) : #[id2:int] void
//
extern
fun
{a:vt0p}
queue_remove
  {id:int}
(
  ISNIL(id, false) | xs: !queue(a, id) >> queue(a, id2)
) : #[id2:int] a // end-of-fun
//
")

キューへの挿入やキューからの削除が、新しいスタンプをそのキューに割り当てていることに注意してください。
これは本質的に、上記に示したマナーでの #stacode("ISNIL") と #stacode("ISFUL") の解釈です。

")
")

#langeng("
#para("\

In order to call #dyncode("queue_insert") on a given queue, one needs to
have a proof attesting to the queue being not full. Such a proof is
obtained if calling #dyncode("queue_isful") on the queue returns false.
Similarly, in order to call #dyncode("queue_remove") on a given queue,
one can first call #dyncode("queue_isnil") on the queue to obtain a proof
attesting to the queue being not empty.\

")
")
#langja("
#para("\

与えられたキューへ #dyncode("queue_insert") を呼び出すためには、そのキューが満杯ではないことを示す証明が必要です。
当該キューに #dyncode("queue_isful") を呼び出して false が返れば、そのような証明を獲得できます。
同様に、与えられたキューへ #dyncode("queue_remove") を呼び出すためには、まずそのキューに #dyncode("queue_isnil") を呼び出して、そのキューが空でないことを示す証明を獲得する必要があります。\

")
")

#langeng("
#para("\

What is really of concern here is not to actually verify that
#dyncode("queue_isnil") and #dyncode("queue_isful") have the interface
assigned to them. Instead, the focus is on ensuring that
#dyncode("queue_insert") is never applied to a full queue and
#dyncode("queue_remove") is never applied to an empty queue under the
assumption that #dyncode("queue_isnil") and #dyncode("queue_isful") have
the assigned interface. I refer to this form of program verification as
being #emphasis("programmer-centric") because its correctness is not
formally established in an objective manner. I myself find that
programmer-centric program verification is very flexible and effective in
practice.  If we believe that constructing informal mathematical proofs can
help one check whether the proven statements are valid, then it is only
natural to believe that programmer-centric program verification can also
help one check whether verified programs are correct.\

")
")
#langja("
#para("\

ここで示した内容は、#dyncode("queue_isnil") と #dyncode("queue_isful") が持つそのインターフェイスを実際には立証していません。
その代わりここでの焦点は、#dyncode("queue_isnil") と #dyncode("queue_isful")
にそのようなインターフェイスが割り当てられたとき、満杯のキューに #dyncode("queue_insert")
が呼び出されないことと #dyncode("queue_remove") が空のキューに呼び出されないことを保証することです。
私はこのスタイルのプログラミング検証を #emphasis("プログラマ中心") であると呼んでいます。
なぜならその正確さは客観的形式的に確立されたものではないからです。
私自身、プログラマ中心のプログラム検証が実際にとても柔軟で効果的であることを見つけました。
もし非形式的な数学の証明が証明された内容が正当であるかどうか検査するのに役立つと我々が信じるのであれば、プログラマ中心のプログラム検証もまた検証されたプログラムが正しいかどうか検査するのに役立つことを自然に信じることができるでしょう。\

")
")

#langeng("
#para("\

Let us now start to implement linear channels for asynchronous
communication between threads. First, let us declare a linear abstract
type #stacode("channel") as follows:


#atscode("\
absvtype channel_vtype(a:vt@ype+) = ptr
vtypedef channel(a:vt0p) = channel_vtype(a)
")

The function for inserting an element into a channel is given the following
interface:

#atscode("\
fun{a:vt0p} channel_insert (!channel(a), a): void
")

The caller of #dyncode("channel_insert") is blocked if the channel is full.
Similarly, the function for removing an element from a channel is given the following
interface:

#atscode("\
fun{a:vt0p} channel_remove (chan: !channel(a)): (a)
")

The caller of #dyncode("channel_remove") is blocked if the channel is empty.

")
")
#langja("
#para("\

それでは、スレッド間の非同期通信のための線形チャネルの実装を開始しましょう。
はじめに、次のような線形抽象型 #stacode("channel") を宣言しましょう:


#atscode("\
absvtype channel_vtype(a:vt@ype+) = ptr
vtypedef channel(a:vt0p) = channel_vtype(a)
")

チャネルに要素を挿入する関数には次のインターフェイスが与えられます:

#atscode("\
fun{a:vt0p} channel_insert (!channel(a), a): void
")

もしそのチャネルが満杯であったら、#dyncode("channel_insert") の呼び出し元はブロックします。
同様に、チャネルから要素を削除する関数には次のインターフェイスが与えられます:

#atscode("\
fun{a:vt0p} channel_remove (chan: !channel(a)): (a)
")

もしそのチャネルが空であったら、#dyncode("channel_remove") の呼び出し元はブロックします。

")
")

#langeng("
#para("\

Let a channel be represented as follows:

#atscode("\
//
datavtype
channel_ =
{
l0,l1,l2,l3:agz
} CHANNEL of
@{
  cap=intGt(0)
, spin=spin_vt(l0)
, rfcnt=intGt(0)
, mutex=mutex_vt(l1)
, CVisnil=condvar_vt(l2)
, CVisful=condvar_vt(l3)
, queue=ptr // deqarray
} (* end of [channel] *)
//
assume channel_vtype(a:vt0p) = channel_
//
")

There are 7 fields in the record representing a channel; the
#dyncode("cap") field stores an integer indicating the (fixed) capacity of
the channel; the #dyncode("spin") field stores a spin-lock for protecting
the reference count in the field of the name #dyncode("rfcnt"); the
#dyncode("mutex") field stores a mutex for protecting the queue in the
field of the name #dyncode("queue"); the field #dyncode("CVisnil") stores a
conditional variable for the situation where a caller (holding the mutex)
wants to wait for the condition that the queue becomes not empty; the
field #dyncode("CVisful") stores a conditional variable for the situation
where a caller (holding the mutex) wants to wait for the condition that the
queue becomes not full.

")
")
#langja("
#para("\

チャネルを次のように表現してみましょう:

#atscode("\
//
datavtype
channel_ =
{
l0,l1,l2,l3:agz
} CHANNEL of
@{
  cap=intGt(0)
, spin=spin_vt(l0)
, rfcnt=intGt(0)
, mutex=mutex_vt(l1)
, CVisnil=condvar_vt(l2)
, CVisful=condvar_vt(l3)
, queue=ptr // deqarray
} (* end of [channel] *)
//
assume channel_vtype(a:vt0p) = channel_
//
")

チャネルを表現するレコードには7つのフィールドがあります;
#dyncode("cap") フィールドはそのチャネルの (固定の) 容量を示す整数を保持しています;
#dyncode("spin") フィールドは、#dyncode("rfcnt") フィールドにあるリファレンスカウントを保護するためのスピンロックを保持しています;
#dyncode("mutex") フィールドは、#dyncode("queue") フィールドにあるキューを保護するための mutex を保持しています;
#dyncode("CVisnil") フィールドは、(mutex を保持した) 呼び出し元がキューが空ではなくなるのを待つための条件変数を保持しています;
#dyncode("CVisful") フィールドは、(mutex を保持した) 呼び出し元がキューが満杯ではなくなるのを待つための条件変数を保持しています。

")
")

#langeng("
#para("\

The function
#dyncode("channel_insert") is given the following implementation:

#atscode("\
implement
{a}(*tmp*)
channel_insert
  (chan, x0) = let
//
val+CHANNEL
  {l0,l1,l2,l3}(ch) = chan
val mutex = unsafe_mutex_vt2t(ch.mutex)
val (pfmut | ()) = mutex_lock (mutex)
val xs =
  $UN.castvwtp0{queue(a)}((pfmut | ch.queue))
val ((*void*)) = channel_insert2<a> (chan, xs, x0)
prval pfmut = $UN.castview0{locked_v(l1)}(xs)
val ((*void*)) = mutex_unlock (pfmut | mutex)
//
in
  // nothing
end // end of [channel_insert]
")

where
the auxiliary function #dyncode("channel_insert2") is given
the following interface:

#atscode("\
fun{a:vt0p}
channel_insert2
  (!channel(a), !queue(a) >> _, a): void
")

Please note that #dyncode("channel_insert2") is called when
the caller is holding the mutex inside the channel. Following
is an implementation for #dyncode("channel_insert2"):

#atscode("\
implement
{a}(*tmp*)
channel_insert2
  (chan, xs, x0) = let
//
val+CHANNEL
  {l0,l1,l2,l3}(ch) = chan
//
val (pf | isful) = queue_isful (xs)
//
in
//
if
isful
then let
  prval
  (pfmut, fpf) =
  __assert () where
  {
    extern
    praxi __assert (): vtakeout0(locked_v(l1))
  }
  val mutex = unsafe_mutex_vt2t(ch.mutex)
  val CVisful = unsafe_condvar_vt2t(ch.CVisful)
  val ((*void*)) = condvar_wait (pfmut | CVisful, mutex)
  prval ((*void*)) = fpf (pfmut)
in
  channel_insert2 (chan, xs, x0)
end // end of [then]
else let
  val isnil = queue_isnil (xs)
  val ((*void*)) = queue_insert (pf | xs, x0)
  val ((*void*)) =
  if isnil.1
    then condvar_broadcast(unsafe_condvar_vt2t(ch.CVisnil))
  // end of [if]
in
  // nothing
end // end of [else]
//
end // end of [channel_insert2]
")

The logic behind #dyncode("channel_insert2") can be explained as follows.
If the queue in the given channel is full, the caller calls
#dyncode("condvar_wait") to release the mutex it holds and then wait on the
conditional variable stored in the field #dyncode("CVisful") of the
channel; after the caller regains the mutex after being awoken by a signal
sent to the conditioanl variable, it calls #dyncode("channel_insert2")
recursively. If the queue in the given channel is not full, then the caller
insert a given element into the queue stored in the field #dyncode("queue")
and then returns. Note that #dyncode("channel_insert2") is a tail-recursive
function that essentially corresponds to a standard while-loop often
appearing in C code for handling the wait on a conditional variable.\

")
")
#langja("
#para("\

関数 #dyncode("channel_insert") には次の実装が与えられます:

#atscode("\
implement
{a}(*tmp*)
channel_insert
  (chan, x0) = let
//
val+CHANNEL
  {l0,l1,l2,l3}(ch) = chan
val mutex = unsafe_mutex_vt2t(ch.mutex)
val (pfmut | ()) = mutex_lock (mutex)
val xs =
  $UN.castvwtp0{queue(a)}((pfmut | ch.queue))
val ((*void*)) = channel_insert2<a> (chan, xs, x0)
prval pfmut = $UN.castview0{locked_v(l1)}(xs)
val ((*void*)) = mutex_unlock (pfmut | mutex)
//
in
  // nothing
end // end of [channel_insert]
")

このとき、補助関数 #dyncode("channel_insert2") には次のインターフェイスが与えらえます:

#atscode("\
fun{a:vt0p}
channel_insert2
  (!channel(a), !queue(a) >> _, a): void
")

呼び出し元がチャネル中の mutex を保持した状態で #dyncode("channel_insert2") は呼び出されることに注意してください。
次のコードは #dyncode("channel_insert2") の実装です:

#atscode("\
implement
{a}(*tmp*)
channel_insert2
  (chan, xs, x0) = let
//
val+CHANNEL
  {l0,l1,l2,l3}(ch) = chan
//
val (pf | isful) = queue_isful (xs)
//
in
//
if
isful
then let
  prval
  (pfmut, fpf) =
  __assert () where
  {
    extern
    praxi __assert (): vtakeout0(locked_v(l1))
  }
  val mutex = unsafe_mutex_vt2t(ch.mutex)
  val CVisful = unsafe_condvar_vt2t(ch.CVisful)
  val ((*void*)) = condvar_wait (pfmut | CVisful, mutex)
  prval ((*void*)) = fpf (pfmut)
in
  channel_insert2 (chan, xs, x0)
end // end of [then]
else let
  val isnil = queue_isnil (xs)
  val ((*void*)) = queue_insert (pf | xs, x0)
  val ((*void*)) =
  if isnil.1
    then condvar_broadcast(unsafe_condvar_vt2t(ch.CVisnil))
  // end of [if]
in
  // nothing
end // end of [else]
//
end // end of [channel_insert2]
")

#dyncode("channel_insert2") の背後にあるロジックは次のように説明できます。
与えられたチャネルのキューが満杯であったなら、呼び出し元はその mutex を手放すために #dyncode("condvar_wait")
を呼び出し、それからチャネルの #dyncode("CVisful") フィールド中の条件変数を待ち合わせます;
条件変数へのシグナル送信で起きた呼び出し元は、mutex を再び保持した後、#dyncode("channel_insert2") を再帰的に呼び出します。
与えられたチャネルのキューが満杯でなかったなら、呼び出し元は #dyncode("queue") フィールド中のキューに与えられた要素を挿入して返ります。
#dyncode("channel_insert2") が末尾再帰関数であり、条件変数を待ち合わせるC言語コードによくある標準的な while ループに本質的に対応していることに注意してください。

")
")

#langeng("
#para("\

By following the above implementation for #dyncode("channel_insert") (and
#dyncode("channel_insert2")), it should be pretty straightforward for one
to figure out an implementation for #dyncode("channel_remove"). I leave it
as an exercise.

")
")
#langja("
#para("\

#dyncode("channel_insert") (と #dyncode("channel_insert2")) の上記実装を真似て、#dyncode("channel_remove") の実装を導くことは単純でしょう。
これは練習問題とします。

")
")

#langeng("
#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/channel_vt.dats", "channel_vt.dats")
containing the entirety of the code presented in this section plus some
code for testing.\

")
")
#langja("
#para("\

この章で紹介したコード全体とテストコードを含む
#mycodelink("CHAP_ABSVTYPE/channel_vt.dats", "channel_vt.dats")
ファイルはオンラインから入手できます。\

")
")

</sect1><!--id="linear-channels-for-async-ipc"-->

</chapter><!--id="abstract_views_viewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
