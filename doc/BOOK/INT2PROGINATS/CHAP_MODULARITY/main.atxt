%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="modularity">
#langeng("
#title("Modularity")
")
#langja("
#title("モジュール性")
")

#langeng("
#para("\

Generally speaking, modularity in programming means to organize programs in
a modular fashion so that they each can be constructed in a relatively
isolated manner and then be combined to function coherently.  I will
introduce in this section some features in ATS that are largely designed to
facilitate program organization.\

")
")
#langja("
#para("\

一般的に言って、プログラミングにおけるモジュール性とは、モジュールスタイルでプログラムを組織化することです。
そのスタイルとは、モジュールそれぞれがある作法で分離されて構築されていて、
一貫した方法で機能を形作ることです。
この章では ATS における、大きなプログラムの組織化を容易にするいくつかの機能を紹介します。\

")
")

#langeng("
#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_MODULARITY/", "on-line").\

")
")
#langja("
#para("\

この章で紹介するコードとテストのためのいくつかの追加コードは
#mycodelink("CHAP_MODULARITY/", "オンライン")
から取得できます。\

")
")

<!-- ****** ****** -->

<sect1
id="types_as_a_form_of_specification">
#langeng("
<title>
Types as a Form of Specification
</title>
")
#langja("
<title>
仕様としての型
</title>
")

#langeng("
#para("\

The interface for a function or value specifies a type that any
implementation of the function or value should possess. For instance, the
following code defines a function #dyncode("fact") for computing the
factorial of a given integer:

#dats2xhtml('\
fun fact (x: int): int = if x > 0 then x * fact (x-1) else 1
')

It is also possible to first declare an interface for #dyncode("fact") as
follows:

#dats2xhtml('\
extern fun fact (x: int): int
')

where #keycode("extern") is a keyword in ATS that initiates the declaration
of an interface. Alternative ways to declare an interface for #dyncode("fact")
are given as follows:

#dats2xhtml('\
extern fun fact : (int) -> int
extern val fact : (int) -> int
')

If #dyncode("fact") is declared to be a function, then it is required to be
applied when occurring in code. If it is declared to be a value, there is
no such a restriction.\

")#comment("para")
")
#langja("
#para("\

関数や値に対するインターフェイスは、その関数や値の実装が有するべき型を特定します。
例えば、次のコードは与えられた整数の階乗を計算する関数 #dyncode("fact") を定義しています:

#dats2xhtml('\
fun fact (x: int): int = if x > 0 then x * fact (x-1) else 1
')

最初に考えられる #dyncode("fact") のインターフェイス定義は次のようなものでしょう:

#dats2xhtml('\
extern fun fact (x: int): int
')

#keycode("extern") は、インターフェイスの宣言を開始する ATS のキーワードです。
#dyncode("fact") のインターフェイスを宣言する別の方法は次のようなものです:

#dats2xhtml('\
extern fun fact : (int) -> int
extern val fact : (int) -> int
')

もし #dyncode("fact") が関数として宣言されたなら、
コード中で使うには適用させる必要があります。
もし値として宣言されたのであれば、そのような制約はありません。\

")#comment("para")
")

#langeng("
#para("\

A function interface can be considered as a form of specification. For
instance, the above interface for #dyncode("fact") specifies that
#dyncode("fact") is a function that takes one argument required to be an
integer and returns a value guaranteed to be an integer. What is so special
about this form of specification is that it is formally enforced in ATS
through typechecking: Any well-typed implementation of #dyncode("fact") in
ATS must possess the interface declared for it.  Of course, this interface
for #dyncode("fact") is not a precise specification as there are
(infinitely) many functions that can be given the same interface. This kind
of imprecision can, however, be reduced or even eliminated,
sometimes. After dependent types are introduced, I will present an
interface for #dyncode("fact") such that any implementation of the
interface is guaranteed to implement precisely the factorial function as is
defined by the following two equations:

<itemizedlist>

<listitem>
#para("
fact(0) = 1
")
</listitem>

<listitem>
#para("
fact(n) = n * fact (n-1) for each natural number n > 0
")
</listitem>

</itemizedlist>

")#comment("para")
")
#langja("
#para("\

関数インターフェイスは仕様だと考えることができます。
例えば、#dyncode("fact") に対する上記のインターフェイスは、#dyncode("fact")
が整数の引数を1つ取り、整数であることが保証された値を返す関数であることを指定しています。
この仕様の形式の特殊な点は、ATS の型検査によって強制されるということです:
ATSにおける正しく型付けされた #dyncode("fact") の実装はそのような宣言のインターフェイスを持たなければなりません。
もちろん、この #dyncode("fact") のインターフェイスは厳格な仕様でありません。
同じインターフェイスを持つ多くの (場合によっては無限に) 関数実体が存在するからです。
けれどもこの一種の不正確性は、時に軽減したり除去することさえできます。
依存型を説明した後で、次の2つの等式で定義される階乗の関数を正確にインターフェイスの実装とすることを保証するような
#dyncode("fact") のインターフェイスを紹介しようと思います:

<itemizedlist>

<listitem>
#para("
fact(0) = 1
")
</listitem>

<listitem>
#para("
fact(n) = n * fact (n-1) for each natural number n > 0
")
</listitem>

</itemizedlist>

")#comment("para")
")

#langeng("
#para("\

An implementation for #dyncode("fact") as the following one can be given at
any point where the declared interface for #dyncode("fact") is accessible:

#dats2xhtml('\
implement fact (x) = if x > 0 then x * fact (x-1) else 1
')

The keyword #keycode("implement") is for initiating an implementation of a
function or value whose interface is already declared. It is fairly common
to see the following style of coding, usually, by a beginning ATS programmer:

#dats2xhtml('\
implement fact (x: int): int = if x > 0 then x * fact (x-1) else 1
')

While this implementation can pass typechecking, it is nonetheless of a
poor style: The types provided by the programmer for the argument and the
result of #dyncode("fact") are redundant as they can be automatically
synthesized by the typechecker.\

")#comment("para")
")
#langja("
#para("\

次に示す #dyncode("fact") の実装は #dyncode("fact") で宣言したインターフェイスを守っています:

#dats2xhtml('\
implement fact (x) = if x > 0 then x * fact (x-1) else 1
')

#keycode("implement") キーワードは、既にインターフェイスを宣言された関数や値の実装の開始を表わします。
ATS 初心者にとっては、次のコーディングスタイルがより一般的かもしれません:

#dats2xhtml('\
implement fact (x: int): int = if x > 0 then x * fact (x-1) else 1
')

この実装は型検査を通りますが、にもかかわらず悪いスタイルと言えます。
#dyncode("fact") の引数と返値にプログラマが与えた型は、
型検査器によって自動的に合成されるため、冗長です。\

")#comment("para")
")

#langeng("
#para("\

As an example of an interface for a value, #dyncode("fact10") is declared
as follows to be a value of the type #stacode("int"):

#dats2xhtml('\
extern val fact10 : int
')

The following implementation for #dyncode("fact10") can be given at any
point where the declared interface for #dyncode("fact10") is accessible:

#dats2xhtml('\
implement fact10 = fact (10)
')

")#comment("para")
")
#langja("
#para("\

値に対するインターフェイスの例として、
型 #stacode("int") の値である #dyncode("fact10") を次に宣言してみます:

#dats2xhtml('\
extern val fact10 : int
')

次に示す #dyncode("fact10") の実装は #dyncode("fact10") で宣言したインターフェイスを守っています:

#dats2xhtml('\
implement fact10 = fact (10)
')

")#comment("para")
")

#langeng("
#para("\

As another example, the following code declares an interface for a
polymorphic function named #dyncode("swap_boxed"):

#dats2xhtml('\
extern
fun swap_boxed{a,b:type} (xy: (a, b)): (b, a)
')

Note that both type variables #stacode("a") and #stacode("b") are boxed.
An implementation for #dyncode("swap_boxed") is given as follows:

#dats2xhtml('\
implement swap_boxed{a,b} (xy) = (xy.1, xy.0)
')

The syntax #stacode("{a,b}") is for passing static arguments #stacode("a")
and #stacode("b") to #dyncode("swap_boxed") simultaneously. As neither
#stacode("a") nor #stacode("b") is actually used in the body of
#dyncode("swap_boxed"), it is allowed to drop #stacode("{a,b}") in this
case.\

")#comment("para")
")
#langja("
#para("\

別の例として、次のコードでは #dyncode("swap_boxed") という名前で多相関数のインターフェイスを宣言しています:

#dats2xhtml('\
extern
fun swap_boxed{a,b:type} (xy: (a, b)): (b, a)
')

型変数 #stacode("a") と #stacode("b") はボックス化されていることに注意してください。
#dyncode("swap_boxed") の実装は次のようになるでしょう:

#dats2xhtml('\
implement swap_boxed{a,b} (xy) = (xy.1, xy.0)
')

#stacode("{a,b}") という構文は、静的な変数 #stacode("a") と #stacode("b") を #dyncode("swap_boxed")
に同時に渡しています。
#stacode("a") も #stacode("b") も実際には #dyncode("swap_boxed") の中身では使われないので、
この場合 #stacode("{a,b}") は省くことができます。\

")#comment("para")
")

#langeng("
#para("\

As yet another example, the following code declares an interface for a
function template named #dyncode("swap_tmplt"):

#dats2xhtml('\
extern
fun{a,b:t@ype} swap_tmplt (xy: (a, b)): (b, a)
')

Note that both type variables #stacode("a") and #stacode("b") are of the
sort #stacode("t@ype"), indicating that they can be of any size.

An implementation for #dyncode("swap_tmplt") is given as follows:

#dats2xhtml('\
implement{a,b} swap_tmplt (xy) = (xy.1, xy.0)
')

")#comment("para")
")
#langja("
#para("\

また別の例として、
次のコードは #dyncode("swap_tmplt") という名前で関数テンプレートのインターフェイスを宣言しています:

#dats2xhtml('\
extern
fun{a,b:t@ype} swap_tmplt (xy: (a, b)): (b, a)
')

型変数 #stacode("a") と #stacode("b") は種 #stacode("t@ype") であることに注意してください。
これらの型変数がどのようなサイズも取れることを示しています。

#dyncode("swap_tmplt") の実装は次のようなものでしょう:

#dats2xhtml('\
implement{a,b} swap_tmplt (xy) = (xy.1, xy.0)
')

")#comment("para")
")

#langeng("
#para("\

It is a standard practice for a programmer to first design interfaces for
the functions to be supported in a package before actually implementing any
of these functions. When such interfaces are available, application
programs can be constructed to test whether the interface design makes
sense or is convenient for practical use. Please remember that a superb
implementation of a poor design cannot make the design any
better. Therefore, testing a design before actually implementing it is
often of vital importance. This is especially true if the involved design
is complex.\

")
")
#langja("
#para("\

実際に関数を実装する前に、
パッケージでサポートすべき関数のインターフェイスをデザインすることは、プログラマにとって一般的な訓練です。
そのようなインターフェイスがあれば、
そのインターフェイスデザインが妥当で実際に使いやすいかどうか検査するために、
アプリケーションプログラムを作ることができます。
貧弱なデザインを持つ素晴しい実装は良いデザインを作りえないということを、覚えておいてください。
したがって、実際に実装する前にデザインを検査することはしばしば非常に重要になります。
複雑なデザインが入り組んでいる時には、特に重要です。\

")
")

</sect1><!--id="types_as_a_form_of_specification"-->

<sect1
id="static_and_dynamic_ats_files">
#langeng("
<title>
Static and Dynamic ATS Files
</title>
")
#langja("
<title>
ATS の静的/動的ファイル
</title>
")

#langeng("
#para("\

The first letters in the ATS filename extensions #emphasis("sats") and
#emphasis("dats") refer to the words #emphasis("static") and
#emphasis("dynamic"), respectively.  For instance, #filename("foo.sats") is
a name for a static file while #filename("bar.dats") is for a dynamic
one. A static file is often referred to as a SATS-file, and it usually
contains interface declarations for functions and values, datatype
declarations, type definitions, etc. The primary purpose of a SATS-file is
for allowing its content to be shared among various other ATS files, either
static or dynamic.\

")
")
#langja("
#para("\

ATS のファイル名の拡張子である #emphasis("sats") と #emphasis("dats") の最初の文字はそれぞれ、
単語 #emphasis("static") と #emphasis("dynamic") に由来しています。
例えば、#filename("foo.sats") は静的ファイルの名前で、#filename("bar.dats") は動的ファイルの名前です。
静的ファイルはしばしば SATS ファイルと呼ばれ、通常は関数, 値, データ型宣言, 型定義などのインターフェイス宣言を含んでいます。
SATS ファイルの主要な目的は、静的/動的にかかわらず別々のATSファイルでその中身を共用することにあります。\

")
")

#langeng("
#para("\

Let us now go through a simple example to see a typical use of static
files. Suppose that we want to implement the Ackermann's function, which is
famous for being recursive but not primitive recursive.  In a static file
named #filename("acker.sats") (or any other legal filename), we can declare
the following function interface:

#sats2xhtml('\
fun acker (m: int, n: int): int
')

Please note that one should not use the keyword #keycode("extern") when
declaring an interface for either a function or a value in a static file.
Then in a dynamic file named #filename("acker.dats") (or any other legal
filename), we can give the following implementation:

#dats2xhtml('\
staload "acker.sats"

implement
acker (m, n) =
  if m > 0 then
    if n > 0 then acker (m-1, acker (m, n-1))
    else acker (m-1, 1)
  else n+1
// end of [acker]
')

The keyword #stacode("staload") indicates to the ATS typechecker that the
file following it is to be statically loaded during
typechecking. Essentially, statically loading a file means to put the
content of the file in a namespace that can be accessed by the following
code.  It is important to note that static loading is different from plain
file inclusion. The latter is also supported in ATS, and it is a feature I
will cover elsewhere.\

")#comment("para")
")
#langja("
#para("\

静的ファイルの典型的な使い方を知るために、シンプルな例を見てみましょう。
まずアッカーマン関数を実装することになったとします。
この関数は原始再帰ではない再帰として有名です。
#filename("acker.sats") という名前の静的ファイルに、次の関数インターフェイスを宣言します:

#sats2xhtml('\
fun acker (m: int, n: int): int
')

静的ファイル内で関数や値のインターフェイス宣言をする際には、
#keycode("extern") キーワード を使わないことに注意してください。
#filename("acker.dats") という名前の動的ファイルに、次ような実装を書きます:

#dats2xhtml('\
staload "acker.sats"

implement
acker (m, n) =
  if m > 0 then
    if n > 0 then acker (m-1, acker (m, n-1))
    else acker (m-1, 1)
  else n+1
// end of [acker]
')

キーワード #stacode("staload") は指定したファイルを型検査中に静的にロードするよう、ATS の型検査器に指示します。
本質的にファイルの静的なロードは、
後続のコードがアクセスできるようにファイルの中身を名前空間に配置することです。
注目すべきなのは、静的なロードは単純なファイルの埋め込みとは異なるということです。
ATS では後者もまたサポートしています。その機能は別の章で解説します。\

")#comment("para")
")

#langeng("
#para("\

It is also possible to give the following implementation for the declared
function #dyncode("acker"):

#dats2xhtml('\
staload ACKER = "acker.sats"

implement $ACKER.acker
  (m, n) = acker (m, n) where {
  fun acker (m: int, n:int): int = 
    if m > 0 then
      if n > 0 then acker (m-1, acker (m, n-1))
      else acker (m-1, 1)
    else n+1
} // end of [$ACKER.acker]
')

In this case, the namespace for storing the content of the file
#filename("acker.sats") is given the name ACKER, and the prefix
#dyncode("$ACKER.") (the dollar sign followed by ACKER followed by the dot
symbol) must be attached to any name that refers an entity (a function, a
value, a datatype, a constructor (associated with a datatype), a type
definition, etc.) declared in #filename("acker.sats"). When there are many
static files to be loaded, it is often a good practice to assign names to
the namespaces holding these files so that the original source of each
declared entity can be readily tracked down.\

")#comment("para")
")
#langja("
#para("\

#dyncode("acker") 関数宣言に対して次のような実装をすることもできます:

#dats2xhtml('\
staload ACKER = "acker.sats"

implement $ACKER.acker
  (m, n) = acker (m, n) where {
  fun acker (m: int, n:int): int = 
    if m > 0 then
      if n > 0 then acker (m-1, acker (m, n-1))
      else acker (m-1, 1)
    else n+1
} // end of [$ACKER.acker]
')

この場合、ACKER という名前の名前空間が #filename("acker.sats") ファイルの中身を保持しています。
また接頭辞 #dyncode("$ACKER.") (ドル記号の後にACKERを、その後にドット記号です)
を #filename("acker.sats") で宣言されている関数, 値, データ型, コンストラクタ, 型宣言
などの名前に付記する必要があります。
多数の静的ファイルがロードされた時、それらのファイルの持つ名前空間に名前を割り当てるのは、
しばしば良い習慣です。
それぞれの要素が宣言されている元のソースコードをすぐに見つけ出せるからです。\

")#comment("para")
")

#langeng("
#para("\

In another file named #filename("test_acker.dats"), let us
write the following code:

#dats2xhtml('\
//
\#include
"share/atspre_staload.hats"
//
staload "acker.sats"
dynload "acker.dats"

implement
main0 () = () where {
//
// acker (3, 3) should return 61
//
  val () = assertloc (acker (3, 3) = 61)
} // end of [main0]
')

The keyword #dyncode("dynload") indicates to the ATS compiler to generate a
call to the initializing function associated with the file
#filename("acker.dats"). This is mandatory as an error would otherwise be
reported at link-time. Usually, calling the initializing function
associated with a dynamic file is necessary only if there is a value
implemented in the file. In this case, there is only a function implemented
in #filename("acker.dats"). If we include the following line somewhere
inside #filename("acker.dats"):

#dats2xhtml('\
\#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
')

then the line starting with the keyword #dyncode("dynload") in
#filename("test_acker.dats") is no longer needed. The function
#dyncode("assertloc") verifies at run-time that its argument evaluates to
the boolean value #dyncode("true"). In the case where the argument
evaluates to #dyncode("false"), the function call aborts and a message is
reported that contains the name of the file, which is
#filename("test_acker.dats") in this example, and the location at
which the source code of the call is found in the file. If this sounds a
bit confusing, please try to execute a program that contains a call to
#dyncode("assertloc") on #dyncode("false") and you will see clearly what
happens.\

")#comment("para")
")
#langja("
#para("\

別のファイル #filename("test_acker.dats") に次のコードを書いてみましょう:

#dats2xhtml('\
//
\#include
"share/atspre_staload.hats"
//
staload "acker.sats"
dynload "acker.dats"

implement
main0 () = () where {
//
// acker (3, 3) should return 61
//
  val () = assertloc (acker (3, 3) = 61)
} // end of [main0]
')

キーワード #dyncode("dynload") は
#filename("acker.dats") ファイルに関連する初期化関数呼び出しを生成するよう、ATS コンパイラに指示します。
これは必須で、さもないとリンク時にエラーが発生してしまいます。
通常、動的ファイルに関連するこの初期化関数は、そのファイルの中で値が実装されている時のみ必要になります。
この例では #filename("acker.dats") の中には関数の実装しかありません。
もし次の行を #filename("acker.dats") の中のどこかに書けば:

#dats2xhtml('\
\#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
')

#filename("test_acker.dats") 中の #dyncode("dynload") キーワード行はもはや不要です。
#dyncode("assertloc") 関数は、その引数を評価してブール値 #dyncode("true") になるか実行時に検証します。
この例では引数は #dyncode("false") に評価されるので、関数呼び出しは中断されてファイル名
(この例では #filename("test_acker.dats")) とそのファイルで呼び出したソースコードの位置を含むメッセージが表示されます。
もし少し混乱してしまったら #dyncode("false") に対して #dyncode("assertloc") を呼び出してみてください。
何が起きるのか明確になるでしょう。\

")#comment("para")
")

#langeng("
#para("\

The simplest way to compile the two files #filename("acker.dats") and
#filename("test_acker.dats") is to issue the following command-line:

<informalexample><programlisting>
<command>atscc</command> -o test_acker acker.dats test_acker.dats
</programlisting></informalexample>

The generated excutable #filename("test_acker") is in the current
working directory.  The compilation can also be performed separately as is
demonstrated below:

<informalexample><programlisting>
<command>atscc</command> -c acker.dats
<command>atscc</command> -c test_acker.dats
<command>atscc</command> -o test_acker acker_dats.o test_acker_dats.o
</programlisting></informalexample>

This style of separate compilation works particularly well when it is
employed by the <command>make</command> utility.\

")#comment("para")
")
#langja("
#para("\

次のコマンドラインを実行すれば、
2つのファイル #filename("acker.dats") と #filename("test_acker.dats") を簡単にコンパイルできます:

<informalexample><programlisting>
<command>atscc</command> -o test_acker acker.dats test_acker.dats
</programlisting></informalexample>

現在のワーキングディレクトリに実行可能ファイル #filename("test_acker") が生成されるはずです。
次のように分割コンパイルをすることもできます:

<informalexample><programlisting>
<command>atscc</command> -c acker.dats
<command>atscc</command> -c test_acker.dats
<command>atscc</command> -o test_acker acker_dats.o test_acker_dats.o
</programlisting></informalexample>

この分割コンパイルのスタイルは
<command>make</command> ユーティリティから呼び出す際に特に有用です。\

")#comment("para")
")

#langeng("
#para("\
If we want to, we can also merge #filename("acker.sats") and
#filename("acker.dats") into a single filename of the following content:

#dats2xhtml('\
extern
fun acker (m: int, m: int): int

implement
acker (m, n) =
  if m > 0 then
    if n > 0 then acker (m-1, acker (m, n-1))
    else acker (m-1, 1)
  else n+1
// end of [acker]
')

Suppose that this single file is given the name #filename("acker3.dats").
Then the testing code can be written as follows:

#dats2xhtml('\
//
\#include
"share/atspre_staload.hats"
//
staload "acker3.dats"
dynload "acker3.dats"

implement
main0 () = () where {
//
// acker (3, 3) should return 61
//
  val () = assertloc (acker (3, 3) = 61)
} // end of [main0]
')

Note that it is perfectly fine for a dynamic ATS file to be statically
loaded. Actually, a static ATS file is really just a special case of
dynamic ATS file in which there is no implementation (of either functions
or values).\

")
")
#langja("
#para("\
望むなら #filename("acker.sats") と #filename("acker.dats") を次のような1つのファイルにまとめることも可能です:

#dats2xhtml('\
extern
fun acker (m: int, m: int): int

implement
acker (m, n) =
  if m > 0 then
    if n > 0 then acker (m-1, acker (m, n-1))
    else acker (m-1, 1)
  else n+1
// end of [acker]
')

#filename("acker3.dats") の名前で上記のファイルを作ったとしましょう。
するとテストコードは次のように書けます:

#dats2xhtml('\
//
\#include
"share/atspre_staload.hats"
//
staload "acker3.dats"
dynload "acker3.dats"

implement
main0 () = () where {
//
// acker (3, 3) should return 61
//
  val () = assertloc (acker (3, 3) = 61)
} // end of [main0]
')

ATS の動的ファイルを静的ロードすることが正常であることに注意してください。
実際 ATS の静的ファイルは、関数や値の実装を含まないATSの動的ファイルの単なる特殊形です。\

")
")

</sect1><!--id="static_and_dynamic_ats_files"-->

<!-- ****** ****** -->

<sect1 id="generic_template_implementation">
#langeng("
<title>
Generic Template Implementation
</title>
")
#langja("
<title>
総称テンプレート実装
</title>
")

#langeng("
#para("\

Interfaces for function templates are mostly similar to those for
functions.  For example, the following syntax declares an interface in a
dynamic file for a function template of the name #dyncode("list0_fold_left"):

#atscode('\
extern
fun{
a:t0p}{b:t0p
} list0_fold_left
  (xs: list0 b, f: (a, b) -<cloref1> a, init: a): a
')

where #stacode("t0p") is a shorthand for #stacode("t@ype").\
")
")
#langja("
#para("\

関数テンプレートのインターフェイスは関数のインターフェイスによく似ています。
例えば、次の構文は動的ファイルにおいて
#dyncode("list0_fold_left") という名前の関数テンプレートのインターフェイスを宣言しています:

#atscode('\
extern
fun{
a:t0p}{b:t0p
} list0_fold_left
  (xs: list0 b, f: (a, b) -<cloref1> a, init: a): a
')

ここで #stacode("t0p") は #stacode("t@ype") の略記です。\
")
")

#langeng("
#para("\

If the same interface is declared in a static file, the keyword
#keycode("extern") should be dropped. Implementing an interface for a
function template is also mostly similar to implementing one for a
function. The above interface for #dyncode("list0_fold_left") is given an
implementation in the following code:

#dats2xhtml('\
implement{a}{b}
list0_fold_left
  (xs, f, init) = let
//
fun loop
(
  xs: list0 b, res: a
) : a =
(
  case+ xs of
  | list0_nil () => res
  | list0_cons (x, xs) => loop (xs, f (res, x))
) (* end of [loop] *)
//
in
  loop (xs, init)
end // end of [list0_fold_left]
')

Note that template parameters are required to appear immediately after the
keyword #dyncode("implement"), and they cannot be omitted.  Template
parameters can also be passed sequentially as is shown in the following
short example:

#dats2xhtml("\
extern
fun
{a,b:t0p}{c:t0p}
app2 (f: (a, b) -<cloref1> c, x: a, y: b): c

implement{a,b}{c} app2 (f, x, y) = f (x, y)
")

")#comment("para")
")
#langja("
#para("\

もし同じインターフェイスが静的ファイルの中で宣言されていたら、
#keycode("extern") キーワードは削除するべきです。
関数テンプレートのインターフェイスを実装することは関数のインターフェイスを実装することと、
やはりよく似ています。
上記の #dyncode("list0_fold_left") のインターフェイスは次のようなコードで実装することができます:

#dats2xhtml('\
implement{a}{b}
list0_fold_left
  (xs, f, init) = let
//
fun loop
(
  xs: list0 b, res: a
) : a =
(
  case+ xs of
  | list0_nil () => res
  | list0_cons (x, xs) => loop (xs, f (res, x))
) (* end of [loop] *)
//
in
  loop (xs, init)
end // end of [list0_fold_left]
')

#dyncode("implement") キーワードの直後に、テンプレート引数を書かなければならないことに注意してください。
この引数は省略できません。
次の短かい例に示すように、テンプレート引数は連続して渡すこともできます:

#dats2xhtml("\
extern
fun
{a,b:t0p}{c:t0p}
app2 (f: (a, b) -<cloref1> c, x: a, y: b): c

implement{a,b}{c} app2 (f, x, y) = f (x, y)
")

")#comment("para")
")

#langeng("
#para("\

The style of template implementation presented in this section is
referred to as generic template implementation. I will later present a
different style of template implementation, which is often referred to as
specific template implementation.\

")
")
#langja("
#para("\

この章で示したスタイルのテンプレート実装は総称テンプレート実装と呼ばれます。
後の章で特殊テンプレート実装と呼ばれる異なるスタイルのテンプレート実装を紹介します。\

")
")

</sect1><!--id="generic_template_implementation"-->

<!-- ****** ****** -->

<sect1 id="specific_template_implementation">
#langeng("
<title>
Specific Template Implementation
</title>
")
#langja("
<title>
特殊テンプレート実装
</title>
")

#langeng("
#para("\

Implementing an interface for a function template specifically means to
give an implementation for a fixed instance of the template. For instance,
the following interface is for a function template of the name
#dyncode("eq_elt_elt"):

#sats2xhtml("\
fun{a:t0p}
eq_elt_elt (x: a, y: a): bool // a generic equality
")

There is no meaningful generic implementation for #dyncode("eq_elt_elt") as
equality test for values of a type T depends on T.  Two specific template
implementations are given as follows for the instances
#dyncode("eq_elt_elt&lt;int&gt;") and #dyncode("eq_elt_elt&lt;double&gt;"):

#dats2xhtml("\
implement eq_elt_elt<int> (x, y) = g0int_eq (x, y)
implement eq_elt_elt<double> (x, y) = g0float_eq (x, y)
")

where #dyncode("eq_int_int") and #dyncode("eq_double_double") are equality
functions for values of the type #stacode("int") and #stacode("double"),
respectively. It is also possible to give the implementations as follows:

#dats2xhtml("\
implement eq_elt_elt<int> (x, y) = (x = y)
implement eq_elt_elt<double> (x, y) = (x = y)
")

This is allowed as the symbol #dyncode("=") is already overloaded with
#dyncode("g0int_eq") and #dyncode("g0float_eq") (in addition to many other
functions).\

")#comment("para")
")
#langja("
#para("\

関数テンプレートのインターフェイスを特殊実装するというのは、
そのテンプレートの固定のインスタンスに実装を与えることです。
例えば、次のインターフェイスは #dyncode("eq_elt_elt") という名前の関数テンプレートです:

#sats2xhtml("\
fun{a:t0p}
eq_elt_elt (x: a, y: a): bool // a generic equality
")

型 T の等値性検査は型 T に依存するので、#dyncode("eq_elt_elt") の意味のある総称的な実装は存在しません。

2つの特殊テンプレート実装である
インスタンス #dyncode("eq_elt_elt&lt;int&gt;") と #dyncode("eq_elt_elt&lt;double&gt;")
を次に示します:

#dats2xhtml("\
implement eq_elt_elt<int> (x, y) = g0int_eq (x, y)
implement eq_elt_elt<double> (x, y) = g0float_eq (x, y)
")

#dyncode("eq_int_int") と #dyncode("eq_double_double") はそれぞれ
#stacode("int") と #stacode("double") 型の値に対する等式関数です。
この実装は次のように書くこともできます:

#dats2xhtml("\
implement eq_elt_elt<int> (x, y) = (x = y)
implement eq_elt_elt<double> (x, y) = (x = y)
")

シンボル #dyncode("=") が #dyncode("g0int_eq") と #dyncode("g0float_eq") でオーバーロードされている
(その他多くの関数もオーバーロードしていています)ので、
このような実装が可能なのです。\

")#comment("para")
")

#langeng("
#para("\

Let us now see a typical use of specific template implementation.  The
following defined function template #dyncode("listeq") implements an
equality function on lists:

#dats2xhtml("\
fun{
a:t0p
} listeq
(
  xs: list0 a
, ys: list0 a
) : bool = (
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq_elt_elt<a> (x, y) then listeq (xs, ys) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
) (* end of [listeq] *)
")

Given two lists xs and ys, #dyncode("listeq") returns #dyncode("true") if
and only if xs and ys are of the same length and each element in xs equals
the corresponding one in ys (according to #dyncode("eq_elt_elt")).
Given a type T, it is clear that the instance
#dyncode("eq_elt_elt&lt;T&gt;") is needed if #dyncode("listeq") is called
on two lists of the type #stacode("list0(T)"). In other words, a specific
implementation for #dyncode("eq_elt_elt&lt;T&gt;") should be given if a
call to #dyncode("listeq") is to be made on two lists of the type
#stacode("list0(T)"). Note that the implementation for an instance of a
function template is required to be accessible from the file where the
instance is called.\

")

#comment("para")
")
#langja("
#para("\

ここで、特殊テンプレート実装の典型的な使い方を見てみましょう。
次に定義する関数テンプレート #dyncode("listeq") はリストの等式関数を実装しています:

#dats2xhtml("\
fun{
a:t0p
} listeq
(
  xs: list0 a
, ys: list0 a
) : bool = (
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq_elt_elt<a> (x, y) then listeq (xs, ys) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
) (* end of [listeq] *)
")

2つのリスト xs と ys が与えられた時、xs と ys
が同じ長さでなおかつそれぞれの要素が等しい (#dyncode("eq_elt_elt") を使って比較することになります)
なら #dyncode("listeq") は #dyncode("true") を返します。
型 T が与えられた時、#stacode("list0(T)") 型の2つのリストに対して
#dyncode("listeq") を使うために、#dyncode("eq_elt_elt&lt;T&gt;") のインスタンスが必要になることは明らかです。
別の言い型をすると、#stacode("list0(T)") 型の2つのリストに #dyncode("listeq")
を呼び出すのであれば、#dyncode("eq_elt_elt&lt;T&gt;") の特殊実装を与える必要があるのです。
関数テンプレートのインスタンス実装は、インスタンスを呼び出すファイルで有効でなければならないことに注意してください。\

")

#comment("para")
")

#langeng("
#para("\
As a comparison, the following defined function template
#dyncode("listeqf") also implements equality test on two given lists:

#dats2xhtml("\
fun{
a:t0p
} listeqf
(
  xs: list0 a
, ys: list0 a
, eq: (a, a) -> bool
) : bool = (
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq (x, y) then listeqf (xs, ys, eq) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
) (* end of [listeqf] *)
")

In this case, #dyncode("listeqf") takes an additional argument
#dyncode("eq") that tests whether two list elements are equal.  As
#dyncode("listeq") is a first-order function while #dyncode("listeqf") is a
higher-order one, it is likely for the former to be compiled into more
efficient object code. I would like to point out that the library of ATS
makes pervasive use of specifically implemented templates.

")#comment("para")
")
#langja("
#para("\
比較のために、与えられた2つのリストが等しいか判定する関数テンプレート
#dyncode("listeqf") を次に実装します:

#dats2xhtml("\
fun{
a:t0p
} listeqf
(
  xs: list0 a
, ys: list0 a
, eq: (a, a) -> bool
) : bool = (
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq (x, y) then listeqf (xs, ys, eq) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
) (* end of [listeqf] *)
")

この例では #dyncode("listeqf") には、リストの要素同士が等しいか判定するために引数
#dyncode("eq") が追加されています。
#dyncode("listeqf") は高階関数ですが #dyncode("listeq") は通常の関数なので、
前者はより効率的なオブジェクトコードにコンパイルされる可能性が高いことになります。
また、ATS のライブラリでは特殊実装のテンプレートを広範囲に使っています。

")#comment("para")
")

#langeng("
#para("\
Please find the code presented in this section plus some additional
testing code available #mycodelink("CHAP_MODULARITY/listeq.dats", "on-line").
")
")
#langja("
#para("\
この章で示したコードとテストのための追加コードは
#mycodelink("CHAP_MODULARITY/listeq.dats", "オンライン")
から入手できます。
")
")

</sect1><!--id="specific_template_implementation"-->

<!-- ****** ****** -->

<sect1 id="abstract_types">
#langeng("
<title>
Abstract Types
</title>
")
#langja("
<title>
抽象型
</title>
")

#langeng("
#para("\

The name <emphasis>abstract type</emphasis> refers to a type such
that values of the type are represented in a way that is completely hidden
from users of the type. This form of information-hiding attempts to ensure
that changes to the implementation of an abstract type cannot introduce
type-errors into well-typed code that makes use of the abstract type. In
ATS as well as in many other programming languages, abstract types play a
pivotal role in support of modular programming. I will present as follows a
concrete example to illustrate a typical use of abstract types in
practice.\

")
")
#langja("
#para("\

<emphasis>抽象型</emphasis> という名前は、型の利用者から完全に隠した型の値の表現方法に由来します。
このような情報の隠蔽は、抽象の実装に対する変更が抽象型を使っている型安全なコードで型エラーを引き起こさないよう保証する努力です。
多くの他のプログラミング言語と同様に、ATS
でも抽象型はモジュールプログラミングをサポートする重要な役割をはたします。
抽象型の実際的で典型的な使用の例を次に示します。\

")
")

#langeng("
#para("\

Suppose that we are to implement a package to provide various
funtionalities on finite sets of integers. We first declare an abstract
type #stacode("intset") as follows for values representing finite sets of
integers:

#sats2xhtml("\
abstype intset // a boxed abstract type
")

The keyword #stacode("abstype") indicates that the declared abstract type
#stacode("intset") is boxed, that is, the size of #stacode("intset") is the
same as that of a pointer.  There is a related keyword #stacode("abst@ype")
for introducing unboxed abstract types, which will be explained elsewhere.
We next present an interface for each function or value that we want to
implement in the package:

#sats2xhtml("\
// empty set
val intset_empty : intset

// singleton set of [x]
fun intset_make_sing (x: int): intset

// turning a list into a set
fun intset_make_list (xs: list0 int): intset

// turning a set into a list
fun intset_listize (xs: intset): list0 (int)

// membership test
fun intset_ismem (xs: intset, x: int): bool

// computing the size of [xs]
fun intset_size (xs: intset): size_t

// adding [x] into [xs]
fun intset_add (xs: intset, x: int): intset

// deleting [x] from [xs]
fun intset_del (xs: intset, x: int): intset

// union of [xs1] and [xs2]
fun intset_union (xs1: intset, xs2: intset): intset

// intersection of [xs1] and [xs2]
fun intset_inter (xs1: intset, xs2: intset): intset

// difference between [xs1] and [xs2]
fun intset_differ (xs1: intset, xs2: intset): intset
")

Let us now suppose that the declaration for #stacode("intset") and the
above interfaces are all stored in a file named #filename("intset.sats")
(or any other legal name for a static file).\

")#comment("para")
")
#langja("
#para("\

整数の有限集合に対する様々な機能を提供するパッケージを実装しているとしましょう。
まずはじめに、整数の有限集合を表現する値のために次のような抽象型 #stacode("intset") を宣言します:

#sats2xhtml("\
abstype intset // a boxed abstract type
")

キーワード #stacode("abstype") は宣言された抽象型 #stacode("intset") がボックス化されていることを指示します。
つまり #stacode("intset") のサイズはポインタのサイズと同じです。
関連したキーワード #stacode("abst@ype") はアンボックス化された抽象型の開始で、別の章で説明します。
パッケージで実装したいそれぞれの関数と値のインターフェイスを次に示します:

#sats2xhtml("\
// empty set
val intset_empty : intset

// singleton set of [x]
fun intset_make_sing (x: int): intset

// turning a list into a set
fun intset_make_list (xs: list0 int): intset

// turning a set into a list
fun intset_listize (xs: intset): list0 (int)

// membership test
fun intset_ismem (xs: intset, x: int): bool

// computing the size of [xs]
fun intset_size (xs: intset): size_t

// adding [x] into [xs]
fun intset_add (xs: intset, x: int): intset

// deleting [x] from [xs]
fun intset_del (xs: intset, x: int): intset

// union of [xs1] and [xs2]
fun intset_union (xs1: intset, xs2: intset): intset

// intersection of [xs1] and [xs2]
fun intset_inter (xs1: intset, xs2: intset): intset

// difference between [xs1] and [xs2]
fun intset_differ (xs1: intset, xs2: intset): intset
")

ここでは #stacode("intset") の宣言と上記のインターフェイスは全て #filename("intset.sats")
と名前のつけられたファイルに格納されているものとしましょう。\

")#comment("para")
")

#langeng("
#para("\

Usually, a realistic implementation for finite sets is based on some kind
of balanced trees (e.g., AVL trees, red-black trees). For the purpose of
illustration, I hereby give an implementation in which finite sets of
integers are represented as ordered lists of integers. This implementation
is contained in a file named #filename("intset.dats"), which is available
#mycodelink("CHAP_MODULARITY/intset.dats", "on-line").  In order to
construct values of an abstract type, we need to concretize it temporarily
by using the following form of declaration:

#dats2xhtml("\
assume intset = list0 (int)
")

where #stacode("assume") is a keyword. This assume-declaration equates
#stacode("intset") with the type #stacode("list0 (int)") and this equation is
valid until the end of the scope in which it is introduced. As the
assume-declaration is at the toplevel in #filename("intset.dats"),
the assumption that #stacode("intset") equals #stacode("list0 (int)") is valid
until the end of the file. There is a global restriction in ATS that allows
each abstract type to be concretized by an assume-declaration at most
once. More specifically, if an abstract type is concretized in two files
#filename("foo1.dats") and #filename("foo2.dats"), then
these two files cannot be used together to generate an executable.

The rest of implementation in #stacode("intset") is all standard.  For
instance, the union operation on two given sets of integers is implemented
as follows:

#dats2xhtml("\
implement
intset_union
  (xs1, xs2) = (
case+ (xs1, xs2) of
| (list0_cons (x1, xs11),
   list0_cons (x2, xs21)) =>
  let
    val sgn = compare (x1, x2)
  in
    case+ 0 of
    | _ when sgn < 0 =>
        list0_cons{int}(x1, intset_union (xs11, xs2))
    | _ when sgn > 0 =>
        list0_cons{int}(x2, intset_union (xs1, xs21))
    | _ (* sgn = 0 *) =>
        list0_cons{int}(x1, intset_union (xs11, xs21))
    // end of [case]
  end // end of [(cons, cons)]
| (list0_nil (), _) => xs2
| (_, list0_nil ()) => xs1
) (* end of [intset_union] *)
")

There is also some testing code available
#mycodelink("CHAP_MODULARITY/test_intset.dats", "on-line")
that makes use of some functions declared in
#filename("intset.sats").  Often testing code as such is
constructed immediately after the interfaces for various functions and
values in a package are declared. This allows these interfaces to be tried
before they are actually implemented so that potential flaws can be exposed
in a timely fashion.
")#comment("para")
")
#langja("
#para("\

通常、
有限集合の現実的な実装はなんらかの平衡木 (例えば AVL 木や赤黒木) を使います。
説明のために、ここでは整数の順序付きリストを使って表現される整数の有限集合を実装します。
この実装は #filename("intset.dats") という名前のファイルに保存されており、
このファイルは #mycodelink("CHAP_MODULARITY/intset.dats", "オンライン") から取得できます。
抽象型の値をコンストラクトするために、
次のような宣言を使って一時的にそれを具体化させる必要があります:

#dats2xhtml("\
assume intset = list0 (int)
")

#stacode("assume") キーワードを使いました。
この assume 宣言は
#stacode("intset") と型 #stacode("list0 (int)") を同一に扱うように指示します。
この結び付きは、それが導入されたスコープの終了まで有効です。
#filename("intset.dats") のトップレベルに assume 宣言があるので、#stacode("intset")
と #stacode("list0 (int)") が等価だという前提はファイル末尾まで有効です。
ATS には、それぞれの抽象型は最大でも1度までしか assume
宣言によって具体化することができないという、グローバルな制限があります。
より具体的には、もし抽象型が2つのファイル #filename("foo1.dats") と #filename("foo2.dats")
で具体化されていたら、これらの2つのファイルを一緒にして1つの実行ファイルで使うことはできません。

#stacode("intset") の残りの実装は全て一般的なものです。
例えば、2つの整数の有限集合の合併は次のような実装になります:

#dats2xhtml("\
implement
intset_union
  (xs1, xs2) = (
case+ (xs1, xs2) of
| (list0_cons (x1, xs11),
   list0_cons (x2, xs21)) =>
  let
    val sgn = compare (x1, x2)
  in
    case+ 0 of
    | _ when sgn < 0 =>
        list0_cons{int}(x1, intset_union (xs11, xs2))
    | _ when sgn > 0 =>
        list0_cons{int}(x2, intset_union (xs1, xs21))
    | _ (* sgn = 0 *) =>
        list0_cons{int}(x1, intset_union (xs11, xs21))
    // end of [case]
  end // end of [(cons, cons)]
| (list0_nil (), _) => xs2
| (_, list0_nil ()) => xs1
) (* end of [intset_union] *)
")

#filename("intset.sats") で宣言されている関数の使用に対するいらかのテストコードが
#mycodelink("CHAP_MODULARITY/test_intset.dats", "オンライン")
から入手できます。
しばしばこのようなテストコードを、
パッケージで宣言されている様々な関数と値のインターフェイスの直後でコンストラクトすることがあります。
これらのインターフェイスが実際に実装される前に試すことで、
欠陥をすぐに発見することができます。
")#comment("para")
")

</sect1><!--id="abstract_types"-->

<!-- ****** ****** -->

<sect1 id="example_a_package_for_rationals">
#langeng("
<title>
Example: A Package for Rationals
</title>
")
#langja("
<title>
例: 有理数パッケージ
</title>
")

#langeng("
#para("\

Let us represent a rational number as a pair of integers.  If we declare a
boxed abstract type #stacode("rat") for values representing rational
numbers, then each value of the type #stacode("rat") is stored in
heap-allocated memory, which can only be reclaimed through garbage
collection (GC). Instead, we follow an alternative approach by declaring
#stacode("rat") as an unboxed abstract type. Therefore, a declaration like
the following one is expected:

#sats2xhtml("\
abst@ype rat
")

The problem with this declaration is that it is too abstract. As there is
not information given about the size of the type #stacode("rat"), the ATS
compiler does not even know how much memory is needed for storing a value
of the type #stacode("rat"). However, the programmer should not assume that
such a form of declaration is useless. There are realistic circumstances
where a declaration of this form can be of great importance, and this is a
topic I will cover elsewhere. For now, let us declare an unboxed abstract
type as follows:

#sats2xhtml("\
abst@ype rat = (int, int)
")

This declaration simply informs the ATS compiler that the representation
for values of the type #stacode("rat") is the same as the one for values of
the type #stacode("(int, int)"). However, this information is not made
available to the typechecker of ATS. In particular, if a value of the type
#stacode("rat") is treated as a pair of integers in a program, then a
type-error will surely occur.  ")#comment("para")
")
#langja("
#para("\

有理数を整数の組で表現してみましょう。
もし有理数の値を表現するためにボックス化された抽象型 #stacode("rat") を宣言したら、
#stacode("rat") 型のそれぞれの値はヒープメモリに保存されます。
そのメモリはガベージコレクション (GC) によってのみ回収できます。
代わりに、 #stacode("rat") をアンボックス化された抽象型として宣言する別のアプローチを取ります。
そこで、次のような宣言になります:

#sats2xhtml("\
abst@ype rat
")

この宣言の問題はあまりにも抽象的すぎることです。
#stacode("rat") 型のサイズについて何の情報もないので、
ATSコンパイラは #stacode("rat") 型の値を保存するのに必要なメモリサイズを知ることさえできません。
けれども、プログラマにとってこのような宣言が役に立たないというわけではありません。
実際にはこのような宣言が非常に重要になってくる場面があります。
このトピックは別の章で解説しようと思います。
ここでは、アンボックス化された抽象型を次のように宣言してみましょう:

#sats2xhtml("\
abst@ype rat = (int, int)
")

この宣言は、#stacode("rat") 型の値の表現は #stacode("(int, int)")
型の値の表現と同じであることを、単純に ATS コンパイラに伝えています。
けれども、この情報は ATS の型検査器にとって有効ではありません。
とりわけ、プログラム中で #stacode("rat") 型の値が整数のペアとして扱われると、型エラーを引き起こします。
")#comment("para")
")

#langeng("
#para("\
The following code is contained in a file named
#filename("ratmod.sats"), which is available
#mycodelink("CHAP_MODULARITY/ratmod.sats", "on-line").

#sats2xhtml("\
exception Denominator
exception DivisionByZero

fun rat_make_int_int (p: int, q: int): rat

fun ratneg: (rat) -> rat // negation
fun ratadd: (rat, rat) -> rat // addition
fun ratsub: (rat, rat) -> rat // subtraction
fun ratmul: (rat, rat) -> rat // multiplication
fun ratdiv: (rat, rat) -> rat // division
")

The exception #dyncode("Denominator") is for reporting an erroneous
occasion where a rational number is to be formed with a denominator equal
to zero.  Given two integers representing the numerator and denominator of
a rational number, the function #dyncode("rat_make_int_int") returns a
value representing the rational number. The following implementation of
#dyncode("rat_make_int_int") can be found in a file named
#filename("ratmod.dats"), which is also available
#mycodelink("CHAP_MODULARITY/ratmod.dats", "on-line").

#dats2xhtml("\
implement
rat_make_int_int (p, q) = let
  fun make (
    p: int, q: int
  ) : rat = let
    val r = gcd (p, q) in (p / r, q / r)
  end // end of [make]
//
  val () = if q = 0 then $raise Denominator
//
in
  if q > 0 then make (p, q) else make (~p, ~q)
end // end of [rat_make_int_int]
")

Given a pair of integers p and q such that q is not zero, the function
#dyncode("rat_make_int_int") returns another pair of integers
p<subscript>1</subscript> and q<subscript>1</subscript> such that
q<subscript>1</subscript> is positive, p<subscript>1</subscript> and
q<subscript>1</subscript> are coprimes, that is, their greatest common
divisor is 1, and p<subscript>1</subscript>/q<subscript>1</subscript>
equals p/q. With #dyncode("rat_make_int_int"), it is straightforward to
implement as follows the arithmetic operations on rational numbers:

#dats2xhtml("\
implement ratneg (x) = (~x.0, x.1)

implement
ratadd (x, y) =
  rat_make_int_int (x.0 * y.1 + x.1 * y.0, x.1 * y.1)
// end of [ratadd]

implement
ratsub (x, y) =
  rat_make_int_int (x.0 * y.1 - x.1 * y.0, x.1 * y.1)
// end of [ratsub]

implement
ratmul (x, y) = rat_make_int_int (x.0 * y.0, x.1 * y.1)

implement
ratdiv (x, y) = (
if y.0 > 0
  then rat_make_int_int (x.0 * y.1, x.1 * y.0) else $raise DivisionByZero()
// end of [if]
) (* end of [ratdiv] *)
")

There is also some testing code available
#mycodelink("CHAP_MODULARITY/test_ratmod.dats", "on-line") that makes
use of some functions declared in #filename("ratmod.sats").

")#comment("para")
")
#langja("
#para("\
#mycodelink("CHAP_MODULARITY/ratmod.sats", "オンライン")
から取得できる次のコードは
#filename("ratmod.sats") という名前のファイルに保存されています。

#sats2xhtml("\
exception Denominator
exception DivisionByZero

fun rat_make_int_int (p: int, q: int): rat

fun ratneg: (rat) -> rat // negation
fun ratadd: (rat, rat) -> rat // addition
fun ratsub: (rat, rat) -> rat // subtraction
fun ratmul: (rat, rat) -> rat // multiplication
fun ratdiv: (rat, rat) -> rat // division
")

#dyncode("Denominator") 例外は分母がゼロの有理数を誤って生成してしまったことを示します。
有理数の分子と分母を表わす2つの整数が与えられた時、
関数 #dyncode("rat_make_int_int") は有理数を表わす値を返します。
#dyncode("rat_make_int_int") の次の実装は #filename("ratmod.dats") という名前のファイルにあり、
#mycodelink("CHAP_MODULARITY/ratmod.dats", "オンライン") からも取得できます。

#dats2xhtml("\
implement
rat_make_int_int (p, q) = let
  fun make (
    p: int, q: int
  ) : rat = let
    val r = gcd (p, q) in (p / r, q / r)
  end // end of [make]
//
  val () = if q = 0 then $raise Denominator
//
in
  if q > 0 then make (p, q) else make (~p, ~q)
end // end of [rat_make_int_int]
")

整数 p とゼロでない整数 q の組が与えられた時、
関数 #dyncode("rat_make_int_int") は別の整数の組
p<subscript>1</subscript> と q<subscript>1</subscript> を返します。
ここで、q <subscript>1</subscript> は正の数で、p<subscript>1</subscript> と q<subscript>1</subscript>
は互いに素です。
つまり、それらの最大公約数は1で、p<subscript>1</subscript>/q<subscript>1</subscript> は p/q に等しくなります。
#dyncode("rat_make_int_int") を使うと、有理数の算術演算は次のように素直に実装できます:

#dats2xhtml("\
implement ratneg (x) = (~x.0, x.1)

implement
ratadd (x, y) =
  rat_make_int_int (x.0 * y.1 + x.1 * y.0, x.1 * y.1)
// end of [ratadd]

implement
ratsub (x, y) =
  rat_make_int_int (x.0 * y.1 - x.1 * y.0, x.1 * y.1)
// end of [ratsub]

implement
ratmul (x, y) = rat_make_int_int (x.0 * y.0, x.1 * y.1)

implement
ratdiv (x, y) = (
if y.0 > 0
  then rat_make_int_int (x.0 * y.1, x.1 * y.0) else $raise DivisionByZero()
// end of [if]
) (* end of [ratdiv] *)
")

#filename("ratmod.sats") で宣言されている関数に対するいくらかのテストコードが
#mycodelink("CHAP_MODULARITY/test_ratmod.dats", "オンライン")
から入手できます。

")#comment("para")
")

</sect1><!--id="example_a_package_for_rationals"-->

<!-- ****** ****** -->

<sect1 id="example_a_functorial_package_for_rationals">
#langeng("
<title>
Example: A Functorial Package for Rationals
</title>
")
#langja("
<title>
例: ファンクタを用いた有理数パッケージ
</title>
")

#langeng("
#para("\

The previous package for rational numbers contains a serious limitation:
The type for the integers employed in the representation of rational
numbers is fixed to be #stacode("int"). If we ever want to represent
rational numbers based on integers of a different type (for instance,
#stacode("lint") for long integers or #stacode("llint") for long long
integers), then we need to implement another package for rationals based on
such integers. It is clearly advantageous to avoid this style of
programming as it involves code duplication to a great extent.  ")
")
#langja("
#para("\

前の有理数パッケージには重大な制約があります:
有理数を表現するのに使う整数の型が #stacode("int") に固定されてしまっていることです。
もし異なる型の整数
(例えば long int である #stacode("lint") や long long int である #stacode("llint"))
を使って有理数を表現したいのであれば、そのような整数を使った別の有理数パッケージを実装する必要があります。
コード重複をともなうこのようなプログラミングスタイルを回避することは明らかに好都合でしょう。
")
")

#langeng("
#para("\

The approach I employ in this section to implement a package for rational
numbers that can address the aforementioned limitation follows the idea of
functors in the programming language Standard ML (SML). Let us first
introduce a type definition as follows:

#sats2xhtml("\
typedef
intmod (a:t@ype) = '{
  ofint= int -> a
, fprint= (FILEref, a) -> void
, neg= (a) -> a // negation
, add= (a, a) -> a // addition
, sub= (a, a) -> a // subtraction
, mul= (a, a) -> a // multiplication
, div= (a, a) -> a // division
, mod= (a, a) -> a // modulo operation
, cmp= (a, a) -> int // comparison
} // end of [intmod]
")

Given a type T, #stacode("intmod(T)") is a boxed record type in which each
field is a function type. A value of the type #stacode("intmod(T)") is
supposed to represent a module of integer operations on integers
represented by values of the type T. Similarly, let us introduce another
type definition as follows:

#sats2xhtml("\
abst@ype rat(a:t@ype) = (a, a)

typedef
ratmod (a:t@ype) = '{
  make= (a, a) -<cloref1> rat a
, fprint= (FILEref, rat a) -<cloref1> void
, numer= rat a -> a // numerator
, denom= rat a -> a // denominator
, neg= (rat a) -<cloref1> rat a // negation
, add= (rat a, rat a) -<cloref1> rat a // addition
, sub= (rat a, rat a) -<cloref1> rat a // subtraction
, mul= (rat a, rat a) -<cloref1> rat a // multiplication
, div= (rat a, rat a) -<cloref1> rat a // division
, cmp= (rat a, rat a) -<cloref1> int // comparison
} // end of [ratmod]
")

Given a type T, a value of the type #stacode("ratmod(T)") is supposed to
represent a module of rational operations on rationals represented by
values of the type #stacode("rat(T)"). The function we need to implement can
now be given the following interface:

#sats2xhtml("\
fun{a:t@ype}
ratmod_make_intmod (int: intmod a): ratmod a
")

If applied to a given module of integer operations,
#dyncode("ratmod_make_intmod") returns a module of rational operations such
that the integers in the former and the latter modules have the same
representation. Therefore, #dyncode("ratmod_make_intmod") behaves like a
functor in SML.  In the following code, let us implement two modules
#dyncode("ratmod_int") and #dyncode("ratmod_dbl") of rational operations in
which integers are represented as values of the types #stacode("int") and
#stacode("double"), respectively:

#dats2xhtml('\
staload M = "libc/SATS/math.sats"

val ratmod_int = let
//
val intmod_int = \'{
  ofint= lam (i) => i
, fprint= lam (out, x) => $extfcall (void, "fprintf", out, "%i", x)
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => x / y
, mod= lam (x, y) => op mod (x, y)
, cmp= lam (x, y) => compare (x, y)
} : intmod (int) // end of [val]
//
in
  ratmod_make_intmod<int> (intmod_int)
end // end of [val]

val ratmod_dbl = let
//
val intmod_dbl = \'{
  ofint= lam (i) => g0i2f(i)
, fprint= lam (out, x) => $extfcall (void, "fprintf", out, "%0.f", x)
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => $M.trunc (x / y) // truncation
, mod= lam (x, y) => $M.fmod (x, y)
, cmp= lam (x, y) => compare (x, y)
} : intmod (double) // end of [val]
//
in
  ratmod_make_intmod<double> (intmod_dbl)
end // end of [ratmod_dbl]
')

An implementation of the function #dyncode("ratmod_make_intmod") is
available #mycodelink("CHAP_MODULARITY/ratfun.dats", "on-line") and there
is some related testing code available
#mycodelink("CHAP_MODULARITY/test_ratfun.dats", "on-line") as well.\

")#comment("para")
")
#langja("
#para("\

前述の制限を対処できるような有理数パッケージを実装するためにこの章で使うアプローチは、
プログラミング言語 Standard ML (SML) のファンクタのアイデアにもとづいています。
はじめに次のような型を定義しましょう:

#sats2xhtml("\
typedef
intmod (a:t@ype) = '{
  ofint= int -> a
, fprint= (FILEref, a) -> void
, neg= (a) -> a // negation
, add= (a, a) -> a // addition
, sub= (a, a) -> a // subtraction
, mul= (a, a) -> a // multiplication
, div= (a, a) -> a // division
, mod= (a, a) -> a // modulo operation
, cmp= (a, a) -> int // comparison
} // end of [intmod]
")

型 T が与えられた時、#stacode("intmod(T)")
はそれぞれのフィールドが関数型であるボックス化レコード型です。
#stacode("intmod(T)") 型の値は、型 T の値で表現される整数に対する整数演算のモジュールを表現していると見なすことができます。
同様に、次のような別の型を定義してみましょう:

#sats2xhtml("\
abst@ype rat (a:t@ype) = (a, a)

typedef
ratmod (a:t@ype) = '{
  make= (a, a) -<cloref1> rat a
, fprint= (FILEref, rat a) -<cloref1> void
, numer= rat a -> a // numerator
, denom= rat a -> a // denominator
, neg= (rat a) -<cloref1> rat a // negation
, add= (rat a, rat a) -<cloref1> rat a // addition
, sub= (rat a, rat a) -<cloref1> rat a // subtraction
, mul= (rat a, rat a) -<cloref1> rat a // multiplication
, div= (rat a, rat a) -<cloref1> rat a // division
, cmp= (rat a, rat a) -<cloref1> int // comparison
} // end of [ratmod]
")

型 T が与えられた時、 #stacode("ratmod(T)") 型の値は
#stacode("rat(T)") 型の値で表現される有理数に対する有理数演算のモジュールを表現していると見なすことができます。
ここで実装したいこの関数は次のインターフェイスを持ちます:

#sats2xhtml("\
fun{a:t@ype}
ratmod_make_intmod (int: intmod a): ratmod a
")

与えられた整数演算のモジュールに適用すると、
#dyncode("ratmod_make_intmod") は有理数演算のモジュールを返します。
前者と後者のモジュールで使っている整数は同じ表現を持ちます。
そのため #dyncode("ratmod_make_intmod") は SML のファンクタのような振る舞いをします。
次のコードで、2つの有理数演算のモジュール #dyncode("ratmod_int") と #dyncode("ratmod_dbl") を実装しましょう。
中身の整数として #stacode("int") 型の値と #stacode("double") 型の値をそれぞれ使用しています:

#dats2xhtml('\
staload M = "libc/SATS/math.sats"

val ratmod_int = let
//
val intmod_int = \'{
  ofint= lam (i) => i
, fprint= lam (out, x) => $extfcall (void, "fprintf", out, "%i", x)
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => x / y
, mod= lam (x, y) => op mod (x, y)
, cmp= lam (x, y) => compare (x, y)
} : intmod (int) // end of [val]
//
in
  ratmod_make_intmod<int> (intmod_int)
end // end of [val]

val ratmod_dbl = let
//
val intmod_dbl = \'{
  ofint= lam (i) => g0i2f(i)
, fprint= lam (out, x) => $extfcall (void, "fprintf", out, "%0.f", x)
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => $M.trunc (x / y) // truncation
, mod= lam (x, y) => $M.fmod (x, y)
, cmp= lam (x, y) => compare (x, y)
} : intmod (double) // end of [val]
//
in
  ratmod_make_intmod<double> (intmod_dbl)
end // end of [ratmod_dbl]
')

#dyncode("ratmod_make_intmod") 関数の実装は #mycodelink("CHAP_MODULARITY/ratfun.dats", "オンライン")
から入手できます。
また関連したテストコードも #mycodelink("CHAP_MODULARITY/test_ratfun.dats", "オンライン") から入手できます。\

")#comment("para")
")

</sect1><!--id="example_a_functorial_package_for_rationals"-->

</chapter><!--id="modularity"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
