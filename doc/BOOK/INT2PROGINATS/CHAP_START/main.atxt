%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="preparation_for_starting"
>
#langeng("
#title("Preparation for Starting")
")
#langja("
#title("はじめる前に")
")

#langeng("
#para("\

It is likely that you want to write programs in the programming language
you are learning.  You may also want to try some of the examples included
in this book and see what really happens. So I will first show you how to
write in ATS a single-file program, that is, a program contained in a
single file, and compile it and then execute it.\

")
")
#langja("
#para("\

おそらく、あなたはプログラミング言語を学習する際に何かプログラムを書きたくなるでしょう。
また、この本の見本のいくつかを試して、実際に起きることを目にしたいでしょう。
そこで、はじめにたった1つのファイルで構成されたプログラムを ATS で書く方法を説明します。
その後、コンパイル方法と実行手順を説明します。\

")
")

<sect1
id="a_running_program"
>
#langeng("
#title("A Running Program")
")
#langja("
#title("実行可能なプログラム")
")

#langeng("
#para('\
The following example is a program in ATS that prints out (onto the
console) the string "Hello, world!" plus a newline before it terminates:

#dats2xhtml('\
//
val _ = print ("Hello, world!\\\n")
//
implement main0 () = () // a dummy for [main]
//
')

The keyword #dyncode("val") initiates a binding between the variable
#dyncode("_") (underscore) and the function call #dyncode('print ("Hello,
world!\\\n")').  However, this binding is never used after it is
introduced; its sole purpose is for the call to the #dyncode("print")
function to get evaluated.  ')#comment("para")
")
#langja("
#para('\

次の例は "Hello, world!" という文字列と改行をコンソールに印字するプログラムです。

#dats2xhtml('\
//
val _ = print ("Hello, world!\\\n")
//
implement main0 () = () // a dummy for [main]
//
')

#dyncode("val") キーワードは変数 #dyncode("_") (アンダースコア) に、関数呼び出し
#dyncode('print ("Hello, world!\\\n")') を束縛します。
この束縛は作られた後に使われるのではありません。
評価された時に #dyncode("print") 関数を呼び出すことが唯一の目的です。  ')#comment("para")
")

#langeng("
#para("\

The function #dyncode("main0") is a slight variant of another function
named #dyncode("main"), which is of certain special meaning in ATS. For a
programmer who knows the C or Java programming language, I simply point out
that the role of #dyncode("main") is essentially the same as its
counterpart of the same name in C or Java.  The keyword
#dyncode("implement") initiates the implementation of a function whose
interface has already been declared elsewhere. Following is the declared
interface for #dyncode("main0") in ATS:

#sats2xhtml("\
fun main0 (): void
")

which indicates that #dyncode("main0") is a nullary function, that is, a
function taking no arguments, and it returns no value (or it returns the
void value). The double slash symbol (#dyncode("//")) initiates a comment
that terminates at the end of the current line.\

")#comment("para")
")
#langja("
#para("\

#dyncode("main0") 関数は ATS において特殊な意味を持っていて #dyncode("main") 関数の変形です。
C や Java 言語を知っているプログラマにとっては、
#dyncode("main") の役目は C や Java における同じ名前の関数と本質的に同等であると言えるでしょう。
#dyncode("implement") キーワードは既に別の箇所でインターフェイスが宣言された関数の実装を作成します。
次に示す ATS のソースコードは #dyncode("main0") に対するインターフェイスの宣言です。

#sats2xhtml("\
fun main0 (): void
")

このコードは #dyncode("main0") が引数を取らず返値もない関数であることを示しています。
返値がない、ということは void 値を返すと言いかえることもできます。
#dyncode("//") から行末まではコメントです。 \

")#comment("para")
")

#langeng("
#para("\
Suppose that you have already installed the ATS programming language
system. You can issue the following command-line to generate an executable
named <filename>hello</filename> in the current working directory:

<informalexample><programlisting>
<command>atscc</command> -o hello hello.dats
</programlisting></informalexample>

where <filename>hello.dats</filename> refers to a file containing the above
program.  The command #command("atscc") is essentially a convenience
wrapper around the command #command("atsopt"), which triggers the process
of typechecking and compiling ATS programs. Note that #command("atscc") and
#command("atsopt") may actually be given the names #command("patscc") and
#command("patsopt"), respectively, in certain installations of ATS.  The filename
extension #emphasis(".dats") should not be altered as it has already been
assigned a special meaning that the compilation command #command("atscc")
recognizes. Another special filename extension is #emphasis(".sats"), which
we will soon encounter.\

")#comment("para")
")
#langja("
#para("\
ATS プログラミング言語は既にインストール済みであると仮定します。
次のコマンドを実行すれば作業中ディレクトリに <filename>hello</filename>
という名前で実行ファイルが作られます。

<informalexample><programlisting>
<command>atscc</command> -o hello hello.dats
</programlisting></informalexample>

<filename>hello.dats</filename> は先程のプログラムを含んだファイルです。
#command("atscc") コマンドは #command("atsopt") コマンドの便利なラッパーです。
#command("atsopt") は ATS プログラムの型検査とコンパイルを実行します。
ATS のインストール時の設定によっては、
#command("atscc") と #command("atsopt") はそれぞれ実際には
#command("patscc") と #command("patsopt") という名前が付けられているかもしれないことに注意してください。
#emphasis(".dats") という拡張子は #command("atscc")
コマンドが特別な意味に解釈するため変更してはいけません。
別の特別な意味を持つ拡張子として #emphasis(".sats") があり、この後すぐに出会うことになります。\

")#comment("para")
")

</sect1><!--id="a_running_example"-->

<!-- ****** ****** -->

<sect1
id="a_template_for_single-file_programs"
>

#langeng("
#title("A Template for Single-File Programs")
")
#langja("
#title("1つのファイルで構成されたプログラムのひな形")
")

#langeng("
#para("
The following code template, which is available
#mycodelink("CHAP_START/mytest.dats", "on-line"), is designed for constructing a
single-file program in ATS:

#dats2xhtml('\
(*
**
** A template for single-file ATS programs
**
*)

(* ****** ****** *)
//
\#include "share/atspre_define.hats"
\#include "share/atspre_staload.hats"
//
(* ****** ****** *)

//
// please write you program in this section
//

(* ****** ****** *)

implement main0 () = () // a dummy implementation for [main]

')#comment("atscode")

The line starting with the keyword #dyncode("\#include") enables the ATS
compiler #command("atsopt") to gain access to certain external library
packages and the definitions of various library functions. I will cover
elsewhere in the book the topic on making use of library code in ATS.\

")#comment("para")
")
#langja("
#para("
次に示すコードは1つのファイルで構成された ATS プログラムのひな形です。
またこのひな形は
#mycodelink("CHAP_START/mytest.dats", "オンライン")
からも入手できます。

#dats2xhtml('\
(*
**
** A template for single-file ATS programs
**
*)

(* ****** ****** *)
//
\#include "share/atspre_define.hats"
\#include "share/atspre_staload.hats"
//
(* ****** ****** *)

//
// please write you program in this section
//

(* ****** ****** *)

implement main0 () = () // a dummy implementation for [main]

')#comment("atscode")

#dyncode("\#include") キーワードではじまる行は ATS コンパイラ #command("atsopt") に対して、
指定した外部ライブラリパッケージと様々なライブラリ関数へのアクセスを可能にします。
ATS のライブラリ使用方法はこの本の別の章で説明します。 \

")#comment("para")
")

</sect1><!--id="a_template_for_single_file_programs"-->

<!-- ****** ****** -->

<sect1
id="a_makefile_template"
>
#langeng("
#title("A Makefile Template")
")
#langja("
#title("Makefileのひな形")
")

#langeng("
#para('\

The following Makefile template, which is available
#mycodelink("CHAP_START/Makefile_template", "on-line"), is provided to help
you construct your own Makefile for compiling ATS programs. If you are not
familiar with the #command("make") utility, you could readily find plenty
resources on-line to help yourself learn it.

#atscode('\
\#\#\#\#\#\#
\#
\# Note that
\# certain installations require the following changes:
\#
\# atscc -> patscc
\# atsopt -> patsopt
\# ATSHOME -> PATSHOME
\#
\#\#\#\#\#\#

ATSHOMEQ="$(ATSHOME)"

\#\#\#\#\#\#

ATSCC=$(ATSHOMEQ)/bin/atscc
ATSOPT=$(ATSHOMEQ)/bin/atsopt

\#\#\#\#\#\#

\#
\# HX: Please uncomment the one you want, or skip it entirely
\#
ATSCCFLAGS=
\#ATSCCFLAGS=-O2
\#
\# \'-flto\' enables link-time optimization such as inlining lib functions
\#
\#ATSCCFLAGS=-O2 -flto
\#

\#\#\#\#\#\#

cleanall::

\#\#\#\#\#\#

\#
\# Please uncomment the following three lines and replace the name [foo]
\# with the name of the file you want to compile
\#

\# foo: foo.dats ; \\\\
\#   $(ATSCC) $(ATSCCFLAGS) -o $@ $< || echo $@ ": ERROR!!!"
\# cleanall:: ; $(RMF) foo

\#\#\#\#\#\#

\#
\# You may find these rules useful
\#

\# %_sats.o: %.sats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"
\# %_dats.o: %.dats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"

\#\#\#\#\#\#

RMF=rm -f

\#\#\#\#\#\#

clean:: ; $(RMF) *~
clean:: ; $(RMF) *_?ats.o
clean:: ; $(RMF) *_?ats.c

cleanall:: clean

\#\#\#\#\#\# end of [Makefile] \#\#\#\#\#\#
')#comment("atscode")
')#comment("para")
")
#langja("
#para('\

次に示す Makefile のひな形は ATS プログラムをコンパイルする独自の Makefile を作るのに役立つでしょう。
またこのひな形は #mycodelink("CHAP_START/Makefile_template", "オンライン") から入手できます。
あなたが #command("make") ユーティリティに習熟していなかったとしても、
オンラインからその学習のための情報を数多く見つけられるでしょう。

#atscode('\
\#\#\#\#\#\#
\#
\# Note that
\# certain installations require the following changes:
\#
\# atscc -> patscc
\# atsopt -> patsopt
\# ATSHOME -> PATSHOME
\#
\#\#\#\#\#\#

ATSHOMEQ="$(ATSHOME)"

\#\#\#\#\#\#

ATSCC=$(ATSHOMEQ)/bin/atscc
ATSOPT=$(ATSHOMEQ)/bin/atsopt

\#\#\#\#\#\#

\#
\# HX: Please uncomment the one you want, or skip it entirely
\#
ATSCCFLAGS=
\#ATSCCFLAGS=-O2
\#
\# \'-flto\' enables link-time optimization such as inlining lib functions
\#
\#ATSCCFLAGS=-O2 -flto
\#

\#\#\#\#\#\#

cleanall::

\#\#\#\#\#\#

\#
\# Please uncomment the following three lines and replace the name [foo]
\# with the name of the file you want to compile
\#

\# foo: foo.dats ; \\\\
\#   $(ATSCC) $(ATSCCFLAGS) -o $@ $< || echo $@ ": ERROR!!!"
\# cleanall:: ; $(RMF) foo

\#\#\#\#\#\#

\#
\# You may find these rules useful
\#

\# %_sats.o: %.sats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"
\# %_dats.o: %.dats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"

\#\#\#\#\#\#

RMF=rm -f

\#\#\#\#\#\#

clean:: ; $(RMF) *~
clean:: ; $(RMF) *_?ats.o
clean:: ; $(RMF) *_?ats.c

cleanall:: clean

\#\#\#\#\#\# end of [Makefile] \#\#\#\#\#\#
')#comment("atscode")
')#comment("para")
")

</sect1><!--id="a_makefile_template"-->

</chapter><!--"preparation_for_starting"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
