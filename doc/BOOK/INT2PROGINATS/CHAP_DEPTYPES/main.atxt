%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="introduction-to-dependent-types">
#langeng("
#title("Introduction to Dependent Types")
")
#langja("
#title("依存型入門")
")

#langeng("
#para("\

The types we have encountered so far in this book are often not adequately
precise in capturing programming invariants. For instance, if we assign the
type #stacode("int") to both of integers 0 and 1, then we simply cannot
distinguish 0 from 1 at the level of types. This means that 0 and 1 are
interchangeable as far as typechecking is concerned. In other words, we
cannot expect a program error to be caught during typechecking if the error
is caused by 0 being mistyped as 1. This form of imprecision in types can
become a crippling limitation if we ever want to build a type-based
specification language that is reasonably expressive for practical use.

")#comment("para")
")
#langja("
#para("\

この本でこれまで見てきた型は、しばしばプログラミングの不変条件を正確に表現していませんでした。
例えば型 #stacode("int") を整数0と1の両方に割り当てると、型のレベルでは0と1を単純に見分けることができません。
これは型検査の範囲では0と1が交換可能であることを意味しています。
別の言い方をすると、もし0であるべきところろ1とミスタイプして、
型検査中に捕捉すべきプログラムのエラーが起きても、型検査時に予測できません。
もし、実際の使用に耐える表現力豊かな型ベースの仕様記述言語を作ろうとしたなら、型におけるこの種の不正確さは不自由な制限になりえます。

")#comment("para")
")

#langeng("
#para("\

Please find #mycodelink("CHAP_DEPTYPES/", "on-line")
the code employed for illustration in this chapter plus some additional
code for testing.\

")#comment("para")
")
#langja("
#para("\

この章で紹介するコードとテストのための追加コードは
#mycodelink("CHAP_DEPTYPES/", "オンライン")
から入手できます。\

")#comment("para")
")

<!-- ****** ****** -->

<sect1
id="enhanced_expressiveness_for_specification">
#langeng("
#title("Enhanced Expressiveness for Specification")
")
#langja("
#title("仕様に対する表現力の強化")
")

#langeng("
#para("\

The primary purpose of introducing dependent types into the type system of
ATS is to greatly enhance the expressiveness of types so that they can be
employed to capture program invariants with much greater precision.
Generally speaking, dependent types are types dependent on values of
expressions. For instance, #stacode("bool") is a type constructor in ATS
that forms a type #stacode("bool(b)") when applied to a given boolean value
b. As this type can only be assigned to a boolean expression of the value
b, it is often referred to as a singleton type, that is, a type for exactly
one value. Clearly, the meaning of #stacode("bool(b)") depends on the
boolean value b.  Similarly, #stacode("int") is a type constructor in ATS
that forms a type #stacode("int(i)") when applied to a given integer
i. This type is also a singleton type as it can only be assigned to an
integer expression of the value i. Please note that both #stacode("bool")
and #stacode("int") are overloaded as they also refer to (non-dependent)
types.  I will gradually introduce many other examples of dependent types.
In particular, I will present a flexible means for the programmer to
declare dependent datatypes.\

")#comment("para")
")
#langja("
#para("\

ATS の型システムに依存型を導入する主要な目的は、プログラムの不変条件をより正確に捕捉できるように、型の表現力をより強化することです。
一般的には、依存型とは式の値に依存した型のことです。
例えば、#stacode("bool")
は与えられたブール値 b に適用されると型 #stacode("bool(b)") を作るようなATSの型コンストラクタです。
この型は値 b のブール式にのみ割り当てることができ、これはしばしばシグルトン型と呼ばれます。
つまりきっちり1つの値しか持たない型を意味します。
明らかに、#stacode("bool(b)") の意味はブール値 b に依存しています。
同様に、#stacode("int") はATSの型コンストラクタで、与えられた整数 i に適用されて型 #stacode("int(i)") を作ります。
また、この型は値 i の整数式にのみ割り当てることができるようなシングルトン型です。
#stacode("bool") と #stacode("int") は両方ともオーバーロードされて(依存型でない)型を参照していることに注意してください。
ここでは依存型の他の例を徐々に紹介します。
特に、依存データ型を宣言する柔軟な手法を紹介します。\

")#comment("para")
")

#langeng("
#para("\

The statics of ATS is a simply-typed language, and the types in this
language are called #emphasis("sorts") so as to avoid some
potential confusion (with the types for dynamic terms). The following four
listed sorts are commonly used:

<itemizedlist>

<listitem>
#para("
#emphasis("bool"): for static terms of boolean values
")
</listitem>

<listitem>
#para("
#emphasis("int"): for static terms of integer values
")
</listitem>

<listitem>
#para("
#emphasis("type"): for static terms representing boxed types (for dynamic terms)
")
</listitem>

<listitem>
#para("
#emphasis("t@ype"): for static terms representing unboxed types (for dynamic terms)
")
</listitem>

</itemizedlist>

The sorts #emphasis("bool") and #emphasis("int") are classified as
predicative sorts while the sorts #emphasis("type") and #emphasis("t@ype")
are impredicative. A boxed type is a static term of the sort
#emphasis("type") while an unboxed type is a static term of the sort
#emphasis("t@ype"). As types, #stacode("bool") and #stacode("int") are
static terms of the sort #emphasis("t@ype"). As type constructors,
#stacode("bool") and #stacode("int") are static terms of the sorts
(#emphasis("bool -&gt; t@ype")) and (#emphasis("int -&gt; t@ype")),
respectively.  Also note that the type constructor #stacode("list0") is of
the sort (#emphasis("t@ype -&gt; type")), which indicates that
#stacode("list0") forms a boxed type when applied to an unboxed one.  There
are a variety of built-in static functions in ATS for constructing static
terms of the sorts #emphasis("bool") and #emphasis("int"), and I list as
follows some of these functions together with the sorts assigned to them:

<itemizedlist>

<listitem>
#para("
~ (negation): #emphasis("(int) -&gt; int")
")
</listitem>

<listitem>
#para("
+ (addition): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
- (subtraction): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
* (multiplication): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
/ (division): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
> (greater-than): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
>= (greater-than-or-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
< (less-than): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
<= (less-than-or-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
== (equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
!= (not-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
<> (not-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
~ (boolean negation): #emphasis("(bool) -&gt; bool")
")
</listitem>

<listitem>
#para("
|| (disjunction): #emphasis("(bool, bool) -&gt; bool")
")
</listitem>

<listitem>
#para("
&& (conjunction) : #emphasis("(bool, bool) -&gt; bool")
")
</listitem>

</itemizedlist>

By combining a sort with one or more predicates, we can define a subset
sort. For instance, the following subset sorts are defined in the file
#myatscodelink("prelude/basics_pre.sats", "basics_pre.sats"), which is
automatically loaded by the ATS compiler:

#atscode("\
sortdef nat = {a: int | a >= 0} // for natural numbers
sortdef pos = {a: int | a >= 1}  // for positive numbers
sortdef neg = {a: int | a <= ~1}  // for negative numbers

sortdef nat1 = {a: nat | a < 1} // for 0
sortdef nat2 = {a: nat | a < 2} // for 0, 1
sortdef nat3 = {a: nat | a < 3} // for 0, 1, 2
sortdef nat4 = {a: nat | a < 4} // for 0, 1, 2, 3
")

Note that predicates can be sequenced together with the semicolon
symbol (;) to form a conjunction:

#atscode("\
sortdef nat2 = {a: int | 0 <= a; a < 2} // for 0, 1
sortdef nat3 = {a: int | 0 <= a; a < 3} // for 0, 1, 2
sortdef sgn = { i:int | ~1 <= i; i <= 1 } // for ~1, 0, 1
")

It is also possible to define the subset sorts #emphasis("nat2")
and #emphasis("nat3") as follows:

#atscode("\
sortdef nat2 = {a: int | a == 0 || a == 1} // for 0, 1
sortdef nat3 = {a: int | 0 <= a && a <= 2} // for 0, 1, 2
")

where #stacode("||") and #stacode("&&") stands for disjunction and
conjunction, respectively.

")#comment("para")
")
#langja("
#para("\

ATSの静的な部分は単純型付き言語で、(動的な項の型(type)と)混乱する可能性を回避するために、この言語の型は #emphasis("種(sort)") と呼ばれます。
次に挙げる4つの種は一般的に使用されます:

<itemizedlist>

<listitem>
#para("
#emphasis("bool"): ブール値の静的な項
")
</listitem>

<listitem>
#para("
#emphasis("int"): 整数値の静的な項
")
</listitem>

<listitem>
#para("
#emphasis("type"): 動的な項のボックス化型を表現する静的な項
")
</listitem>

<listitem>
#para("
#emphasis("t@ype"): 動的な項のアンボックス化型を表現する静的な項
")
</listitem>

</itemizedlist>

種 #emphasis("bool") と #emphasis("int") は述語種(predicative sorts)に、
種 #emphasis("type") と #emphasis("t@ype") は非述語種(impredicative sorts)に分類されます。
ボックス化型は種 #emphasis("type") の静的な項です。
アンボックス化型は種 #emphasis("t@ype") の静的な項です。
型としての #stacode("bool") と #stacode("int") は種 #emphasis("t@ype") の静的な項です。
型コンストラクタとしての #stacode("bool") と #stacode("int")
はそれぞれ種 (#emphasis("bool -&gt; t@ype")) と (#emphasis("int -&gt; t@ype")) の静的な項です。
型コンストラクタ #stacode("list0") もまた種 (#emphasis("t@ype -&gt; type")) であることに注意してください。
これは #stacode("list0") はアンボックス化型に適用するとボックス化型を作ることを示しています。
種 #emphasis("bool") と #emphasis("int") の静的な項をコンストラクトするために、
ATSにはビルトインの静的な関数が多数用意されています。
次にこのような関数のいくつかを割り当てられた種と一緒に挙げてみます:

<itemizedlist>

<listitem>
#para("
~ (negation): #emphasis("(int) -&gt; int")
")
</listitem>

<listitem>
#para("
+ (addition): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
- (subtraction): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
* (multiplication): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
/ (division): #emphasis("(int, int) -&gt; int")
")
</listitem>

<listitem>
#para("
> (greater-than): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
>= (greater-than-or-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
< (less-than): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
<= (less-than-or-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
== (equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
!= (not-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
<> (not-equal-to): #emphasis("(int, int) -&gt; bool")
")
</listitem>

<listitem>
#para("
~ (boolean negation): #emphasis("(bool) -&gt; bool")
")
</listitem>

<listitem>
#para("
|| (disjunction): #emphasis("(bool, bool) -&gt; bool")
")
</listitem>

<listitem>
#para("
&& (conjunction) : #emphasis("(bool, bool) -&gt; bool")
")
</listitem>

</itemizedlist>

種と1つ以上の述語を結合して、サブセット種を定義できます。
例えば、次のサブセット種が #myatscodelink("prelude/basics_pre.sats", "basics_pre.sats")
ファイルで定義されていて、ATSコンパイラが自動的にロードします:

#atscode("\
sortdef nat = {a: int | a >= 0} // for natural numbers
sortdef pos = {a: int | a >= 1}  // for positive numbers
sortdef neg = {a: int | a <= ~1}  // for negative numbers

sortdef nat1 = {a: nat | a < 1} // for 0
sortdef nat2 = {a: nat | a < 2} // for 0, 1
sortdef nat3 = {a: nat | a < 3} // for 0, 1, 2
sortdef nat4 = {a: nat | a < 4} // for 0, 1, 2, 3
")

セミコロン記号 (;) を使って述語群を結合することで、それらの並べることができることに注意してください:

#atscode("\
sortdef nat2 = {a: int | 0 <= a; a < 2} // for 0, 1
sortdef nat3 = {a: int | 0 <= a; a < 3} // for 0, 1, 2
sortdef sgn = { i:int | ~1 <= i; i <= 1 } // for ~1, 0, 1
")

次のようにサブセット種 #emphasis("nat2") と #emphasis("nat3") を定義することも可能です:

#atscode("\
sortdef nat2 = {a: int | a == 0 || a == 1} // for 0, 1
sortdef nat3 = {a: int | 0 <= a && a <= 2} // for 0, 1, 2
")

ここのとき #stacode("||") と #stacode("&&") はそれぞれ論理和と論理積を表わしています。

")#comment("para")
")

<!-- ****** ****** -->

#langeng("
#para("\
In order to unleash the expressiveness of dependent types, we need
to employ both universal and existential quantification over static
variables. For instance, the type #stacode("Int") in ATS is defined as
follows:

#atscode("\
typedef Int = [a:int] int (a) // for unspecified integers
")

where the syntax #stacode("[a:int]") means existential quantification over
a static variable #stacode("a") of the sort
#emphasis("int"). Essentially, this means that for each value of
the type #stacode("Int"), there exists an integer I such that the value is
of the type #stacode("int(I)"). Therefore, any value that can be given the
type #stacode("int") can also be given the type #stacode("Int"). A type
like #stacode("Int") is often referred to as an existentially quantified
type.  As another example, the type #stacode("Nat") in ATS is defined as
follows:

#atscode("\
typedef Nat = [a:int | a >= 0] int (a) // for natural numbers
")

where the syntax #stacode("[a:int | a >= 0]") means existential
quantification over a static variable #stacode("a") of the sort
#emphasis("int") that satisfies the constraint #stacode("a >= 0").
Therefore, each value of the type #stacode("Nat") can be assigned the type
#stacode("int(I)") for some integer I satisfying I >= 0. Given that
#stacode("int(I)") is a singleton type, the value equals I and is thus a
natural number. This means that the type #stacode("Nat") is for natural
numbers. The definition of #stacode("Nat") can also be given as follows:

#atscode("\
typedef Nat = [a:nat] int (a) // for natural numbers
")

where the syntax #stacode("[a:nat]") is just a form of syntactic sugar that
automatically expands into #stacode("[a:int | a >= 0]").\

")#comment("para")
")
#langja("
#para("\
依存型の表現力を解き放つために、静的な値の上に全称量化(universal quantification)と存在量化(existential quantification)を採用しましょう。
例えば、ATSの型 #stacode("Int") は次のように定義されています:

#atscode("\
typedef Int = [a:int] int (a) // for unspecified integers
")

ここでは、構文 #stacode("[a:int]") は、種 #emphasis("int") の静的な変数 #stacode("a")
の上の存在量化を意味しています。
これは本質的に、型 #stacode("Int") のそれぞれの値に対して、型 #stacode("int(I)")
の値になるような整数 I が存在することを意味します。
したがって、型 #stacode("int") が与えられるどのような値にも型 #stacode("Int") を与えることができます。
#stacode("Int") のような型はしばしば存在量化型(existentially quantified type)と呼ばれます。
別の例として、ATSの型 #stacode("Nat") は次のように定義されます:

#atscode("\
typedef Nat = [a:int | a >= 0] int (a) // for natural numbers
")

ここでは、構文 #stacode("[a:int | a >= 0]") は、不変条件 #stacode("a >= 0") を満たすような種
#emphasis("int") の静的な変数 #stacode("a") の上の存在量化を意味しています。
したがって、型 #stacode("Nat") のそれぞれの値には
I >= 0 を満たす整数 I を使った型 #stacode("int(I)") を割り当てることができます。
#stacode("int(I)") がシングルトン型として与えられると、その値は I に等しく、自然数になります。
つまり型 #stacode("Nat") は自然数を意味することになります。
#stacode("Nat") はまた次のようにも定義できます:

#atscode("\
typedef Nat = [a:nat] int (a) // for natural numbers
")

ここでは、構文 #stacode("[a:nat]") は単なる構文糖衣で、自動的に #stacode("[a:int | a >= 0]") に展開されます。\

")#comment("para")
")

#langeng("
#para("\
At this point, types have already become much more expressive. For
instance, we could only assign the type #stacode("(int) -&gt; int") to a
function that maps integers to natural numbers (e.g., the function that
computes the absolute value of a given integer), but we can now do better
by assigning it the type #stacode("(Int) -&gt; Nat"), which is clearly more
precise. In order to relate at the level of types the return value of a
function to its arguments, we need universal quantification. For instance,
the following universally quantified type is for a function that returns
the successor of its integer argument:

#atscode("\
{i:int} int (i) -> int (i+1)
")

where the syntax #stacode("{i:int}") means universal quantification over a
static variable #stacode("i") of the sort #stacode("int") and the scope
of this quantification is the function type following it.  One may think
that this function type is also a singleton type as the only function of
this type is the successor function on integers. Actually, there are
infinitely may partial functions that can be given this type as well.  For
the successor function on natural numbers, we can use the following type:

#atscode("\
{i:int | i >= 0} int (i) -> int (i+1)
")

where the syntax #stacode("{i:int | i >= 0}") means universal
quantification over a static variable #stacode("i") of the sort
#emphasis("int") that satisfies the constraint #stacode("i >= 0").
This type can also be written as follows:

#atscode("\
{i:nat} int (i) -> int (i+1)
")

where the syntax #stacode("{i:nat}") automatically expands into
#stacode("{i:int | i >= 0}").  I list as follows the interfaces for some
commonly used functions on integers:

#atscode("\
fun g1int_neg {i:int} (int i): int (~i) // negation
fun g1int_add {i,j:int} (int i, int j): int (i+j) // addition
fun g1int_sub {i,j:int} (int i, int j): int (i-j) // subtraction
fun g1int_mul {i,j:int} (int i, int j): int (i*j) // multiplication
fun g1int_div {i,j:int} (int i, int j): int (i/j) // division

fun g1int_lt {i,j:int} (int i, int j): bool (i < j) // less-than
fun g1int_lte {i,j:int} (int i, int j): bool (i <= j) // less-than-or-equal-to
fun g1int_gt {i,j:int} (int i, int j): bool (i > j) // greater-than
fun g1int_gte {i,j:int} (int i, int j): bool (i >= j) // greater-than-or-equal-to
fun g1int_eq {i,j:int} (int i, int j): bool (i == j) // equal-to
fun g1int_neq {i,j:int} (int i, int j): bool (i != j) // not-equal-to
")

These interfaces are all declared in the file
#myatscodelink("prelude/SATS/integer.sats", "integer.sats"), which is
automatically loaded by the ATS compiler. Note that
the functions listed here can all be referred to by their
standard names:
~ for g1int_neg,
+ for g1int_add,
- for g1int_sub,
* for g1int_mul,
/ for g1int_div,
&lt; for g1int_lt,
&lt;= for g1int_lte,
&gt; for g1int_gt,
&gt;= for g1int_gte,
= for g1int_eq,
!= for g1int_neq,
&lt;&gt; for g1int_neq (most of the time).

")#comment("para")
")
#langja("
#para("\
現時点で型の表現力はすでに強化されています。
例えば、型 #stacode("(int) -&gt; int") は整数を自然数に写像する関数に割り当てることができました
(例: 与えられた整数の絶対値を計算する関数)。
しかし、そのような関数には型 #stacode("(Int) -&gt; Nat") を割り当てた方がより良いでしょう。
その方がより明確になります。
型レベルで関数の返値とその引数を関連付けるためには、全称量化が必要になります。
例えば、次の全称量化型は、引数として渡された整数の次の数を返すような関数を表わしています:

#atscode("\
{i:int} int (i) -> int (i+1)
")

構文 #stacode("{i:int}") は種 #stacode("int") の静的な変数 #stacode("i") の上の全称量化を意味しています。
この全称量化のスコープは、それに続く関数型の中です。
読者は、この型の唯一の関数は整数の後者関数(successor function)であり、この関数型もまたシングルトン型であると考えるかもしれません。
実際には、この型を与えられる部分関数が無数に存在します。
自然数の後者関数に、次のような型を使うことができます:

#atscode("\
{i:int | i >= 0} int (i) -> int (i+1)
")

構文 #stacode("{i:int | i >= 0}") は不変条件 #stacode("i >= 0") を満たすような種 #emphasis("int")
の静的な変数 #stacode("i") の上の全称量化を意味しています。
この型はまた次のように書くこともできます:

#atscode("\
{i:nat} int (i) -> int (i+1)
")

構文 #stacode("{i:nat}") は自動的に #stacode("{i:int | i >= 0}") に展開されます。
整数に一般的に使われるいくつかのインターフェイスを次に挙げます:

#atscode("\
fun g1int_neg {i:int} (int i): int (~i) // negation
fun g1int_add {i,j:int} (int i, int j): int (i+j) // addition
fun g1int_sub {i,j:int} (int i, int j): int (i-j) // subtraction
fun g1int_mul {i,j:int} (int i, int j): int (i*j) // multiplication
fun g1int_div {i,j:int} (int i, int j): int (i/j) // division

fun g1int_lt {i,j:int} (int i, int j): bool (i < j) // less-than
fun g1int_lte {i,j:int} (int i, int j): bool (i <= j) // less-than-or-equal-to
fun g1int_gt {i,j:int} (int i, int j): bool (i > j) // greater-than
fun g1int_gte {i,j:int} (int i, int j): bool (i >= j) // greater-than-or-equal-to
fun g1int_eq {i,j:int} (int i, int j): bool (i == j) // equal-to
fun g1int_neq {i,j:int} (int i, int j): bool (i != j) // not-equal-to
")

これらのインターフェイスは全て #myatscodelink("prelude/SATS/integer.sats", "integer.sats")
ファイルで宣言されていて、ATS コンパイラが自動的にロードします。
ここで挙げた関数群は全てそれらの標準名で参照可能であることに注意してください:
ほとんどの場合、
~ は g1int_neg,
+ は g1int_add,
- は g1int_sub,
* は g1int_mul,
/ は g1int_div,
&lt; は g1int_lt,
&lt;= は g1int_lte,
&gt; は g1int_gt,
&gt;= は g1int_gte,
= は g1int_eq,
!= は g1int_neq,
&lt;&gt; は g1int_neq を参照しています。

")#comment("para")
")

#langeng("
#para("\

It is now a proper moment for me to raise an interesting question: What
does a dependently typed interface for the factorial function look like?
After seeing the above examples, it is only natural for one to expect
something along the following line of thought:

#atscode("\
fun g1int_fact {i:nat} (i: int i): int (fact (i))
")

where #emphasis("fact") is a static version of the factorial function. The
very problem with this solution is that a static function like
#emphasis("fact") cannot be defined in ATS.  The statics of ATS is a
simply-typed language that does not allow any recursive means to be
employed in the construction of static terms. This design is adopted
primarily to ensure that the equality on static terms can be decided based
on a practical algorithm. As typechecking involving dependent types
essentially turns into verifying whether a set of equalities (and some
built-in predicates) on static terms hold, such a design is of vital
importance to the goal of supporting practical programming with dependent
types.

In order to assign an interface to the factorial function that precisely
matches the definition of the function, we need to employ a mechanism in ATS
for combining programming with theorem-proving.  This is a topic I will
cover later.\

")#comment("para")
")
#langja("
#para("\

この興味深い質問を持ち出すには今が適切な時でしょう:
階乗関数の依存型インターフェイスはどのようになるでしょうか？
上記の例を見た後では、次の行のように考えるのが自然でしょう:

#atscode("\
fun g1int_fact {i:nat} (i: int i): int (fact (i))
")

このとき、#emphasis("fact") は階乗関数の静的なバージョンです。
この答には大きな問題があります。
#emphasis("fact") のような静的な関数を ATS では定義できないのです。
ATSの静的な部分は単純型付き言語であり、静的な項のコンストラクトにおいてどのような再帰的な意味も許されていません。
このデザインを採用しているのは、主に現実的なアルゴリズムをベースに静的な項の等価性を決定できるように保証するためです。
本質的に、依存型を伴う型検査は、静的な項における等価性(とビルトインの述語)の集合の検査に変化します。
そのようなデザインは、依存型を使った実際のプログラミングをサポートするためにきわめて重要です。

関数の定義に正確に一致する階乗関数にインターフェイスを割り当てるためには、ATS に定理証明を使ったプログラミングを採用する必要があります。
このトピックは後の章で取り上げます。\

")#comment("para")
")

</sect1><!--id="enhanced_expressiveness_for_specification"-->

<!-- ****** ****** -->

<sect1
id="constraint-solving_during_typechecking">
#langeng("
#title("Constraint-Solving during Typechecking")
")
#langja("
#title("型検査中での制約解決")
")

#langeng("
#para("\

Typechecking in ATS involves generating and solving constraints.
As an example, the code below implements the well-known factorial
function:

#atscode("\
fun
fact{n:nat}
  (x: int n): [r:nat] int r = if x > 0 then x * fact (x-1) else 1
// end of [fact]
")

In this implementation, the function #dyncode("fact") is assigned the
following type:

#atscode("\
{n:nat} int(n) -> [r:nat] int(r)
")

which means that #dyncode("fact") returns a natural number r when applied
to a natural number n. When the code is typechecked, the following
constraints need to be solved:

<itemizedlist>

<listitem>
#para("
For each natural number n, n &gt; 0 implies n - 1 &gt;= 0
")
</listitem>

<listitem>
#para("\
For each natural number n and each natural number r#sub("1"), n &gt; 0 implies n * r#sub("1")&gt;= 0
")
</listitem>

<listitem>
#para("
For each natural number n, 1 &gt;= 0 holds.
")
</listitem>

</itemizedlist>

The first constraint is generated due to the call #dyncode("fact(x-1)"),
which requires that #dyncode("x-1") be a natural number. The second
constraint is generated in order to verify that #dyncode("x * fact(x-1)")
is a natural number under the assumption that #dyncode("fact(x-1)") is a
natural number.  The third constraint is generated in order to verify that
#dyncode("1") is a natural number.  The first and the third constraints can
be readily solved by the constraint solver in ATS, which is based on the
Fourier-Motzkin variable elimination method. However, the second constraint
cannot be handled by the constraint solver as it is nonlinear: The
constraint cannot be turned into a linear integer programming problem due
to the occurrence of the nonlinear term (n*r#sub("1")).  While nonlinear
constraints cannot be handled automatically by the constraint solver in
ATS, the programmer can verify them by constructing proofs in ATS
explicitly. I will cover the issue of explicit proof construction in an
elaborated manner elsewhere.\

")#comment("para")
")
#langja("
#para("\

ATS における型検査は制約の生成と解決を引き起こします。
例えば、次のコードはよく知られた階乗関数を実装しています:

#atscode("\
fun
fact{n:nat}
  (x: int n): [r:nat] int r = if x > 0 then x * fact (x-1) else 1
// end of [fact]
")

この実装では、関数 #dyncode("fact") には次の型が割り当てられています:

#atscode("\
{n:nat} int(n) -> [r:nat] int(r)
")

これは、#dyncode("fact") は自然数 n に適用されると自然数 r を返すことを意味しています。
このコードが型検査されるとき、次の制約が解決される必要があります:

<itemizedlist>

<listitem>
#para("
それぞれの自然数 n について、n &gt; 0 が n - 1 &gt;= 0 の意味を含む
")
</listitem>

<listitem>
#para("\
それぞれの自然数 n とそれぞれの自然数 r#sub("1") について、n &gt; 0 が n * r#sub("1")&gt;= 0 の意味を含む
")
</listitem>

<listitem>
#para("
それぞれの自然数 n について、常に 1 &gt;= 0 である
")
</listitem>

</itemizedlist>

1番目の制約は、呼び出し #dyncode("fact(x-1)") によって生成されています。
#dyncode("x-1") が自然数であることが要求されているからです。
2番目の制約は、 #dyncode("fact(x-1)") が自然数であるという仮定の下で、#dyncode("x * fact(x-1)") が自然数であるかどうか検証することで生成されています。
3番目の制約は、#dyncode("1") が自然数であるかどうか検証することで生成されています。
1番目と3番目の制約は ATS の制約ソルバによってたやすく解決できます。
この手法は Fourier-Motzkin 変数消去法にもとづいています。
けれども、2番目の制約は線形ではないため制約ソルバで取り扱うことができません。
この制約は、線形でない項 (n*r#sub("1")) が存在するために、線形整数プログラミングの問題に変形できないのです。
ATS の制約ソルバは非線形の制約を自動的に取り扱うことはできませんが、証明を明示的に構築することでプログラマはそれらを検証することができます。
精巧にそして明示的に構築する証明については別の章で紹介します。\

")#comment("para")
")

#langeng("
#para("\

By default, the constraint-solver implemented for ATS/Postiats makes use of
the standard arithmetic of infinite precision.  For the sake of efficiency,
one may also choose to use machine-level arithmetic for solving integer
constraints. Due to potential arithmetic overflow, results returned by the
constraint-solver that uses machine-level arithmetic can be incorrect (but
we have so far never knowingly encountered such a situation in practice).\

")#comment("para")
")
#langja("
#para("\

初期設定では、ATS/Postiatsで実装されている制約ソルバは標準の任意精度演算を用いています。
効率の理由で、整数の制約の解決にマシンレベル演算を使うこともまた選択できます。
演算のオーバーフローの可能性があるため、
マシンレベル演算を使う制約ソルバが返す結果は不正確である可能性があります。
(しかし今までのところ実際にはそのような状況に遭遇したことはありません。)\

")#comment("para")
")

</sect1><!--id="constraint-solving_during_typechecking"-->

<!-- ****** ****** -->

<sect1
id="example_string_processing">
#langeng("
#title("Example: String Processing")
")
#langja("
#title("例: 文字列処理")
")

#langeng("
#para("\

A string in ATS is represented in the same manner as in C: It is a sequence
of adjacently stored non-null characters followed by the null character,
and its length is the number of non-null characters in the sequence.
Conventionally, such strings are often referred to as C-style strings,
which are notoriously difficult to be processed safely (as is clearly
indicated by so many bugs and breaches due to misusing such strings). As a
matter of fact, ATS is the first practical programming language that I know
can fully support safe processing of C-style strings. In ATS,
#stacode("string") is a type constructor of the sort #emphasis("(int) -&gt;
type").

Given a static integer n, #stacode("string(n)") is the type for strings of
length n. Note that #stacode("string") also refers to a non-dependent type
for strings of unspecified length, which is basically equivalent to the
type #stacode("String") defined as follows:

#atscode("\
typedef String = [n:nat] string (n)
")

The following two functions are commonly used for traversing a given string:

#atscode("\
fun string_is_atend
  {n:int}{i:nat | i <= n}
  (str: string (n), i: size_t (i)): bool (i==n)
// end of [string_is_atend]

fun string_isnot_atend
  {n:int}{i:nat | i <= n}
  (str: string (n), i: size_t (i)): bool (i < n)
// end of [string_isnot_atend]
")

Obviously, either one of them can be implemented based on the other. As an
example, the following code implements a function that computes the length
of a given string:

#atscode("\
fun
string_length
  {n:nat} (
  str: string (n)
) : size_t (n) = let
  fun loop {i:nat | i <= n} .<n-i>.
    (str: string n, i: size_t i): size_t (n) =
    if string_isnot_atend (str, i) then loop (str, succ(i)) else i
  // end of [loop]
in
  loop (str, i2sz(0))
end // end of [string_length]
")

Note that the function #dyncode("loop") in the body of
#dyncode("string_length") is defined tail-recursively, which can then be
translated into a genuine loop in the generated C code.  Although this
implementation of #dyncode("string_length") looks fairly plain right now,
it was actually an exciting achievement in the pursuit of practical
programming with dependent types.\

")#comment("para")
")
#langja("
#para("\

ATS の文字列はC言語と同じ方法で表現されています。
それは NULL 文字で終端される非 NULL 文字群が隣接して保存された列で、その長さはその列の中の非 NULL 文字の数です。
慣習的に、このような文字列をしばしばC言語スタイル文字列と呼びます。
また安全に処理することが困難であるために悪評が高いことでも知られています
(この文字列の誤用に起因する多くのバグと欠陥が明確に物語っています)。
実際のところ、私の知るかぎり ATS はC言語スタイルの文字列に対する安全な処理を完全にサポートするはじめての実用的なプログラミング言語です。
ATS では、 #stacode("string") は種 #emphasis("(int) -&gt; type") の型コンストラクタです。

静的な整数 n が与えられた時、 #stacode("string(n)") は長さ n の文字列の型です。
#stacode("string") は長さが指定されていない文字列の非依存型をも参照していることに注意してください。
この非依存型は次に定義する型 #stacode("String") と基本的に同等です:

#atscode("\
typedef String = [n:nat] string (n)
")

次の2つの関数は与えられた文字列を走査する用途に一般に使われます:

#atscode("\
fun string_is_atend
  {n:int}{i:nat | i <= n}
  (str: string (n), i: size_t (i)): bool (i==n)
// end of [string_is_atend]

fun string_isnot_atend
  {n:int}{i:nat | i <= n}
  (str: string (n), i: size_t (i)): bool (i < n)
// end of [string_isnot_atend]
")

明らかに、これら内のどちらかはもう一方を元にして実装することができます。
例として、次のコードは与えられた文字列の長さを算出する関数を実装しています:

#atscode("\
fun
string_length
  {n:nat} (
  str: string (n)
) : size_t (n) = let
  fun loop {i:nat | i <= n} .<n-i>.
    (str: string n, i: size_t i): size_t (n) =
    if string_isnot_atend (str, i) then loop (str, succ(i)) else i
  // end of [loop]
in
  loop (str, i2sz(0))
end // end of [string_length]
")

#dyncode("string_length") の本体中の関数 #dyncode("loop") は末尾再帰的な定義であることに注意してください。
これは生成されたC言語コード中では純粋なループになります。
現時点では #dyncode("string_length") のこの実装はかなり簡素に見えますが、依存型を使った実践的なプログラミングを突き詰めると実に面白い成果が得られます。\

")#comment("para")
")

#langeng("
#para("\

The following two functions are for accessing and updating characters
stored in strings:

#atscode("\
typedef charNZ = [c:int | c != '\\\\000'] char (c)

fun
string_get_at{n:int}
  {i:nat | i < n} (str: string n, i: size_t i): charNZ
overload [] with string_get_at

fun
string_set_char_at{n:int}
  {i:nat | i < n} (str: string n, i: size_t i, c: charNZ): void
overload [] with string_set_char_at
")

The type constructor #stacode("char") is of the sort
#emphasis("(char) -&gt; t@ype"), which takes a static
character c to form a singleton type #stacode("char(c)") for the only
character equal to c. Thus, the type #stacode("charNZ") is for all non-null
characters. The following defined function #dyncode("string_find")
traverses a string from left to right to check whether a given character
occurs in the string:

#atscode("\
//
typedef
sizeLt (n:int) = [i:nat | i < n] size_t (i)
//
fun
string_find{n:nat}
(
  str: string n, c0: char
) : Option (sizeLt n) = let
  typedef res = sizeLt (n)
  fun loop{i:nat | i <= n}
  (
    str: string n, c0: char, i: size_t i
  ) : Option (res) = let
    val isnot = string_isnot_atend (str, i)
  in
    if isnot then
      if (c0 = str[i]) then Some{res}(i) else loop (str, c0, succ(i))
    else None () // end of [if]
  end (* end of [loop] *)
in
  loop (str, c0, i2sz(0))
end // end of [string_find]
//
")

If the character #dyncode("c0") occurs in the string #dyncode("str"), then
a value of the form #dyncode("Some(i)") is returned, when i refers to the
position of the first occurrence of #dyncode("c0") (counting from left to
right). Otherwise, the value #dyncode("None()") is returned.\

")#comment("para")
")
#langja("
#para("\

次の2つの関数は文字列に保存されている文字へのアクセスと変更を表わします:

#atscode("\
typedef charNZ = [c:char | c <> '\\\\000'] char (c)

fun
string_get_at{n:int}
  {i:nat | i < n} (str: string n, i: size_t i): charNZ
overload [] with string_get_at

fun
string_set_char_at{n:int}
  {i:nat | i < n} (str: string n, i: size_t i, c: charNZ): void
overload [] with string_set_char_at
")

型コンストラクタ #stacode("char") には種 #emphasis("(char) -&gt; t@ype") が割り当てられています。
このコンストラクタは静的な文字 c を取って c と等しい文字しか持てないシングルトン型 #stacode("char(c)")
を作ります。
したがって型 #stacode("charNZ") は全ての非NULL文字を表わします。
次に定義される関数 #dyncode("string_find") は文字列を左から右に走査して、与えられた文字が文字列の中に見つかるか判定します:

#atscode("\
//
typedef
sizeLt (n:int) = [i:nat | i < n] size_t (i)
//
fun string_find{n:nat}
(
  str: string n, c0: char
) : Option (sizeLt n) = let
  typedef res = sizeLt (n)
  fun loop{i:nat | i <= n}
  (
    str: string n, c0: char, i: size_t i
  ) : Option (res) =
  (
    if string_isnot_atend (str, i) then
      if (c0 = str[i]) then Some{res}(i) else loop (str, c0, succ(i))
    else None () // end of [if]
  ) (* end of [loop] *)
in
  loop (str, c0, i2sz(0))
end // end of [string_find]
//
")

もし文字 #dyncode("c0") が文字列 #dyncode("str") の中に存在するなら #dyncode("Some(i)") の値を返します。
この i は #dyncode("c0") がはじめに出現した位置を(左から右に数えて)参照しています。
そうでなければ値 #dyncode("None()") が返ります。\

")#comment("para")
")

#langeng("
#para("\

There is some inherent inefficiency in the implementation of
#dyncode("string_find"): A given position #dyncode("i") is first checked to
see if it is strictly less than the length of the string #dyncode("str") by
calling #dyncode("string_isnot_atend"), and, if it is, the character stored
at the position in the string is fetched by calling
#dyncode("string_get_at"). These two function calls are merged into one in
the following implementation:

#atscode("\
//
// This implementation does the same as [string_find]
// but should be more efficient.
//
fun
string_find2{n:nat}
(
  str: string n, c0: char
) : Option (sizeLt n) = let
//
fun
loop{i:nat | i <= n}
(
  str: string n
, c0: char, i: size_t i
) : Option (sizeLt n) = let
  typedef res = sizeLt (n)
  val c = string_test_at (str, i)
in
  if c != '\\\\000' then
  (
    if (c0 = c) then Some{res}(i) else loop (str, c0, succ(i))
  ) else None ((*void*)) // end of [if]
end // end of [loop]
//
in
  loop (str, c0, i2sz(0))
end // end of [string_find2]
")

The interface for the function #dyncode("string_test_at") is given as
follows:

#atscode("\
fun
string_test_at
  {n:int}{i:nat | i <= n}
(
  str: string (n), i: size_t (i)
) : [c:char | (c != NUL && i < n) || (c == NUL && i >= n)] char c
// end of [string_test_at]
")

By checking the return value of a call to #dyncode("string_test_at"),
we can readily tell whether the position #dyncode("i") is at the end of
the string #dyncode("str").\

")#comment("para")
")
#langja("
#para("\

#dyncode("string_find") の実装にはいくらか非効率な部分があります:
最初に #dyncode("string_isnot_atend") 呼び出して、与えられた位置 #dyncode("i") は 文字列 #dyncode("str")
の長さより短かいかどうか検査されます。
そしてもし短かければ #dyncode("string_get_at") を呼び出して、
文字列の当該位置に保存されている文字を取り出します。
これら2つの関数呼び出しを次の実装のように1つにまとめましょう:

#atscode("\
//
// This implementation does the same as [string_find]
// but should be more efficient.
//
fun
string_find2{n:nat}
(
  str: string n, c0: char
) : Option (sizeLt n) = let
//
fun
loop{i:nat | i <= n}
(
  str: string n
, c0: char, i: size_t i
) : Option (sizeLt n) = let
  typedef res = sizeLt (n)
  val c = string_test_at (str, i)
in
  if c != '\\\\000' then
  (
    if (c0 = c) then Some{res}(i) else loop (str, c0, succ(i))
  ) else None ((*void*)) // end of [if]
end // end of [loop]
//
in
  loop (str, c0, i2sz(0))
end // end of [string_find2]
")

The interface for the function #dyncode("string_test_at") is given as
follows:

#atscode("\
fun
string_test_at
  {n:int}{i:nat | i <= n}
(
  str: string (n), i: size_t (i)
) : [c:char | (c != NUL && i < n) || (c == NUL && i >= n)] char c
// end of [string_test_at]
")

#dyncode("string_test_at") 呼び出しの返値を検査することで、
位置 #dyncode("i") が文字列 #dyncode("str") の最後かどうかすぐに判定できます。\

")#comment("para")
")

#langeng("
#para("\

Handling strings safely and efficiently is a complicated matter in
programming language design, and a great deal of information about a
programming language can often be revealed by simply studying its treatment
of strings. In ATS, properly processing C-style strings also makes
essential use of linear types, which I will cover in another part of this
book.\

")#comment("para")
")
#langja("
#para("\

文字列を安全に効率的に取り扱うことは、プログラミング言語のデザインにおいて厄介事の一つです。
またプログラミング言語に関する大量の情報が、文字列の取り扱いに関することであることもしばしばです。
ATSでは、線形型を使ってC言語スタイル文字列を適切に処理することができます。
このトピックはこの本の別の章で紹介します。\

")#comment("para")
")

</sect1><!--id="example_string_processing"-->

<!-- ****** ****** -->

<sect1
id="example_binary_search_on_arrays">
#langeng("
#title("Example: Binary Search on Arrays")
")
#langja("
#title("例: 配列の二分探索")
")

#langeng("
#para("\

Given a type T of the sort #emphasis("t@ype") and a static integer I (i.e.,
a static term of the sort #emphasis("int")), #stacode("arrayref(T, I)") is
a boxed type for arrays of size I in which each stored element is of the
type T. Note that such arrays have no size information attached to them.
The following interface is for a function template
#dyncode("array_make_elt") that can be called to create an array (with no
size information attached to it):

#atscode("\
fun{a:t@ype}
array_make_elt{n:int} (asz: size_t n, elt: a): arrayref (a, n)
")

Given a static integer I, the type #stacode("size_t(I)") is a singleton
type for a value of the type size_t in C that represents the integer equal
to I. The function templates for reading from and writing to an array cell
have the following interfaces:

#atscode("\
fun{a:t@ype}
arrayref_get_at
  {n:int}{i:nat | i < n} (A: arrayref (a, n), i: size_t i): a
overload [] with arrayref_get_at

fun{a:t@ype}
arrayref_set_at
  {n:int}{i:nat | i < n} (A: arrayref (a, n), i: size_t i, x: a): void
overload [] with arrayref_set_at
")

Note that these two function templates do not incur any run-time
array-bounds checking: The types assigned to them guarantee that each index
used for array subscripting is always legal, that is, within the bounds of
the array being subscripted.\

")#comment("para")
")
#langja("
#para("\

種 #emphasis("t@ype") の型 T と静的な整数 I (例: 種 #emphasis("int") の静的な項)が与えられた時、#stacode("arrayref(T, I)") はボックス化型で、保管されている要素が型 T であるサイズ I の配列です。
このような配列はサイズに関する情報を付随して持っていないことに注意してください。
次のインターフェイスは配列を生成するための関数テンプレート #dyncode("array_make_elt") です。
このテンプレートが生成する配列もまたサイズ情報を持っていません:

#atscode("\
fun{a:t@ype}
array_make_elt{n:int} (asz: size_t n, elt: a): arrayref (a, n)
")

静的な整数 I が与えられた時、型 #stacode("size_t(I)") はシングルトン型で、I と等しい整数を表わすC言語の型 size_t の値を表わします。
配列要素の読み書きのための関数テンプレートは次のようなインターフェイスを持ちます:

#atscode("\
fun{a:t@ype}
arrayref_get_at
  {n:int}{i:nat | i < n} (A: arrayref (a, n), i: size_t i): a
overload [] with arrayref_get_at

fun{a:t@ype}
arrayref_set_at
  {n:int}{i:nat | i < n} (A: arrayref (a, n), i: size_t i, x: a): void
overload [] with arrayref_set_at
")

これら2つの関数テンプレートはどのような実行時の配列境界チェックもしないことに注意してください:
これらに割り当てられた型は配列の添字として使われるそれぞれのインデックスが常に正当であることを保証します。
つまり配列の添字が範囲内であることを保証します。\

")#comment("para")
")

#langeng("
#para("\

As a convincing example of practical programming with dependent types, the
following code implements the standard binary search algorithms on an ordered
array:

#atscode("\
fun{
a:t@ype
} bsearch_arr{n:nat}
(
  A: arrayref (a, n), n: int n, x0: a, cmp: (a, a) -> int
) : int = let
//
fun loop
  {i,j:int |
   0 <= i; i <= j+1; j+1 <= n}
(
  A: arrayref (a, n), l: int i, u: int j
) :<cloref1> int =
(
  if l <= u then let
    val m = l + half (u - l)
    val x = A[m]
    val sgn = cmp (x0, x)
  in
    if sgn >= 0 then loop (A, m+1, u) else loop (A, l, m-1)
  end else u // end of [if]
) (* end of [loop] *)
//
in
  loop (A, 0, n-1)
end // end of [bsearch_arr]
")

The function #dyncode("loop") defined in the body of
#dyncode("bsearch_arr") searches the segment of the array #dyncode("A")
between the indices #dyncode("l") and #dyncode("u"), inclusive.  Clearly,
the type assigned to #dyncode("loop") indicates that the integer values i
and j of the arguments #dyncode("l") and #dyncode("u") must satisfy the
precondition consisting of the constraints 0 <= i, i <= j+1, and j+1 <= n,
where n is the size of the array being searched.  The progress we have made
by introducing dependent types into ATS should be evident in this example:
We can not only specify much more precisely than before but also enforce
effectively the enhanced precision in specification.\

")#comment("para")
")
#langja("
#para("\

依存型を使った実際のプログラミングの説得力のある例として、次のコードでは整列された配列に対する標準の二分探索アルゴリズムを実装しています:

#atscode("\
fun{
a:t@ype
} bsearch_arr{n:nat}
(
  A: arrayref (a, n), n: int n, x0: a, cmp: (a, a) -> int
) : int = let
//
fun loop
  {i,j:int |
   0 <= i; i <= j+1; j+1 <= n}
(
  A: arrayref (a, n), l: int i, u: int j
) :<cloref1> int =
(
  if l <= u then let
    val m = l + half (u - l)
    val x = A[m]
    val sgn = cmp (x0, x)
  in
    if sgn >= 0 then loop (A, m+1, u) else loop (A, l, m-1)
  end else u // end of [if]
) (* end of [loop] *)
//
in
  loop (A, 0, n-1)
end // end of [bsearch_arr]
")

#dyncode("bsearch_arr") の本体で定義されている関数 #dyncode("loop") は配列 #dyncode("A")
のインデックス #dyncode("l") と #dyncode("u") の間の部分を探索します。
#dyncode("loop") に割り当てられた型は、引数 #dyncode("l") と #dyncode("u") の整数の値 i と j
が、制約 0 <= i, i <= j+1, j+1 <= n から成る前提条件を必ず満たすことを明確に示しています。
このとき n は探索する配列のサイズです。
依存型を ATS に導入したことによる進歩はこの例で明白になったでしょう:
導入前よりはるかに正確に仕様を規定できるようになっただけでなく、強化した正確さを効果的に強制することも可能になったのです。\

")#comment("para")
")

#langeng("
#para("\

Please find #mycodelink("CHAP_DEPTYPES/bsearch_arr.dats", "on-line") the
code employed for illustration in this section plus some additional code
for testing.\

")#comment("para")
")
#langja("
#para("\

この章で紹介したコードと追加のテストコードは
#mycodelink("CHAP_DEPTYPES/bsearch_arr.dats", "オンライン")
から入手できます。\

")#comment("para")
")

</sect1><!--id="example_binary_search_on_arrays"-->

<!-- ****** ****** -->

<sect1
id="termination-checking_for_recursive_functions">
#langeng("
#title("Termination-Checking for Recursive Functions")
")
#langja("
#title("再帰関数の停止性検査")
")

#langeng("
#para("\

There is a mechanism in ATS that allows the programmer to supply
termination metrics for checking whether recursively defined functions are
terminating.  It will soon become clear that this mechanism of
termination-checking plays a fundamental role in the design of ATS/LF, a
theorem-proving subsystem of ATS, where proofs are constructed as total
functional programs.\

")
")
#langja("
#para("\

ATS には、再帰的に定義された関数の停止性を検査するための停止性メトリクス (termination metrics)
をプログラマ自身で提供できるような、メカニズムがあります。
すぐに明らかになることですが、この停止性検査のメカニズムは
ATS/LF のデザインにおいて基礎的な役割を果たします。
この ATS/LF は ATS における定理証明サブシステムで、その証明は全域関数プログラムとして構成されます。\

")
")

#langeng("
#para("\

A termination metric is just a tuple of natural numbers and the standard
lexicographic ordering on natural numbers is used to order such tuples. In
the following example, a singleton metric #stacode("n") is supplied to
verify that the recursive function #dyncode("fact") is terminating, where
#stacode("n") is the value of the integer argument of #dyncode("fact"):

#atscode("\
fun fact {n:nat} .<n>.
  (x: int n): int = if x > 0 then x * fact (x-1) else 1
// end of [fact]
")

Note that the metric attached to the recursive call #dyncode("fact(x-1)")
is #stacode("n-1"), which is strictly less than the initial metric
#stacode("n"). Essentially, termination-checking in ATS verifies that the
metric attached to each recursive call in the body of a function is
strictly less that the initial metric attached to the function.
")#comment("para")
")
#langja("
#para("\

停止性メトリクスは自然数の単純なタプルで、
そのタプルの順序には標準の自然数の辞書順が使われます。
次の例では、再帰関数 #dyncode("fact") が停止するか検査するために、シングルトンメトリクス
(singleton metric) #stacode("n") を与えています。
このとき #stacode("n") は #dyncode("fact") の整数引数の値です:

#atscode("\
fun fact {n:nat} .<n>.
  (x: int n): int = if x > 0 then x * fact (x-1) else 1
// end of [fact]
")

再帰呼び出し #dyncode("fact(x-1)") に付随したメトリクスは #stacode("n-1")
であり、これは最初のメトリクス #stacode("n") よりも小さいことに注意してください。
本質的に、ATS における停止性検査とは、関数の本体にあるそれぞれの再帰呼び出しに付随するメトリクスが、その関数の当初のメトリクスよりも必ず小さくなること検証することです。
")#comment("para")
")

#langeng("
#para("\

A more difficult and also more interesting example is given as follows,
where the MacCarthy's 91-function is implemented:

#atscode("\
fun f91 {i:int} .<max(101-i,0)>. (x: int i)
  : [j:int | (i < 101 && j==91) || (i >= 101 && j==i-10)] int (j) =
  if x >= 101 then x-10 else f91 (f91 (x+11))
// end of [f91]
")

The metric supplied to verify the termination of #dyncode("f91") is
#stacode("max(101-i,0)"), where #stacode("i"). is the value of the
integer argument of #dyncode("f91"). Please try to verify manually that
this metric suffices for verifying the termination of #dyncode("f91").\

")#comment("para")
")
#langja("
#para("\

より難しくまた興味深い例は、次のマッカーシーの91関数 (MacCarthy's 91-function) の実装です:

#atscode("\
fun f91 {i:int} .<max(101-i,0)>. (x: int i)
  : [j:int | (i < 101 && j==91) || (i >= 101 && j==i-10)] int (j) =
  if x >= 101 then x-10 else f91 (f91 (x+11))
// end of [f91]
")

#dyncode("f91") の停止性を証明するために与えられたメトリクスは
#stacode("max(101-i,0)") です。
このとき #stacode("i") は #dyncode("f91") の整数引数の値です。
このメトリクスが #dyncode("f91") の停止性検証するのに十分であるかどうか、手で検証してみてください。\

")#comment("para")
")

#langeng("
#para("\

As another example, the following code implements the Ackermann's function,
which is well-known for being recursive but not primitive recursive:

#atscode("\
fun acker
  {m,n:nat} .<m,n>.
  (x: int m, y: int n): Nat =
  if x > 0 then
    if y > 0 then acker (x-1, acker (x, y-1)) else acker (x-1, 1)
  else y + 1
// end of [acker]
")

The metric supplied for verifying the termination of #dyncode("acker") is a
pair #stacode("(m,n)"), where #stacode("m") and #stacode("n") are values of
the two integer arguments of #dyncode("acker"). The metrics attached to the
three recursive calls to #dyncode("acker") are, from left to right,
#stacode("(m-1,k)") for some natural number k, #stacode("(m,n-1)"), and
#stacode("(m-1,1)"). Clearly, these metrics are all strictly less than the
initial metric #stacode("(m,n)") according to the lexicographic ordering on
pairs of natural numbers.\

")#comment("para")
")
#langja("
#para("\

別の例として、次のコードはアッカーマン関数を実装しています。
この関数は原始再帰関数でない再帰として有名です:

#atscode("\
fun acker
  {m,n:nat} .<m,n>.
  (x: int m, y: int n): Nat =
  if x > 0 then
    if y > 0 then acker (x-1, acker (x, y-1)) else acker (x-1, 1)
  else y + 1
// end of [acker]
")

#dyncode("acker") の停止性検証のために与えられたメトリックはペア #stacode("(m,n)") です。
このとき #stacode("m") と #stacode("n") は #dyncode("acker") の2つの整数引数の値です。
#dyncode("acker") への3つの再帰呼び出しに付随するメトリクスは、左から右に
#stacode("(m-1,k)"), #stacode("(m,n-1)"), #stacode("(m-1,1)") です。
このとき k はなんらかの自然数です。
自然数のペアを辞書順によれば、これらのメトリクスは初期のメトリクス #stacode("(m,n)")
よりも小さくなっていることは明白です。\

")#comment("para")
")

#langeng("
#para("\

Termination-checking for mutually recursive functions is similar.  In the
following example, #dyncode("isevn") and #dyncode("isodd") are defined
mutually recursively:

#atscode("\
fun isevn
  {n:nat} .<2*n>.
  (n: int n) : bool =
  if n = 0 then true else isodd (n-1)
and isodd
  {n:nat} .<2*n+1>.
  (n: int n) : bool = not (isevn (n))
")

The metrics supplied for verifying the termination of #dyncode("isevn") and
#dyncode("isodd") are #stacode("2*n") and #stacode("2*n+1"), respectively,
where #stacode("n") is the value of the integer argument of
#dyncode("isevn") and also the value of the integer argument of
#dyncode("isodd").  Clearly, if the metrics #stacode("(n, 0)") and
#stacode("(n, 1)") are supplied for #dyncode("isevn") and
#dyncode("isodd"), respectively, the termination of these two functions can
also be verified.  Note that it is required that the metrics for mutually
recursively defined functions be tuples of the same length.\

")#comment("para")
")
#langja("
#para("\

相互再帰関数の停止性検査も同様です。
次の例では、#dyncode("isevn") と #dyncode("isodd") が相互再帰的に定義されています:

#atscode("\
fun isevn
  {n:nat} .<2*n>.
  (n: int n) : bool =
  if n = 0 then true else isodd (n-1)
and isodd
  {n:nat} .<2*n+1>.
  (n: int n) : bool = not (isevn (n))
")

#dyncode("isevn") と #dyncode("isodd") の停止性を検査するために与えられたメトリクスはそれぞれ
#stacode("2*n") と #stacode("2*n+1") です。
このとき #stacode("n") は #dyncode("isevn") の整数引数の値であり、さらにまた
#dyncode("isodd") の整数引数の値です。
#dyncode("isevn") と #dyncode("isodd") に #stacode("(n, 0)") と #stacode("(n, 1)")
のメトリクスを与えれば、これら2つの関数の停止性もまた検査できることは明白です。
相互再帰的に定義された関数のメトリクスは同じ長さのタプルであることが要求されることに注意してください。\

")#comment("para")
")

</sect1><!--id="termination-checking_for_recursive_functions"-->

<!-- ****** ****** -->

<sect1
id="dependent_types_for_debugging">
#langeng("
#title("Example: Dependent Types for Debugging")
")
#langja("
#title("例: 依存型を使ったデバッグ")
")

#langeng("
#para("\

Given an integer x >= 0, the integer square root of x is the greatest
integer i satisfying i * i <= x.  An implementation of the integer square
root function is given as follows based on the method of binary search:

#atscode("\
fun isqrt
  (x: int): int = let
//
fun search
(
  x: int, l: int, r: int
) : int = let
  val diff = r - l
in
  case+ 0 of
  | _ when diff > 0 => let
      val m = l + (diff / 2)
    in
      // x < m * m is more efficient but can overflow easily
      if x / m < m then search (x, l, m) else search (x, m, r)
    end // end of [if]
  | _ => l (* the result is found *)
end // end of [search]
//
in
  search (x, 0, x)
end // end of [isqrt]
")

This implementation passes typechecking, but it seems to be looping forever
when tested. Instead of going into the standard routine of debugging (e.g.,
by inserting calls to some printing functions), let us attempt to identify
the cause for infinite looping by proving the termination of the function
#dyncode("search") through the use of dependent types. Clearly, the
function #dyncode("search") is assigned the function type #stacode("(int,
int, int) -&gt; int"), meaning that #dyncode("search") takes three integers as
its arguments and returns an integer as its result, and there is not much
else that can be gathered from a non-dependent type as such. However, the
programmer may have thought that the function #dyncode("search") should
possess the following invariants (if implemented correctly):

<itemizedlist>

<listitem>
#para("
l * l &lt;= x and x &lt;= r * r must hold when #dyncode("search(x, l, r)") is called.
")
</listitem>

<listitem>
#para("\

Assume l * l &lt;= x &lt; r * r for some integers x, l, r.  If a recursive
call #dyncode("search(x, l1, r1)") for some integers l1 and r1 is
encountered in the body of #dyncode("search(x, l, r)"), then r1-l1 &lt; r-l
must hold. This invariant implies that #dyncode("search") is terminating.\

")
</listitem>

</itemizedlist>

Though the first invariant can be captured in the type system of ATS, it is
somewhat involved to do so due to the need for handling nonlinear
constraints. Instead, let us try to assign #dyncode("search") the following
dependent function type:

#atscode("\
{x:nat} {l,r:nat | l < r} .<r-l>. (int(x), int(l), int(r)) -> int
")

which captures a weaker invariant stating that l &lt; r must hold when
#dyncode("search(x, l, r)") is called. The termination metric
#stacode(".&lt;r-l&gt;.") is provided for checking that the function
#dyncode("search") is terminating. When we assign #dyncode("search") the
dependent function type, we have to modify its body as certain errors are
otherwise reported during typechecking. The following code we obtain after
proper modification does pass typechecking:

#atscode("\
fun
isqrt{x:nat}
  (x: int x): int = let
//
fun search
  {x,l,r:nat | l < r} .<r-l>.
(
  x: int x, l: int l, r: int r
) : int = let
  val diff = r - l
in
  case+ 0 of
  | _ when diff > 1 => let
      val m = l + (diff / 2)
    in
      if x / m < m then search (x, l, m) else search (x, m, r)
    end // end of [if]
  | _ => l (* the result is found *)
end // end of [search]
//
in
  if x > 0 then search (x, 0, x) else 0
end // end of [isqrt]
")

It is now rather clear that infinite looping in the previous implementation
of #dyncode("search") may happen if #dyncode("search(x, l, r)") is called
in a situaltion where r-l equals 1 as this call can potentially lead to
another call to #dyncode("search") of the same arguments. However, such a call
leads to a type-error after #dyncode("search") is assigned the aforementioned
dependent function type.\

")#comment("para")
")
#langja("
#para("\

x >= 0 の整数が割り当てられた時、x の平方根は i * i <= x を満たすような最大の整数 i になります。
次のように平方根関数を二分探索法をもとに実装します:

#atscode("\
fun isqrt
  (x: int): int = let
//
fun search
(
  x: int, l: int, r: int
) : int = let
  val diff = r - l
in
  case+ 0 of
  | _ when diff > 0 => let
      val m = l + (diff / 2)
    in
      // x < m * m is more efficient but can overflow easily
      if x / m < m then search (x, l, m) else search (x, m, r)
    end // end of [if]
  | _ => l (* the result is found *)
end // end of [search]
//
in
  search (x, 0, x)
end // end of [isqrt]
")

この実装は型検査を通りますが、実行すると無限ループにおちいってしまいます。
一般的なデバッグ手法 (例: プリント関数呼び出しを埋め込む) を使う代わりに、依存型を使って関数
#dyncode("search") の停止性を証明して、無限ループの原因を特定してみることにしましょう。
関数 #dyncode("search") には関数型 #stacode("(int, int, int) -&gt; int") が割り当てられています。
これは #dyncode("search") が3つの整数を引数に取り、1つの整数を返すことを意味しています。
このような非依存型からその他の情報が得られないことは明確です。
けれども、もし実装が正しければ関数 #dyncode("search") は次の不変条件を持つべきだと、プログラマは思うでしょう:

<itemizedlist>

<listitem>
#para("
#dyncode("search(x, l, r)") が呼び出された時、l * l &lt;= x かつ x &lt;= r * r である。
")
</listitem>

<listitem>
#para("\

整数 x, l, r について l * l &lt;= x &lt; r * r を仮定します。
#dyncode("search(x, l, r)") の本体で整数 l1 と r1 について再帰関数 #dyncode("search(x, l1, r1)")
を呼び出すと、r1-l1 &lt; r-l です。
この不変条件は #dyncode("search") が停止することを示しています。\

")
</listitem>

</itemizedlist>

1番目の不変条件は ATS の型システムで表現できるにもかかわらず、
非線形な制約を取り扱う必要があるためにいくぶん複雑です。
その代わりに、次の依存型の関数として #dyncode("search") を定義してみましょう:

#atscode("\
{x:nat} {l,r:nat | l < r} .<r-l>. (int(x), int(l), int(r)) -> int
")

#dyncode("search(x, l, r)") が呼び出される時、より弱い不変条件である l &lt; r を取ります。
関数 #dyncode("search") の停止性を検証するために停止性メトリクス #stacode(".&lt;r-l&gt;.") を与えます。
#dyncode("search") に依存型の関数型を割り当てると、型検査で見つかるエラーに対して関数本体を修正する必要があります。
次のコードは型検査を通るように適切な修正を施したものです:

#atscode("\
fun
isqrt{x:nat}
  (x: int x): int = let
//
fun search
  {x,l,r:nat | l < r} .<r-l>.
(
  x: int x, l: int l, r: int r
) : int = let
  val diff = r - l
in
  case+ 0 of
  | _ when diff > 1 => let
      val m = l + (diff / 2)
    in
      if x / m < m then search (x, l, m) else search (x, m, r)
    end // end of [if]
  | _ => l (* the result is found *)
end // end of [search]
//
in
  if x > 0 then search (x, 0, x) else 0
end // end of [isqrt]
")

r-l が 1 等しい時に #dyncode("search(x, l, r)") が呼び出されると、以前の
#dyncode("search") 実装における無限ループが発生するのではないか、ということが明らかになりました。
この呼び出しは同じ引数で別の #dyncode("search") 呼び出しを引き起こしてしまう可能性があります。
けれども、#dyncode("search") に前述の依存型の関数型が割り当てた後では、そのような呼び出しは型エラーになります。\

")#comment("para")
")

#langeng("
#para("\

By being precise and being able to enforce precision effectively, the
programmer will surely notice that his or her need for run-time debugging
is diminishing rapidly.\

")
")
#langja("
#para("\

正確であろうとし、また効果的に正確さを強制できることで、実行時デバッグの必要性はどんどん小さくなることに、プログラマは確実に気が付くでしょう。\

")
")

</sect1><!--id="dependent_types_for_debugging"-->

<!-- ****** ****** -->

</chapter>
<!--id="introduction_to_dependent_types"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
