%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="parametric_polymorphism">
#langeng("
#title("Parametric Polymorphism")
")
#langja("
#title("パラメータ多相")
")

#langeng("
#para("\

Code sharing is of paramount importance in programming.  In a typed
programming language, we often encounter a situation where the same
functionality is needed for values of different types. For instance, we may
need to compute the length of a list while the elements in the list can be
characters, integers, strings, etc. Evidently, we want to avoid
implementing a list-length function for each element type as it would
probably be the worst form of code duplication. We want to implement one
single function that can be applied to any list to compute the length of
the list. This list-length function parameterizes over the element type of
a given list, and it behaves uniformly regardless what the element type is.
This is a form of code sharing that is often referred to as
#emphasis("parametric polymorphism"), which should be distinguished from
other forms of polymorphism such as inheritance polymorphism in
object-oriented programming.\

")#comment("para")
")
#langja("
#para("\

コードの共有はプログラミングにおいて最も重要です。
型付きのプログラミング言語では、異なる型の値が同じ機能を必要としてしまうような状況にしばしば出会います。
例えば、文字, 整数, 文字列などをリストの要素とするリストの長さを算出する必要があるかもしれません。
明らかに、リストの長さを取る関数をそれぞれの要素の型毎に実装したくはありません。
おそらくコード重複の最悪の形でしょう。
どんなリストに対してもリストの長さを算出できるような唯一の関数を実装したいのです。
このリストの長さを取る関数は与えられたリストの要素の型をパラメータ化し、要素の型によらず一様な振る舞いをします。
このようなコードの共有はしばしば #emphasis("パラメータ多相") と呼ばれます。
これはオブジェクト指向プログラミングにおける継承ポリモーフィズムのようなその他のポリモーフィズムとは区別すべきです。\

")#comment("para")
")

#langeng("
#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_POLYMORPH", "on-line").\

")
")
#langja("
#para("\

この章で示すコードと追加のテストコードは
#mycodelink("CHAP_POLYMORPH", "オンライン")
から入手できます。\

")
")

<sect1
id="function_templates">
#langeng("
#title("Function Templates")
")
#langja("
#title("関数テンプレート")
")

#langeng("
#para("\

A function template is a code template that implements a function.
In the following code, two functions are defined to swap values:

#atscode("\
typedef charint = (char, int)
typedef intchar = (int, char)
fun swap_char_int (xy: charint): intchar = (xy.1, xy.0)
fun swap_int_char (xy: intchar): charint = (xy.1, xy.0)
")

If types are ignored, the bodies of #dyncode("swap_char_int") and
#dyncode("swap_int_char") are identical. In order to avoid this kind of
code duplication, we can first implement a function template
#dyncode("swap") as follows and then implement #dyncode("swap_char_int")
and #dyncode("swap_int_char") based on #dyncode("swap"):

#atscode("\
fun{
a,b:t@ype
} swap (xy: (a, b)): (b, a) = (xy.1, xy.0)
fun swap_char_int (xy: charint): intchar = swap<char,int> (xy)
fun swap_int_char (xy: intchar): charint = swap<int,char> (xy)
")

It should be noted that a function template is not a first-class value in
ATS: There is no expression for representing a function template.  The
syntax #stacode("{a,b:t@ype}") following the keyword #dyncode("fun")
represents template parameters or arguments. The unusual symbol
#stacode("t@ype") is a sort for static terms representing types of
unspecified size, where the size of a type is the number of bytes needed
for representing a value of the type (under the assumption that all of the
values of the type have the same size).  There is another sort
#stacode("type") in ATS, which is for static terms representing types of
size equal to one word exactly, that is, 4 bytes on a 32-bit machine or 8
bytes on a 64-bit machine.  The syntax #dyncode("swap&lt;char,int&gt;"),
where no space is allowed between #dyncode("swap") and #dyncode("&lt;") ,
stands for an instance of the function template #dyncode("swap") in which
the parameters #stacode("a") and #stacode("b") are replaced with
#stacode("char") and #stacode("int"), respectively.  The syntax
#dyncode("swap&lt;int,char&gt;") is interpreted similarly.\

")#comment("para")
")
#langja("
#para("\

関数テンプレートは関数を実装するコードテンプレートです。
次のコードは、値をスワップする2つの関数を定義しています:

#atscode("\
typedef charint = (char, int)
typedef intchar = (int, char)
fun swap_char_int (xy: charint): intchar = (xy.1, xy.0)
fun swap_int_char (xy: intchar): charint = (xy.1, xy.0)
")

型を無視すると #dyncode("swap_char_int") と #dyncode("swap_int_char") の中身は同一です。
この種類のコードの重複を防ぐために、まずはじめに関数テンプレート #dyncode("swap") を次のように実装し、それから #dyncode("swap_char_int") と #dyncode("swap_int_char") を #dyncode("swap") を元に実装します:

#atscode("\
fun{
a,b:t@ype
} swap (xy: (a, b)): (b, a) = (xy.1, xy.0)
fun swap_char_int (xy: charint): intchar = swap<char,int> (xy)
fun swap_int_char (xy: intchar): charint = swap<int,char> (xy)
")

関数テンプレートは ATS において第一級の値ではないことに注意すべきです:
関数テンプレートを表わすような式は存在しません。
キーワード #dyncode("fun") に続く構文 #stacode("{a,b:t@ype}") はテンプレートパラメータや引数を表わしています。
一風変わった記号 #stacode("t@ype") はサイズが特定されていない型を表現する静的な項の種で、その型のサイズは型の値を表現するのに必要なバイト数です (型の値のサイズが全て同じであると仮定した場合ですが)。
ATS にはもう一つの種 #stacode("type") があり、サイズが正確に1ワードである型を表現する静的な項です。
1ワードというのは、32ビットマシンは4バイト、64ビットマシンでは8バイトです。
#dyncode("swap&lt;char,int&gt;") という構文は
(#dyncode("swap") と #dyncode("&lt;") の間にスペースを入れないでください)、
パラメータ #stacode("a") と #stacode("b") をそれぞれ #stacode("char") と #stacode("int")
で置き換えた関数テンプレート #dyncode("swap") のインスタンスを表わします。
構文 #dyncode("swap&lt;int,char&gt;") も同様に解釈できるでしょう。\

")#comment("para")
")

#langeng("
#para("\

A different style of implementation of #dyncode("swap") is given
as follows:

#atscode("\
fun{a:t@ype}{b:t@ype} swap2 (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

where the template parameters are given sequentially (instead of
simultaneously). The following code shows how #dyncode("swap2") can be
instantiated to form instances:

#atscode("\
fun swap_char_int (xy: charint): intchar = swap2<char><int> (xy)
fun swap_int_char (xy: intchar): charint = swap2<int><char> (xy)
")

Note that #dyncode("&gt;&lt;") is a special symbol (of the name GTLT) and
no space is allowed between #dyncode("&gt;") and #dyncode("&lt;").\

")#comment("para")
")
#langja("
#para("\

次のような #dyncode("swap") の異なるスタイルの実装を見てみましょう:

#atscode("\
fun{a:t@ype}{b:t@ype} swap2 (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

上記の実装ではテンプレートパラメータは同時にではなく連続して与えられています。
次のコードは #dyncode("swap2") をインスタンス化する方法を示しています:

#atscode("\
fun swap_char_int (xy: charint): intchar = swap2<char><int> (xy)
fun swap_int_char (xy: intchar): charint = swap2<int><char> (xy)
")

#dyncode("&gt;&lt;") は (GTLTという名前の) 特別な記号で、#dyncode("&gt;") と #dyncode("&lt;") の間にスペースを入れてはいけません。\

")#comment("para")
")

#langeng("
#para("\

As another example, a higher-order function template for composing
(closure) functions is given as follows:

#atscode("\
typedef
cfun (t1:t@ype, t2:t@ype) = t1 -<cloref1> t2

fun{
a,b,c:t@ype
} compose (
  f: cfun (a, b), g: cfun (b, c)
) :<cloref1> cfun (a, c) = lam x => g(f(x))

val plus1 = lam (x:int): int =<cloref> x+1
val times2 = lam (x:int): int =<cloref> x*2

val f_2x_1 = compose<int,int,int> (times2, plus1)
val f_2x_2 = compose<int,int,int> (plus1, times2)
")

It should be clear that the value #dyncode("f_2x_1") represents the
function that multiplies its integer argument by 2 and then adds 1 to it.
Similarly, the value #dyncode("f_2x_2") represents the function that adds 1
to its integer argument and then multiplies it by 2.\

")#comment("para")
")
#langja("
#para("\

別の例として、(クロージャ) 関数を作る高階関数テンプレートを次に示します:

#atscode("\
typedef
cfun (t1:t@ype, t2:t@ype) = t1 -<cloref1> t2

fun{
a,b,c:t@ype
} compose (
  f: cfun (a, b), g: cfun (b, c)
) :<cloref1> cfun (a, c) = lam x => g(f(x))

val plus1 = lam (x:int): int =<cloref> x+1
val times2 = lam (x:int): int =<cloref> x*2

val f_2x_1 = compose<int,int,int> (times2, plus1)
val f_2x_2 = compose<int,int,int> (plus1, times2)
")

値 #dyncode("f_2x_1") は、整数の引数に2を掛けた後に1を足す関数を表わしています。
同様に、値 #dyncode("f_2x_2") は、1を整数の引数に足した後に2を掛ける関数を表わしています。\

")#comment("para")
")

#langeng("
#para("\

In ATS, function templates are typechecked but not compiled to code in C.
Instead, they are compiled to an intermediate form.  Only instances of
function templates are compiled to code in C. Suppose we have a function
template foo taking one type parameter and two instances foo&lt;T1&gt; and
foo&lt;T2&gt; are used in a program for some types T1 and T2. In general,
one function in C is generated for each instance of foo when the program is
compiled. However, if T1 and T2 have the same name, then the two instances
may share one function in C.\

")#comment("para")
")
#langja("
#para("\

ATS では、関数テンプレートは型検査されますが、C言語コードにはコンパイルされません。
その代わり、関数テンプレートは中間形式にコンパイルされます。
関数テンプレートのインスタンスのみがC言語コードにコンパイルされます。
1つの型パラメータを取る関数テンプレート foo と、
2つのインスタンス foo&lt;T1&gt; と foo&lt;T2&gt; が T1 と T2 型でプログラムで使用されていると考えてみましょう。
一般的に、プログラムがコンパイルされると、C言語の1つ1つの関数は foo のそれぞれのインスタンスから生成されます。
けれども、T1 と T2 が同じ名前を持っているなら、2つのインスタンスはC言語の1つの関数を共有するかもしれません。\

")#comment("para")
")

#langeng("
#para("\

Please note that I may simply use the name function to refer to a function
template from now on if no confusion is expected.\

")
")
#langja("
#para("\

混乱しないと思われる場合、これからこの本では関数という名前を関数テンプレートの意味で使うことがあることに注意してください。\

")
")

</sect1><!--id="function_templates"-->

<!-- ****** ****** -->

<sect1
id="polymorphic_functions">
#langeng("
#title("Polymorphic Functions")
")
#langja("
#title("多相関数")
")

#langeng("
#para("\

A polymorphic function is rather similar to a function template.
However, the former is a first-class value in ATS while the latter is not.
As an example, the following defined function #dyncode("swap_boxed") is
polymorphic:

#atscode("\
fun swap_boxed{a,b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

The type variables #stacode("a") and #stacode("b") are often referred as
static arguments while #dyncode("xy") is a dynamic argument. Here is some code
that makes use of the polymorphic function #dyncode("swap_boxed"):

#atscode('\
val AB = ("A", "B")
val BA1 = swap_boxed{string,string} (AB)
val BA2 = swap_boxed (AB) // omitting type arguments may be fine
')

If #stacode("swap_boxed") is called on a pair of the type (T1, T2) for some
types T1 and T2, both T1 and T2 are required to be boxed. Otherwise, a
type-error is reported. For instance, calling #dyncode("swap_boxed") on
#dyncode("(0, 1)") yields a type-error as the type #dyncode("int") is not
boxed.\

")#comment("para")
")
#langja("
#para("\

多相関数はどちらかといえば関数テンプレートに似ています。
けれども、前者は ATS における第一級の値ですが後者は違います。
例として次に定義する関数 #dyncode("swap_boxed") は多相的です:

#atscode("\
fun swap_boxed{a,b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

型変数 #stacode("a") と #stacode("b") はしばしば静的引数と呼ばれ、 #dyncode("xy") は動的引数と呼ばれます。
次のコードは多相関数 #dyncode("swap_boxed") を使っています:

#atscode('\
val AB = ("A", "B")
val BA1 = swap_boxed{string,string} (AB)
val BA2 = swap_boxed (AB) // omitting type arguments may be fine
')

もし型 T1 と T2 が与えられ #stacode("swap_boxed") をタプル型 (T1, T2) に対して呼び出した場合、T1
と T2 はボックス化されていなければなりません。
そうでなければ型エラーが発生します。
例えば #dyncode("swap_boxed") を #dyncode("(0, 1)") に呼び出すと、型 #dyncode("int")
がボックス化されていないことを示す型エラーが起きます。\

")#comment("para")
")

#langeng("
#para("\

When calling a polymorphic function, we often omit passing static
arguments explicitly and expect them to be synthesized by the
compiler. However, there are also occasions, which are not uncommon, where
static arguments need to be supplied explicitly as either they cannot be
successfully synthesized or what is synthesized is not exactly what is
expected by the programmer.\

")
")
#langja("
#para("\

多相関数を呼び出す時、静的引数を省略してコンパイラによって推論されることをしばしば期待します。
けれども推論に失敗したり、推論がプログラマが意図していたものとは違っているために、明示的に静的引数を指定することが必要になることも珍しくはありません。\

")
")

#langeng("
#para("\

It is also possible to pass static arguments sequentially as is
shown in the following style of implementation of a polymorphic function:

#atscode('\
fun swap2_boxed{a:type}{b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)

val AB = ("A", "B")
val BA1 = swap2_boxed (AB) // both static arguments to be synthesized
val BA2 = swap2_boxed{...} (AB) // both static arguments to be synthesized
val BA3 = swap2_boxed{..}{string} (AB) // 1st static argument to be synthesized
val BA4 = swap2_boxed{string}{..} (AB) // 2nd static argument to be synthesized
val BA5 = swap2_boxed{..}{..} (AB) // both static arguments to be synthesized
val BA6 = swap2_boxed{string}{string} (AB) // both static arguments are provided
')

The special syntax #stacode("{..}") indicates to the typechecker that the
static argument (or arguments) involved in the current application should
be synthesized while the special syntax #stacode("{...}") means that the
rest of static arguments should all be synthesized.\

")#comment("para")
")
#langja("
#para("\

次の多相関数の実装スタイルのように、静的引数を連続して渡すことも可能です:

#atscode('\
fun swap2_boxed{a:type}{b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)

val AB = ("A", "B")
val BA1 = swap2_boxed (AB) // both static arguments to be synthesized
val BA2 = swap2_boxed{...} (AB) // both static arguments to be synthesized
val BA3 = swap2_boxed{..}{string} (AB) // 1st static argument to be synthesized
val BA4 = swap2_boxed{string}{..} (AB) // 2nd static argument to be synthesized
val BA5 = swap2_boxed{..}{..} (AB) // both static arguments to be synthesized
val BA6 = swap2_boxed{string}{string} (AB) // both static arguments are provided
')

特殊構文 #stacode("{..}") はこの適用に含まれる静的引数が推論されるべきであることを型検査器に指示します。
さらに特殊構文 #stacode("{...}") は残りの静的引数全てが推論されるべきであることを型検査器に指示します。\

")#comment("para")
")

#langeng("
#para("\

I have seen two kinds of errors involving polymorphic functions that are
extremely common in practice.

<itemizedlist>

<listitem>

#para("\
The first kind is depicted in the following example:

#atscode("\
fun swap_boxed{a,b:t@ype} (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

Notice that the sort for type variables #stacode("a") and #stacode("b") is
#stacode("t@ype") (instead of #stacode("type")). While this example can
pass typechecking, its compilation results in a compile-time error that may
seem mysterious to many programmers. The simple reason for this error is
that the compiler cannot figure out the size of #stacode("a") and
#stacode("b") when trying to generate code in C as the sort #stacode("t@ype")
is for types of unspecified size.

")#comment("para")

</listitem>

<listitem>
#para("\
The second kind is depicted in the following example:

#atscode("\
fun{a,b:type} swap_boxed (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

Strictly speaking, there is really no error in this case. If defined as
such, #stacode("swap_boxed") is a function template instead of a
polymorphic function. However, such a function template is severely
restricted as it cannot be instantiated with types that are not boxed.
While this could be intended, it is very unlikely.\

")#comment("para")

</listitem>

</itemizedlist>

Given the potential confusion, why do we need both function templates and
polymorphic functions?  At this stage, it is certainly plausible that we
program only with function templates and make no use of polymorphic
functions. However, polymorphic functions can hardly be missed in the
presence dependent types. There will actually be numerous occasions where
we encounter polymorphic function templates, that is, templates for
polymorphic functions.\

")#comment("para")
")
#langja("
#para("\


実際の場面で非常に一般的な多相関数に由来する2種類のエラーを見てます:

<itemizedlist>

<listitem>

#para("\
1番目の種類は次のような例です:

#atscode("\
fun swap_boxed{a,b:t@ype} (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

型変数 #stacode("a") と #stacode("b") の種が #stacode("type") の代わりに #stacode("t@ype")
であることに注意してください。
この例は型検査には通りますが、コンパイル時に起きるエラーは、多くのプログラマにとって不可解なものでしょう。
このエラーを発生させる単純な理由は、コンパイラが #stacode("a") と #stacode("b")
のサイズを算出できないことです。
種 #stacode("t@ype") のC言語コードを生成しようとした時、型のサイズが特定できないのです。

")#comment("para")

</listitem>

<listitem>
#para("\
2番目の種類は次のような例です:

#atscode("\
fun{a,b:type} swap_boxed (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

厳密に言えば、実際にはこの例にエラーはありません。
もしこのような定義がされると、#stacode("swap_boxed") は多相関数の代わりに関数テンプレートになります。
けれども、このような関数テンプレートはボックス化されていない型でインスタンス化できず、使用が制限されています。
これが意図したものでなければ、好ましくないでしょう。\

")#comment("para")

</listitem>

</itemizedlist>

混乱する可能性があるのに、なぜ関数テンプレートと多相関数が必要になるのでしょうか？
関数テンプレートだけを使い、多相関数を使うべきではない、というのがもちろん現時点ではもっともらしく思えます。
けれども、多相関数は依存型に強く結びついています。
多相関数のためのテンプレートである多相関数テンプレートに、実際には数多く出会うことになるでしょう。\

")#comment("para")
")

</sect1><!--id="polymorphic_functions"-->

<!-- ****** ****** -->

<sect1
id="polymorphic_datatypes">
#langeng("
#title("Polymorphic Datatypes")
")
#langja("
#title("多相データ型")
")

#langeng("
#para("\

Code sharing also applies to datatype declarations. For instance, a
commonly used polymorphic datatype #stacode("list0") is declared as follows:

#atscode("\
datatype
list0 (a:t@ype) =
  | list0_nil (a) of () | list0_cons (a) of (a, list0 a)
// end of [list0]
")

More precisely, #stacode("list0") is a type constructor. Given a type T, we
can form a type #stacode("list0(T)") for lists consisting of elements of
the type T. For instance, #stacode("list0(char)") is for character lists,
#stacode("list0(int)") for integer lists, #stacode("list0(list0(int))") for lists
whose elements are themselves integer lists, etc.  To a great extent, the
need for function templates or polymorphic functions largely stems from the
availability of polymorphic datatypes. As an example, a function template
#dyncode("list0_length") is implemented as follows for computing the length
of any given list:

#atscode("\
fun{a:t@ype}
list0_length (xs: list0 a): int =
(
  case+ xs of
  | list0_cons (_, xs) => 1 + list0_length<a> (xs) | list0_nil () => 0
) (* end of [list0_length] *)
")

When applying #dyncode("list0_length") to a list xs, we can in general
write #dyncode("list0_length(xs)"), expecting the typechecker to synthesize
a proper type parameter for #dyncode("list0_length").  We may also write
#dyncode("list0_length&lt;")#stacode("T")#dyncode("&gt;(xs)") if the
elements of xs are of the type T. The latter style, though a bit more
verbose, is likely to yield more informative messages in case type-errors
occur.

")#comment("para")
")
#langja("
#para("\

コード共有はデータ型の宣言についても適用できます。
例えば、なじみ深い多相データ型 #stacode("list0") は次のように宣言されます:

#atscode("\
datatype
list0 (a:t@ype) =
  | list0_nil (a) of () | list0_cons (a) of (a, list0 a)
// end of [list0]
")

より正確には #stacode("list0") は型コンストラクタです。
型 T が与えられた時、型 T を要素とするリストである型 #stacode("list0(T)") を作ることができます。
例えば #stacode("list0(char)") は文字のリストで、 #stacode("list0(int)") は整数のリスト、#stacode("list0(list0(int))") は整数のリストを要素とするリスト、などです。
関数テンプレートや多相関数の主な必要性は多相データ型の可用性から大いに生じています。
例として、関数テンプレート #dyncode("list0_length") は与えられたリストの長さを計算するよう、次のように実装されます:

#atscode("\
fun{a:t@ype}
list0_length (xs: list0 a): int =
(
  case+ xs of
  | list0_cons (_, xs) => 1 + list0_length<a> (xs) | list0_nil () => 0
) (* end of [list0_length] *)
")

#dyncode("list0_length") をリスト xs に適用する時、型検査器が #dyncode("list0_length") の型パラメータを適切に推論してくれることを期待して、
一般に #dyncode("list0_length(xs)") と書くことができます。
また xs の要素が型 T であるとき、#dyncode("list0_length&lt;")#stacode("T")#dyncode("&gt;(xs)") と書くこともできます。
後者のスタイルは少し冗長ですが、型エラーが発生した際により有用なメッセージが得られるため好ましいと言えます。

")#comment("para")
")

#langeng("
#para("\

Another commonly used polymorphic datatype #stacode("option0") is declared as
follows:

#atscode("\
datatype
option0 (a:t@ype) =
  | option0_none (a) of () | option0_some (a) of a
// end of [option0]
")

A typical use of #stacode("option0") is to perform some kind of
error-handling. Suppose that we are to implement a function doing integer
division and we want to make sure that the function returns even if it is
called in a case where the divisor equals 0. This can be done as follows:

#atscode("\
fun divopt
(
  x: int, y: int
) : option0 (int) =
  if y != 0 then option0_some{int}(x/y) else option0_none((*void*))
// end of [divopt]
")

By inspecting what #dyncode("divopt") returns, we can tell whether integer
division has been done normally or an error of divsion-by-zero has
occurred. A realistic use of #stacode("option0") is shown in the following
implementation of #dyncode("list0_last"):

#atscode("\
fun{
a:t@ype
} list0_last
(
  xs: list0 a
) : option0 (a) = let
//
fun loop
  (x: a, xs: list0 a): a =
(
  case+ xs of
  | list0_nil () => x | list0_cons (x, xs) => loop (x, xs)
) (* end of [loop] *)
//
in
  case+ xs of
  | list0_nil () => option0_none((*void*))
  | list0_cons (x, xs) => option0_some{a}(loop (x, xs))
end // end of [list0_last]
")

When applied to a list, #dyncode("list0_last") returns an optional
value. If the value matches the pattern #dyncode("option0_none()"), then
the list is empty. Otherwise, the value is formed by applying
#dyncode("option0_some") to the last element of the given list.\

")#comment("para")
")
#langja("
#para("\

もう一つの多相データ型の一般的な使い方 #stacode("option0") は次のような宣言です:

#atscode("\
datatype
option0 (a:t@ype) =
  | option0_none (a) of () | option0_some (a) of a
// end of [option0]
")

#stacode("option0") の典型的な使い方はエラーの取り扱いです。
整数の除算関数を実装しようとしていて、0 で除算してしまった時でも関数が返ってくることを保証したくなったとしましょう。
これは次のようにすれば可能です:

#atscode("\
fun divopt
(
  x: int, y: int
) : option0 (int) =
  if y != 0 then option0_some{int}(x/y) else option0_none((*void*))
// end of [divopt]
")

#dyncode("divopt") の返値を検査することで、整数の除算が正常終了したのか、0除算が起きてエラー終了した見分けることができます。
#stacode("option0") の実際の使用例は次の実装 #dyncode("list0_last") になります:

#atscode("\
fun{
a:t@ype
} list0_last
(
  xs: list0 a
) : option0 (a) = let
//
fun loop
  (x: a, xs: list0 a): a =
(
  case+ xs of
  | list0_nil () => x | list0_cons (x, xs) => loop (x, xs)
) (* end of [loop] *)
//
in
  case+ xs of
  | list0_nil () => option0_none((*void*))
  | list0_cons (x, xs) => option0_some{a}(loop (x, xs))
end // end of [list0_last]
")

リストに適用されると、#dyncode("list0_last") はオプション値を返します。
もしこの値がパターン #dyncode("option0_none()") にマッチすれば、このリストは空です。
そうでなければ、この値はリストの最後の要素に #dyncode("option0_some") を適用したものになります。\

")#comment("para")
")

</sect1><!--id="polymorphic_datatypes"-->

<!-- ****** ****** -->

<sect1
id="example_function_templates_on_lists">
#langeng("
#title("Example: Function Templates on Lists")
")
#langja("
#title("例: リストに対する関数テンプレート")
")

#langeng("
#para("\

In functional programming, lists are ubiquitous. We implement as follows
some commonly used function templates on lists. It should be noted that
these templates are all available in some library of ATS, where they may be
implemented in a significantly more efficient manner due to the use of
certain programming features (such as linear datatypes) that have not been
covered so far.\

")
")
#langja("
#para("\

関数型プログラミングでは、リストはどこででも使われます。
ここでは一般に使われるリストに対する関数テンプレートを実装します。
これらのテンプレートは全て、ATS のライブラリで利用できることに注意すべきです。
それらは線形データ型のようなこれまで紹介してないプログラミングの機能を使って、より効果的な方法で実装されていることがあります。\

")
")

#langeng("
#para("\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_POLYMORPH/listfuns.dats", "on-line").\

")
")
#langja("
#para("\

この章のコード全体と追加のテストコードは
#mycodelink("CHAP_POLYMORPH/listfuns.dats", "オンライン")
から入手できます。
(訳注: このコードを atscc でコンパイルする際には -DATS_MEMALLOC_LIBC オプションが必要です。
さらにATSコンパイラ本体だけではなく、ATS2-Postiats-contrib のインストールも必要です。)\

")
")

<sect2 id="list0_append">
#langeng("
#title("
Appending: #dyncode("list0_append")
")
")
#langja("
#title("
連結: #dyncode("list0_append")
")
")

#langeng("
#para("\

Given two lists xs and ys of the type #stacode("list0(T)") for some type T,
#dyncode("list0_append(xs, ys)") returns a list that is the concatenation
of xs and ys:

#atscode("\
fun{
a:t@ype
} list0_append
(
  xs: list0 a
, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_cons{a}(x, list0_append<a> (xs, ys))
| list0_nil ((*void*)) => ys
) (* end of [list0_append] *)
")

Clearly, this implementation of #dyncode("list0_append") is not
tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T と型 #stacode("list0(T)") の2つのリスト xs と ys
が与えられた時、#dyncode("list0_append(xs, ys)") は xs と ys を連結した1つのリストを返します:

#atscode("\
fun{
a:t@ype
} list0_append
(
  xs: list0 a
, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_cons{a}(x, list0_append<a> (xs, ys))
| list0_nil ((*void*)) => ys
) (* end of [list0_append] *)
")

明らかに、この #dyncode("list0_append") は末尾再帰ではありません。\

")#comment("para")
")

</sect2><!--id="list0_append"-->

<sect2
id="list0_reverse_append">
#langeng("
#title("
Reverse-Appending: #dyncode("list0_reverse_append")
")
")
#langja("
#title("
逆順連結: #dyncode("list0_reverse_append")
")
")

#langeng("
#para("\

Given two lists xs and ys of the type #dyncode("list0(T)") for some type T,
#dyncode("list0_reverse_append(xs, ys)") returns a list that is the
concatenation of the reverse of xs and ys:

#atscode("\
fun{
a:t@ype
} list0_reverse_append
(
  xs: list0 a, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_reverse_append<a> (xs, list0_cons{a}(x, ys))
| list0_nil () => ys
) (* end of [list0_reverse_append] *)
")

Clearly, this implementation of #dyncode("list0_reverse_append") is
tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T と型 #dyncode("list0(T)") の2つのリスト xs と ys が与えられた時、#dyncode("list0_reverse_append(xs, ys)") は xs と ys の逆順を連結したリストを返します:

#atscode("\
fun{
a:t@ype
} list0_reverse_append
(
  xs: list0 a, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_reverse_append<a> (xs, list0_cons{a}(x, ys))
| list0_nil () => ys
) (* end of [list0_reverse_append] *)
")

明らかに、 #dyncode("list0_reverse_append") のこの実装は末尾再帰です。\

")#comment("para")
")

</sect2><!--id="list0_reverse_append"-->

<sect2
id="list0_reverse">
#langeng("
#title("
Reversing: #dyncode("list0_reverse")
")
")
#langja("
#title("
逆順: #dyncode("list0_reverse")
")
")

#langeng("
#para("\

Given a list xs, #dyncode("list0_reverse(xs)") returns the
reverse of xs:

#atscode("\
fun{a:t@ype}
list0_reverse
  (xs: list0 a): list0 a = list0_reverse_append<a> (xs, list0_nil)
// end of [list0_reverse]
")
")#comment("para")
")
#langja("
#para("\

リスト xs が与えられた時、#dyncode("list0_reverse(xs)") は xs の逆順を返します:

#atscode("\
fun{a:t@ype}
list0_reverse
  (xs: list0 a): list0 a = list0_reverse_append<a> (xs, list0_nil)
// end of [list0_reverse]
")
")#comment("para")
")

</sect2><!--id="list0_reverse"-->

<sect2 id="list0_map">
#langeng("
#title("
Mapping: #dyncode("list0_map")
")
")
#langja("
#title("
マップ: #dyncode("list0_map")
")
")

#langeng("
#para("\

Given a list xs of the type #stacode("list0(T1)") for some type T1 and a
closure function f of the type T1 -&lt;cloref1&gt; T2 for some type T2,
#dyncode("list0_map(xs, f)") returns a list ys of the type #stacode("list0(T2)"):

#atscode("\
fun
{a:t@ype}
{b:t@ype}
list0_map
(
  xs: list0 a, f: a -<cloref1> b
) : list0 b =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_cons{b}(f x, list0_map<a><b> (xs, f))
| list0_nil ((*void*)) => list0_nil ()
) (* end of [list0_map] *)
")

The length of ys equals that of xs and each element y in ys equals f(x),
where x is the corresponding element in xs.  Clearly, this implementation
of #dyncode("list0_map") is not tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T1、型 T2、型 T1 -&lt;cloref1&gt; T2 のクロージャ関数 f、型 #stacode("list0(T1)") のリスト
xs が与えられた時、#dyncode("list0_map(xs, f)") は #stacode("list0(T2)") 型のリスト ys を返します:

#atscode("\
fun
{a:t@ype}
{b:t@ype}
list0_map
(
  xs: list0 a, f: a -<cloref1> b
) : list0 b =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_cons{b}(f x, list0_map<a><b> (xs, f))
| list0_nil ((*void*)) => list0_nil ()
) (* end of [list0_map] *)
")

ys の長さは xs の長さに等しく、ys 中のそれぞれの要素 y は xs 中の関連する要素をxとしたとき f(x) に等しくなります。
明らかに #dyncode("list0_map") のこの実装は末尾再帰ではありません。\

")#comment("para")
")

</sect2><!--id="list0_map"-->

<!-- ****** ****** -->

<sect2 id="list0_foldleft">
#langeng("
#title("Left-Folding: #dyncode("list0_foldleft")")
")
#langja("
#title("左 fold: #dyncode("list0_foldleft")")
")

#langeng("
#para('\

Given xs, ini and f, #dyncode("list0_foldleft(ini, xs, f)") computes the
value of the expression f(... f(f(ini, xs[0]), xs[1]) ..., xs[n-1]), where
n is the length of xs and xs[i] refers to element i in xs for each i &lt; n.
The following implementation of #dyncode("list0_foldleft") is tail-recursive:

#atscode('\
fun
{a:t@ype}
{b:t@ype}
list0_foldleft
(
  ini: a, xs: list0 (b), f: (a, b) -> a
) : a =
(
  case+ xs of
  | list0_cons
      (x, xs) => list0_foldleft<a><b> (f (ini, x), xs, f)
  | list0_nil ((*void*)) => ini
)
')

')
")
#langja("
#para('\

xs, ini, f が与えられた時、#dyncode("list0_foldleft(ini, xs, f)") は式 f(... f(f(ini, xs[0]), xs[1]) ..., xs[n-1]) の値を計算します。
このとき n は xs の長さで、 xs[i] は i &lt; n のような xs の i 番目の要素です。
次の #dyncode("list0_foldleft") の実装は末尾再帰です:

#atscode('\
fun
{a:t@ype}
{b:t@ype}
list0_foldleft
(
  ini: a, xs: list0 (b), f: (a, b) -> a
) : a =
(
  case+ xs of
  | list0_cons
      (x, xs) => list0_foldleft<a><b> (f (ini, x), xs, f)
  | list0_nil ((*void*)) => ini
)
')

')
")

</sect2><!--id="list0_foldleft"-->

<!-- ****** ****** -->

<sect2 id="list0_foldright">
#langeng("
#title("Right-Folding: #dyncode("list0_foldright")")
")
#langja("
#title("右 fold: #dyncode("list0_foldright")")
")

#langeng("
#para('\

Given xs, res and f, #dyncode("list0_foldright(xs, res, f)") computes the
value of the expression f(xs[0], f(xs[1], f(... f(xs[n-1], res) ...))), where
n is the length of xs and xs[i] refers to element i in xs for each i &lt; n.
The following implementation of #dyncode("list0_foldright") is not tail-recursive:

#atscode('\
fun
{a:t@ype}
{b:t@ype}
list0_foldright
(
  xs: list0 (a), res: b, f: (a, b) -> b
) : b =
(
  case+ xs of
  | list0_cons
      (x, xs) => f (x, list0_foldright<a><b> (xs, res, f))
  | list0_nil ((*void*)) => res
)
')

')
")
#langja("
#para('\

xs, res, f が与えられた時、#dyncode("list0_foldright(xs, res, f)") は式 f(xs[0], f(xs[1], f(... f(xs[n-1], res) ...))) の値を計算します。
このとき n は xs の長さで、 xs[i] は i &lt; n のような xs の i 番目の要素です。
次の #dyncode("list0_foldright") 実装は末尾再帰ではありません:

#atscode('\
fun
{a:t@ype}
{b:t@ype}
list0_foldright
(
  xs: list0 (a), res: b, f: (a, b) -> b
) : b =
(
  case+ xs of
  | list0_cons
      (x, xs) => f (x, list0_foldright<a><b> (xs, res, f))
  | list0_nil ((*void*)) => res
)
')

')
")

</sect2><!--id="list0_foldright"-->

<!-- ****** ****** -->

<sect2 id="list0_zip">
#langeng("
#title("Zipping: #dyncode("list0_zip")")
")
#langja("
#title("zip 関数: #dyncode("list0_zip")")
")

#langeng("
#para("\

Given two lists xs and ys of the types #stacode("list0(T1)") and
#stacode("list0(T2)") for some types T1 and T2, respectively,
#dyncode("list0_zip(xs, ys)") returns a list zs of the type #stacode("list0
@(T1, T2)"):

#atscode("\
fun{
a,b:t@ype
} list0_zip
(
  xs: list0 a
, ys: list0 b
) : list0 @(a, b) = let
  typedef ab = @(a, b)
in
//
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =>
  (
    list0_cons{ab}((x, y), list0_zip<a,b> (xs, ys))
  )
| (_, _) => list0_nil ()
//
end // end of [list0_zip]
")

The length of zs is the minimum of the lengths of xs and ys and each
element z in zs equals @(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
#dyncode("list0_zip") is not tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T1 と T2、型 #stacode("list0(T1)") と #stacode("list0(T2)") の2つのリスト xs と ys
がそれぞれ与えられた時、#dyncode("list0_zip(xs, ys)") は型 #stacode("list0 @(T1, T2)")
のリスト zs を返します:

#atscode("\
fun{
a,b:t@ype
} list0_zip
(
  xs: list0 a
, ys: list0 b
) : list0 @(a, b) = let
  typedef ab = @(a, b)
in
//
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =>
  (
    list0_cons{ab}((x, y), list0_zip<a,b> (xs, ys))
  )
| (_, _) => list0_nil ()
//
end // end of [list0_zip]
")

zs の長さは xs と ys の長さの小さい方になり、zs のそれぞれの要素 z は x と y をそれぞれ xs と ys
の対応する要素としたときの @(x, y) に等しくなります。
明らかに、この #dyncode("list0_zip") の実装は末尾再帰ではありません。\

")#comment("para")
")

</sect2><!--id="list0_zip"-->

<sect2 id="list0_zipwith">
#langeng("
#title("
Zipping with: #dyncode("list0_zipwith")
")
")
#langja("
#title("
zip with 関数: #dyncode("list0_zipwith")
")
")

#langeng("
#para("\

Given two lists xs and ys of the types #stacode("list0(T1)") and
#stacode("list0(T2)") for some types T1 and T2, respectively, and a closure
function f of the type (T1, T2) -&lt;cloref1&gt; T3 for some type T3,
#dyncode("list0_zipwith(xs, ys, f)") returns a list zs of the type
#stacode("list0(T3)"):

#atscode("\
fun
{a,b:t@ype}
{c:t@ype}
list0_zipwith
(
  xs: list0 a
, ys: list0 b
, f: (a, b) -<cloref1> c
) : list0 c =
(
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =>
  (
    list0_cons{c}(f (x, y), list0_zipwith<a,b><c> (xs, ys, f))
  )
| (_, _) => list0_nil ()
) (* end of [list0_zipwith] *)
")

The length of zs is the minimum of the lengths of xs and ys and each
element z in zs is f(x, y), where x and y are the corresponding elements in
xs and ys, respectively.  Clearly, this implementation of
#dyncode("list0_zipwith") is not tail-recursive.  Note that
#dyncode("list0_zipwith") behaves exactly like #dyncode("list0_zip") if its
third argument #dyncode("f") is replaced with #dyncode("lam (x, y) => @(x, y)").
This function template is also named #dyncode("list0_map2") for the obvious
reason.\

")#comment("para")
")
#langja("
#para("\

型 T1, T2, T3 と、型 (T1, T2) -&lt;cloref1&gt; T3 のクロージャ関数 f
と、#stacode("list0(T1)") と #stacode("list0(T2)")  型の2つのリスト xs と ys
がそれぞれ与えられた時、#dyncode("list0_zipwith(xs, ys, f)") は #stacode("list0(T3)")
型のリスト zs を返します:

#atscode("\
fun
{a,b:t@ype}
{c:t@ype}
list0_zipwith
(
  xs: list0 a
, ys: list0 b
, f: (a, b) -<cloref1> c
) : list0 c =
(
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =>
  (
    list0_cons{c}(f (x, y), list0_zipwith<a,b><c> (xs, ys, f))
  )
| (_, _) => list0_nil ()
) (* end of [list0_zipwith] *)
")

zs の長さは xs と ys の長さの小さい方になり、zs のそれぞれの要素 z は x と y をそれぞれ
xs と ys の対応する要素としたときの f(x, y) に等しくなります。
明らかに、この #dyncode("list0_zipwith") の実装は末尾再帰ではありません。
3番目の引数 #dyncode("f") を #dyncode("lam (x, y) => @(x, y)")
で置き換えれば、#dyncode("list0_zipwith") は #dyncode("list0_zip")
とまったく同じ振る舞いをすることに注意してください。
この関数テンプレートは #dyncode("list0_map2") という名前も持っています。\

")#comment("para")
")

</sect2><!--id="list0_zipping_with"-->

</sect1><!--id="example_function_templates_on_lists"-->

<!-- ****** ****** -->

<sect1 id="example_mergesort" xreflabel="implementation of mergesort on lists">

#langeng("
#title("Example: Mergesort on Lists")
")
#langja("
#title("例: リストのマージソート")
")

#langeng("
#para("\

Mergesort is simple sorting algorithm that is guaranteed to be log-linear.
It is stable in the sense that the order of two equal elements always stay
the same after sorting. I give as follows a typical functional style of
implementation of mergesort on lists.

")
")
#langja("
#para("\

マージソートは最悪計算量 O(n log n) の単純なソートアルゴリズムです。
2つの等しい要素がソートした後でも同じ配置であるという意味で安定です。
ここではリストに対するマージソートの典型的な関数型スタイルの実装を示します。

")
")

#langeng("
#para('\

First, let us introduce abbreviations
for the list constructors #dyncode("list0_nil") and #dyncode("list0_cons"):

#atscode("\
\#define :: list0_cons // writing [::] for list0_cons
\#define cons0 list0_cons // writing [cons0] for list0_cons
\#define nil0 list0_nil // writing [nil0] for list0_nil
")

Note that the operator #dyncode("::") is already given the infix status.
For instance, the list consisting of the first 5 natural numbers can be
constructed as follows:

#atscode("\
cons0 (0, cons0 (1, 2 :: 3 :: 4 :: nil0 ()))
")

In practice, there is of course no point in mixing #dyncode("cons0")
with #dyncode("::").

')#comment("para")
")
#langja("
#para('\

はじめに、リストコンストラクタ #dyncode("list0_nil") と #dyncode("list0_cons") の省略形を導入しましょう:

#atscode("\
\#define :: list0_cons // writing [::] for list0_cons
\#define cons0 list0_cons // writing [cons0] for list0_cons
\#define nil0 list0_nil // writing [nil0] for list0_nil
")

演算子 #dyncode("::") は既に中置に設定されていることに注意してください。
例えば、自然数のはじめの5個からなるリストは次のようにコンストラクトできます:

#atscode("\
cons0 (0, cons0 (1, 2 :: 3 :: 4 :: nil0 ()))
")

もちろん実際には、#dyncode("cons0") と #dyncode("::") を混ぜる意味はありません。

')#comment("para")
")

#langeng("
#para("\

We next implement a function template #dyncode("merge") to merge two given
ordered lists into a single ordered one:

#atscode("\
typedef
lte (a:t@ype) = (a, a) -> bool

fun{
a:t@ype
} merge (
  xs: list0 a, ys: list0 a, lte: lte a
) : list0 a =
(
  case+ xs of
  | cons0 (x, xs1) => (
    case+ ys of
    | cons0 (y, ys1) =>
        if x \lte y then
          cons0{a}(x, merge<a> (xs1, ys, lte))
        else
          cons0{a}(y, merge<a> (xs, ys1, lte))
        // end of [if]
    | nil0 () => xs
    ) // end of [cons0]
  | nil0 () => ys
) (* end of [merge] *)
")

For instance, suppose that the two given lists are (1, 3, 4, 8) and (2, 5,
6, 7, 9), and the comparison function (the third argument of
#dyncode("merge")) is the standard less-than-or-equal-to function on
integers. Then the list returned by #dyncode("merge") is (1, 2, 3, 4, 5, 6,
7, 8, 9). The syntax #dyncode("\lte") means that the particular occurrence
of #dyncode("lte") following the backslash symbol (#dyncode("\\\\")) is
given the infix status, and thus the expression #dyncode("x \\\\lte y")
means the same as #dyncode("lte(x, y)").\

")#comment("para")
")
#langja("
#para("\

次に、与えられた2つの整列されたリストを1つの整列されたリストにマージする関数テンプレート
#dyncode("merge") を実装します:

#atscode("\
typedef
lte (a:t@ype) = (a, a) -> bool

fun{
a:t@ype
} merge (
  xs: list0 a, ys: list0 a, lte: lte a
) : list0 a =
(
  case+ xs of
  | cons0 (x, xs1) => (
    case+ ys of
    | cons0 (y, ys1) =>
        if x \lte y then
          cons0{a}(x, merge<a> (xs1, ys, lte))
        else
          cons0{a}(y, merge<a> (xs, ys1, lte))
        // end of [if]
    | nil0 () => xs
    ) // end of [cons0]
  | nil0 () => ys
) (* end of [merge] *)
")

例えば、与えられた2つのリストが (1, 3, 4, 8) と (2, 5, 6, 7, 9) だと考えてみましょう。
#dyncode("merge") の第3引数である比較関数は整数の小なりイコール (less-than-or-equal-to) 関数です。
すると #dyncode("merge") はリスト (1, 2, 3, 4, 5, 6, 7, 8, 9) を返します。
構文 #dyncode("\lte") はほぼ #dyncode("lte") と同じ意味をしていますが、バックスラッシュ記号
(#dyncode("\\\\")) を前に付けるとは中置設定になります。
したがって式 #dyncode("x \\\\lte y") は #dyncode("lte(x, y)") と同じ意味です。\

")#comment("para")
")

#langeng("
#para("\

The following function template #dyncode("mergesort") implements the
standard mergesort algorithm:

#atscode("\
fun{
a:t@ype
} mergesort
(
  xs: list0 a, lte: lte a
) : list0 a = let
//
val n = list0_length<a> (xs)
//
fun msort
(
  xs: list0 a, n: int, lte: lte a
) : list0 a =
  if n >= 2 then split (xs, n, lte, n/2, nil0) else xs
//
and split
(
  xs: list0 a, n: int, lte: lte a, i: int, xsf: list0 a
) : list0 a =
  if i > 0 then let
    val-cons0 (x, xs) = xs
  in
    split (xs, n, lte, i-1, cons0{a}(x, xsf))
  end else let
    val xsf = list0_reverse<a> (xsf) // make sorting stable!
    val xsf = msort (xsf, n/2, lte) and xs = msort (xs, n-n/2, lte)
  in
    merge<a> (xsf, xs, lte)
  end // end of [if]
//
in
  msort (xs, n, lte)
end // end of [mergesort]
")#comment("atscode")

Suppose we want to sort the list (8, 3, 4, 1, 2, 7, 6, 5, 9); we first
divide it into two lists: (8, 3, 4, 1) and (2, 7, 6, 5, 9); by performing
mergesort on each of them, we obtain two ordered lists: (1, 3, 4, 8) and
(2, 5, 6, 7, 9); by merging these two ordered list, we obtain the ordered
list (1, 2, 3, 4, 5, 6, 7, 8, 9), which is a permutation of the original
list (8, 3, 4, 1, 2, 7, 6, 5, 9).\

")#comment("para")
")
#langja("
#para("\

次の関数テンプレート #dyncode("mergesort") は標準のマージソートアルゴリズムを実装しています:

#atscode("\
fun{
a:t@ype
} mergesort
(
  xs: list0 a, lte: lte a
) : list0 a = let
//
val n = list0_length<a> (xs)
//
fun msort
(
  xs: list0 a, n: int, lte: lte a
) : list0 a =
  if n >= 2 then split (xs, n, lte, n/2, nil0) else xs
//
and split
(
  xs: list0 a, n: int, lte: lte a, i: int, xsf: list0 a
) : list0 a =
  if i > 0 then let
    val-cons0 (x, xs) = xs
  in
    split (xs, n, lte, i-1, cons0{a}(x, xsf))
  end else let
    val xsf = list0_reverse<a> (xsf) // make sorting stable!
    val xsf = msort (xsf, n/2, lte) and xs = msort (xs, n-n/2, lte)
  in
    merge<a> (xsf, xs, lte)
  end // end of [if]
//
in
  msort (xs, n, lte)
end // end of [mergesort]
")#comment("atscode")

リスト (8, 3, 4, 1, 2, 7, 6, 5, 9) をソートしてみましょう;
はじめに2つのリストに分割します:
(8, 3, 4, 1) と (2, 7, 6, 5, 9) です;
これらそれぞれにマージソートをほどこすことで、2つの整列されたリストが得られます:
(1, 3, 4, 8) と (2, 5, 6, 7, 9) です;
これら2つの整列済みリストをマージして、整列済みリスト (1, 2, 3, 4, 5, 6, 7, 8, 9) が得られます。
これは元のリスト (8, 3, 4, 1, 2, 7, 6, 5, 9) の置換になっています。\

")#comment("para")
")

#langeng("
#para("\

Note that the function template #dyncode("merge") is not tail-recursive as
the call to #dyncode("merge") in its body is not a tail-call. This can be a
serious problem in practice: It is almost certain that a stack overflow is
to occur if the above implementation of mergesort is employed to sort a
list that is very long (e.g., containing 1,000,000 elements or more). I
will later give a tail-recursive implementation of the #dyncode("merge")
function in ATS that makes use of linear types.  ")
")
#langja("
#para("\

関数テンプレート #dyncode("merge") は末尾再帰ではないことに注意してください。
#dyncode("merge") 本体の自分自身の呼び出しが末尾呼出ではありません。
これは実際の使用において大きな問題です:
上記のマージソートの実装がとても長いリスト (例えば1,000,000以上の要素を含む)
のソートに対して呼び出されたら、スタックオーバーフローが引き起こされることは疑う余地がありません。
後の章で、ATS の線形型を使って #dyncode("merge") 関数の末尾再帰的実装を紹介します。
")
")

#langeng("
#para("\

Please find the entire code in this section plus some additional code for
testing #mycodelink("CHAP_POLYMORPH/mergesort.dats", "on-line").\

")
")
#langja("
#para("\

この章のコード全体と追加のテストコードは
#mycodelink("CHAP_POLYMORPH/mergesort.dats", "オンライン")
から入手できます。\

")
")

</sect1><!--id="example_mergesort"-->

</chapter><!--id="parametric_polymorphism"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
