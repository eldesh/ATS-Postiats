%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="functions">
#langeng("
#title("Functions")
")
#langja("
#title("関数")
")

#langeng("
#para("\

Functions play a foundational role in programming.  While it may be
theoretically possible to program without functions (but with loops), such
a programming style is of little practical value. ATS does provide some
language constructs for implementing for-loops and while-loops directly. I,
however, strongly recommend that the programmer implement loops as
recursive functions or more precisely, as tail-recursive functions. This is
a programming style that matches well with more advanced programming
features in ATS, which will be presented in this book later.\

")
")
#langja("
#para("\

関数はプログラミングの基盤です。
理論上、関数を使わずループを使ってプログラムを作ることは可能です。
けれどそのようなプログラミングスタイルは現実的ではないでしょう。
ATS は他の言語と同様に for ループや while ループを直接実装できます。
けれども私としては、再帰呼出もしくはよりよい末尾再帰呼出によって、
プログラマにループを実装してほしいと考えています。
このプログラミングスタイルは ATS のより進んだプログラミングの特徴とうまく調和できるからです。
そのような特徴はより先のページで紹介します。\

")
")

#langeng("
#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_FUNCTION/", "on-line").\

")
")
#langja("
#para("\

この章に出てくるコードとテストのための追加コードは
#mycodelink("CHAP_FUNCTION/", "オンライン")
から得られます。
")
")

<sect1
id="functions-as-a-simple-form-of-abstraction">
#langeng("
#title("Functions as a Simple Form of Abstraction")
")
#langja("
#title("単純な抽象としての関数")
")

#langeng("
#para("Given an expression exp of the type #dyncode("double"), we can
multiply exp by itself to compute its square. If exp is a complex
expression, we may introduce a binding between a name and exp so that exp
is only evaluated once. This idea is shown in the following example:

#atscode("\
let val x = 3.14 * (10.0 - 1.0 / 1.4142) in x * x end
")

Now suppose that we have found a more efficient way to do squaring. In
order to take full advantage of it, we need to modify each occurrence of
squaring in the current program accordingly. This style of programming is
clearly not modular, and it is of little chance to scale. To address this
problem, we can implement a function as follows to compute the square of a
given floating point number:

#dats2xhtml("\
fn square (x: double): double = x * x
")

The keyword #dyncode("fn") initiates the definition of a non-recursive
function, and the name following it is for the function to be defined.  In
the above example, the function #dyncode("square") takes one argument of
the name #dyncode("x"), which is assumed to have the type
#dyncode("double"), and returns a value of the type
#dyncode("double"). The expression on the right-hand side (RHS) of the
symbol #dyncode("=") is the body of the function, which is #dyncode("x *
x") in this case. If we have a more efficient way to do squaring, we
can just re-implement the body of the function #dyncode("square")
accordingly to take advantage of it, and there is no other changes needed
(assuming that squaring is solely done by calling #dyncode("square")).
")#comment("para")
")
#langja("
#para("#dyncode("double") 型である式が与えられた時、
その式を自分自身と掛け合わせることで二乗を計算することができます。
もしその式が複雑な式であるなら、その評価を一度きりにするためにその式に名前を付けることができます。
例えば次のような例です:

#atscode("\
let val x = 3.14 * (10.0 - 1.0 / 1.4142) in x * x end
")

二乗を取るもっと良い方法が見つかったと想像してみましょう。
この方法の恩恵を受けるには、
プログラム中の二乗しているコードをそれぞれ修正しなければなりません。
このようなプログラミングスタイルは明らかにモジュラリティを欠いています。
この問題に対処するために、
次のような関数を実装することで任意の浮動小数点数の二乗を計算できます:

#dats2xhtml("\
fn square (x: double): double = x * x
")

#dyncode("fn") キーワードは再帰をしない関数を定義を開始します。
そしてキーワードに続く名前は関数名です。
先の例の場合、 #dyncode("square") 関数は #dyncode("x") という名前の引数を一つ取ります。
この引数の型は #dyncode("double") で、返値の型も #dyncode("double") です。
シンボル #dyncode("=") の右辺 (right-hand side - RHS) の式が関数の中身です。
この場合は #dyncode("x * x") になります。
二乗を取るより良い方法が見つかったら、
#dyncode("square") 関数の中身を再実装するだけで済みます。
それ以外の修正は不要です。
(二乗を取るときには単に #dyncode("square") を呼び出しているからです。)
")#comment("para")
")

#langeng("
#para("\

If #dyncode("square") is a name, what is the expression it refers to? It
turns out that the above function definition can also be written as
follows:

#dats2xhtml("\
val square = lam (x: double): double => x * x
")

where the RHS of the symbol #dyncode("=") is a lambda-expression
representing an anonymous function that takes one argument of the type
#dyncode("double") and returns a value of the type #dyncode("double"),
and the expression following the symbol #dyncode("=>") is the body of the
function. If we wish, we can change the name of the function argument as
follows:

#dats2xhtml("\
val square = lam (y: double): double => y * y
")

This is called alpha-renaming (of function arguments), and the new
lambda-expression is said to be alpha-equivalent to the original one.\

")#comment("para")
")
#langja("
#para("\

#dyncode("square") が名前だとすれば、それが参照する式とは何なのでしょうか？
上の関数定義は次のように書くこともできることがわかります:

#dats2xhtml("\
val square = lam (x: double): double => x * x
")

ここで #dyncode("=") 記号の右辺はラムダ式で、#dyncode("double")
型の引数を1つ取り、#dyncode("double") 型の値を返す無名関数を表わしています。
そして #dyncode("=>") 記号に続く式が関数の本体です。
もし望むなら、関数の引数名を次のように変更することができます:

#dats2xhtml("\
val square = lam (y: double): double => y * y
")

これは (関数の引数の) α-変換と呼ばれ、
新しくできたラムダ式は元の式に対するα-同値と呼ばれます。\

")#comment("para")
")

#langeng("
#para("\

A lambda-expression is a (function) value. Suppose we have a
lambda-expression representing a binary function, that is, a function
taking two arguments. In order to assign a type of the form (T1, T2) -> T
to the lambda-expression, we need to verify that the body of the function
can be given the type T if the two arguments of the function are assumed to
have the types T1 and T2.
What is stated also applies, #emphasis("mutatis mutandis"), to
lambda-expressions representing functions of fewer or more arguments. For
instance, the lambda-expression #dyncode("lam (x: double): double => x *
x") can be assigned the function type #dyncode("(double) -> double"), which
may also be written as #dyncode("double -> double").\

")#comment("para")
")
#langja("
#para("\

ラムダ式は (関数の) 値です。
2引数の関数を表わすラムダ式があるとします。
(T1, T2) -> T の型をラムダ式に割り当てるためには、
関数の2つの引数が型 T1 と T2 を持つと仮定した時、
関数の本体が型 T であるかどうか証明しなければなりません。
適用する箇所を<emphasis>変更すると</emphasis>、
より少ないもしくはより多い引数を取る関数を表わすラムダ式になります。
例えば、ラムダ式 #dyncode("lam (x: double): double => x * x") は関数の型 #dyncode("(double) -> double")
を割り当てることができます。
この型は #dyncode("double -> double") と書くこともできます。\

")#comment("para")
")

#langeng("
#para("\

Assume that exp is an expression of some function type (T1, T2) -> T. Note
that exp is not necessarily a name or a lambda-expression. If expressions
exp<subscript>1</subscript> and exp<subscript>2</subscript> can be assigned
the types T1 and T2, then the function application
exp(exp<subscript>1</subscript>, exp<subscript>2</subscript>), which may
also be referred to as a function call, can be assigned the type T.  Typing
a function application of fewer or more arguments is handled similarly.\

")#comment("para")
")
#langja("
#para("\

exp は関数の型 (T1, T2) -> T の式であると仮定します。
exp は名前を持つ関数やラムダ式である必要はないことに注意してください。
式 exp<subscript>1</subscript> と exp<subscript>2</subscript> に型 T1 と T2 が割り当て可能だとすると、
関数適用 exp(exp<subscript>1</subscript>, exp<subscript>2</subscript>) には型 T を割り当てることができます
(この関数適用も関数呼び出しであるかもしれません)。
より少ないもしくはより多い引数の関数適用の型付けも同様です。\

")#comment("para")
")

#langeng("
#para("Let us now see an example that builds on the previously defined
function #dyncode("square"). The boundary of a ring consists of two
circles centered at the same point. If the radii of the outer and inner
circles are R and r, respectively, then the area of the ring can be
computed by the following function #dyncode("area_of_ring"):

#dats2xhtml("\
fn area_of_ring
  (R: double, r: double): double = 3.1416 * (square(R) - square(r))
// end of [area_of_ring]
")

Note that the subtraction and multiplication functions
are of the type #dyncode("(double, double) -> double")
and #dyncode("square") is of the type #dyncode("(double) ->
double"). It is thus a simple routine to verify that the body of
#dyncode("area_of_ring") can be assigned the type #dyncode("double").\

")#comment("para")
")
#langja("
#para("前に定義した関数 #dyncode("square") を使った例を見てみましょう。
2つの円から成り立つリングの境界線は同じ点を中心としています。
外側と内側の円の半径をそれぞれ R と r とすると、
リングの面積は次の関数 #dyncode("area_of_ring") で計算できます:

#dats2xhtml("\
fn area_of_ring
  (R: double, r: double): double = 3.1416 * (square(R) - square(r))
// end of [area_of_ring]
")

浮動小数点数の減算と乗算の関数が型 #dyncode("(double, double) -> double") で、
#dyncode("square") が型 #dyncode("(double) -> double") で与えられた時、
#dyncode("area_of_ring") の本体に型 #dyncode("double") を割り当てられることは、単純な方法で検査できます。\

")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="function-arity">
#langeng("
#title("Function Arity")
")
#langja("
#title("関数のアリティ (arity)")
")

#langeng("
#para("\

The arity of a function is the number of arguments the function
takes.  Functions of arity 0, 1, 2 and 3 are often called nullary, unary,
binary and ternary functions, respectively. For example, the following
function #dyncode("sqrsum1") is a binary function such that its two
arguments are of the type #dyncode("int"):

#dats2xhtml("\
fn sqrsum1 (x: int, y: int): int = x * x + y * y
")

We can define a unary function #dyncode("sqrsum2") as follows:
#dats2xhtml("\
//
typedef int2 = (int, int)
//
fn sqrsum2
  (xy: int2): int =
  let val x = xy.0 and y = xy.1 in x * x + y * y end
// end of [sqrsum2]
")

The keyword #stacode("typedef") introduces a binding between the name
#stacode("int2") and the tuple type #stacode("(int, int)"). In other words,
#stacode("int2") is treated as an abbreviation or alias for #stacode("(int,
int)"). The function #dyncode("sqrsum2") is unary as it takes only one
argument, which is a tuple of the type #stacode("int2").  When applying
#dyncode("sqrsum2") to a tuple consisting of #dyncode("1") and
#dyncode("~1"), we need to write #dyncode("sqrsum2 @(1, ~1)"). If we simply
write #dyncode("sqrsum2 (1, ~1)"), then the typechecker is to report an
error of function arity mismatch as it assumes that #dyncode("sqrsum2") is
applied to two arguments (instead of one representing a pair).\

")#comment("para")
")
#langja("
#para("\

関数のアリティは関数が取る引数の数です。
しばしばアリティが 0, 1, 2, 3 の関数はそれぞれ、nullary, unary, binary, ternary 関数と呼ばれます。
例えば、次の関数 #dyncode("sqrsum1") は binary 関数で、2つの引数の型は #dyncode("int") です:

#dats2xhtml("\
fn sqrsum1 (x: int, y: int): int = x * x + y * y
")

unary関数 #dyncode("sqrsum2") を次のように定義することができます:
#dats2xhtml("\
//
typedef int2 = (int, int)
//
fn sqrsum2
  (xy: int2): int =
  let val x = xy.0 and y = xy.1 in x * x + y * y end
// end of [sqrsum2]
")

キーワード #stacode("typedef") は名前 #stacode("int2") とタプル型 #stacode("(int, int)") を束縛します。
別の言い方をすると #stacode("int2") は #stacode("(int, int)") の略語しくは別名として取り扱われます。
関数 #dyncode("sqrsum2") は #stacode("int2") 型のタプルを引数として1つだけ取るunaryです。
#dyncode("sqrsum2") を #dyncode("1") と #dyncode("~1") から成るタプルに適用するには、
#dyncode("sqrsum2 @(1, ~1)") と書く必要があります。
もし単純に #dyncode("sqrsum2 (1, ~1)") と書いた場合、
型検査器は関数のアリティが合わないというエラーを出力します。
型検査器は #dyncode("sqrsum2") に (1つのペアではなく) 2つの引数が適用されたと見なしてしまうためです。\

")#comment("para")
")

#langeng("
#para("\

Many functional languages (e.g., Haskell and ML) only allow unary
functions. A function of multiple arguments is encoded in these languages
as a unary function taking a tuple as its only argument or it is curried
into a function that takes these arguments sequentially. ATS, however,
provides direct support for functions of multiple arguments. There is even
some limited support in ATS for variadic functions, that is, functions of
indefinite number of arguments (e.g., the famous #dyncode("printf")
function in C). This is a topic I will cover elsewhere.\

")#comment("para")
")
#langja("
#para("\

(Haskell や ML のような) 多くの関数型言語は unary 関数のみを許しています。
これらの言語において、複数の引数を取る関数はエンコードして表現します。
つまり、タプルを唯一の引数として取る unary 関数か、
カリー化された関数に連続してそれらの引数を渡すようにして実現されています。
けれども、ATS は複数引数を持つ関数を直接サポートしています。
ATS でも可変長引数の関数を限定的にサポートしています。
これはつまり引数の数が不定の関数です (例えばC言語の #dyncode("printf") 関数が有名です)。
この話題は別の章で取り上げます。\

")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="function-interface">
#langeng("
#title("Function Interface")
")
#langja("
#title("関数インターフェイス")
")

#langeng("
#para("\

The interface for a function specifies the type assigned to the
function. Given a binary function foo of the type (T1, T2) -> T3, its
interface can be written as follows:

#sats2xhtml("\
fun foo (arg1: T1, arg2: T2): T3
")

where #dyncode("arg1") and #dyncode("arg2") may be replaced with any
other legal identifiers for function arguments.  For functions of more or
fewer arguments, interfaces can be written in a similar fashion.  For
instance, we have the following interfaces for various functions on
integers:

#sats2xhtml("\
fun succ_int (x: int): int // successor
fun pred_int (x: int): int // predecessor

fun add_int_int (x: int, y: int): int // +
fun sub_int_int (x: int, y: int): int // -
fun mul_int_int (x: int, y: int): int // *
fun div_int_int (x: int, y: int): int // /

fun mod_int_int (x: int, y: int): int // modulo
fun gcd_int_int (x: int, y: int): int // greatest common divisor

fun lt_int_int (x: int, y: int): bool // <
fun lte_int_int (x: int, y: int): bool // <=
fun gt_int_int (x: int, y: int): bool // >
fun gte_int_int (x: int, y: int): bool // >=
fun eq_int_int (x: int, y: int): bool // =
fun neq_int_int (x: int, y: int): bool // <>

fun max_int_int (x: int, y: int): int // maximum
fun min_int_int (x: int, y: int): int // minimum

fun print_int (x: int): void
fun tostring_int (x: int): string
")

For now, I mostly use function interfaces for the purpose of presenting
functions.  I will show later how a function definition can be separated
into two parts: a function interface and an implementation that implements
the function interface. Note that separation as such is pivotal for
constructing (large) programs in a modular style.\

")#comment("para")
")
#langja("
#para("\

関数のインターフェイスは、その関数に割り当てられる型を明確にします。
binary 関数 foo が型 (T1, T2) -> T3 で与えられた時、そのインターフェイスは次のように書くことができます:

#sats2xhtml("\
fun foo (arg1: T1, arg2: T2): T3
")

ここで #dyncode("arg1") と #dyncode("arg2") は関数の引数に対する他の識別子で置換することもできます。
より多いもしくは少ない引数の関数でも、インターフェイスは同じように書くことができます。
例えば、次のような様々な整数に対する関数のインターフェイスがあります:

#sats2xhtml("\
fun succ_int (x: int): int // successor
fun pred_int (x: int): int // predecessor

fun add_int_int (x: int, y: int): int // +
fun sub_int_int (x: int, y: int): int // -
fun mul_int_int (x: int, y: int): int // *
fun div_int_int (x: int, y: int): int // /

fun mod_int_int (x: int, y: int): int // modulo
fun gcd_int_int (x: int, y: int): int // greatest common divisor

fun lt_int_int (x: int, y: int): bool // <
fun lte_int_int (x: int, y: int): bool // <=
fun gt_int_int (x: int, y: int): bool // >
fun gte_int_int (x: int, y: int): bool // >=
fun eq_int_int (x: int, y: int): bool // =
fun neq_int_int (x: int, y: int): bool // <>

fun max_int_int (x: int, y: int): int // maximum
fun min_int_int (x: int, y: int): int // minimum

fun print_int (x: int): void
fun tostring_int (x: int): string
")

これ以降、関数を提示するときに関数インターフェイスを使います。
後の章で、関数定義は2つの部品に分離できることを示します:
関数インターフェイス部分と関数インターフェイスを実装する実装部分です。
この分離は大きなプログラムをモジュールスタイルで作るのにきわめて重要であることに注意してください。\

")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="evaluation-of-function-calls">
#langeng("
#title("Evaluation of Function Calls")
")
#langja("
#title("関数呼び出しの評価")
")

#langeng("
#para("\

Evaluating a function call is straightforward. Assume that we are to
evaluate the function call #dyncode("abs(0.0 - 1.0)") under some
environment ENV0, where the function #dyncode("abs") is defined as follows:

#dats2xhtml("\
fn abs (x: double): double = if x >= 0.0 then x else ~x
")

We first evaluate the argument of the call to #dyncode("~1.0") under ENV0;
we then extend ENV0 to ENV1 with a binding between #dyncode("x") and
#dyncode("~1.0") and start to evaluate the body of #dyncode("abs") under
ENV1; we evaluate the test #dyncode("x >= 0") to #dyncode("~1.0 >= 0") and
then to #dyncode("false"), which indicates that we take the else-branch
#dyncode("~x") to continue; we evaluate #dyncode("~x") to
#dyncode("~(~1.0)") and then to #dyncode("1.0"); so the evaluation of the
function call #dyncode("abs(0.0 - 1.0)") returns #dyncode("1.0").\

")#comment("para")
")
#langja("
#para("\

関数呼び出しの評価は単純です。
関数 #dyncode("abs") が次のように定義されていて、
関数呼び出し #dyncode("abs(0.0 - 1.0)") を環境 ENV0 の下で評価することを考えてみましょう:

#dats2xhtml("\
fn abs (x: double): double = if x >= 0.0 then x else ~x
")

まずはじめに ENV0 の下で呼び出しの引数を評価して #dyncode("~1.0") を得ます;
#dyncode("x") と #dyncode("~1.0") を束縛して ENV0 を ENV1 に拡張します、
そして ENV1 の下で #dyncode("abs") 本体の評価を開始します;
判定 #dyncode("x >= 0") を #dyncode("~1.0 >= 0") に評価してさらに #dyncode("false") にします、これはelseブランチ #dyncode("~x") に実行を続けることを示しています;
#dyncode("~x") を #dyncode("~(~1.0)") 評価してさらに #dyncode("1.0") にします;
そして関数呼び出し #dyncode("abs(0.0 - 1.0)") の評価は #dyncode("1.0") を返します。\

")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="recursive-functions">
#langeng("
#title("Recursive Functions")
")
#langja("
#title("再帰関数")
")

#langeng("
#para("\

A recursive function is one that may make calls to itself in its body. In
ATS, the keyword #keycode("fun") is used to initiate the definition of a
recursive function.  Clearly, a non-recursive function is just a special
kind of recursive function: the kind that does not make any calls to itself
in its body. If one prefers, one can use #keycode("fun") (instead of
#keycode("fn")) to initiate the definition of a non-recursive function.\

")

#para("\

I consider recursion the most enabling feature a programming language can
provide. With recursion, we are enabled to do problem-solving based on a
strategy of reduction: In order to solve a problem to which a solution is
difficult to find immediately, we reduce the problem to problems that are
#emphasis("similar") but #emphasis("simpler"), and we repeat this
reduction process if needed until solutions become apparent. Let us now see
some concrete examples of problem-solving that make use of this reduction
strategy.\

")#comment("para")
")
#langja("
#para("\
再帰関数はその本体で自分自身を呼び出すような関数です。
したがって、再帰しない関数は再帰関数の単なる特殊形であるとも言えます:
この種の関数はその本体で自分自身を決して呼び出しません。
再帰はプログラミング言語が提供しているもっとも効果的な機能だと、私は考えています。
再帰を使うことで、再帰的な戦略で問題解決をすることができます:
すぐに解法を見つけることが困難な問題を解決するために、
問題を同様な単純な問題に減少させ、
さらに解法が明白になるまでその減少プロセスを繰り返します。
ここでは
このような減少戦略を使った問題解決の具体的な例を見てみましょう。
")#comment("para")
")

#langeng("
#para("\
Suppose that we want to sum up all the integers ranging from 1 to n,
where n is a given integer. This can be readily done by implementing the
following recursive function #dyncode("sum1"):

#dats2xhtml("\
fun sum1
  (n: int): int =
  if n >= 1 then sum1 (n-1) + n else 0
// end of [sum1]
")

To find out the sum of all the integers ranging from #dyncode("1") to
#dyncode("n"), we call #dyncode("sum1 (n)"). The reduction strategy for
#dyncode("sum1 (n)") is straightforward: If #dyncode("n") is greater than
#dyncode("1"), then we can readily find the value of #dyncode("sum1 (n)")
by solving a simpler problem, that is, finding the value of #dyncode("sum1
(n-1)").\

")#comment("para")
")
#langja("
#para("\
与えられた整数を n とするとき、1 から n までの範囲の整数を全て足すことを考えましょう。
これは次のような再帰関数 #dyncode("sum1") にたやすく実装することができます:

#dats2xhtml("\
fun sum1
  (n: int): int =
  if n >= 1 then sum1 (n-1) + n else 0
// end of [sum1]
")

キーワード #dyncode("fun") は再帰関数の定義の開始です。
#dyncode("1") から #dyncode("n") までの範囲の全ての整数の和を得るために、
#dyncode("sum1 (n)") を呼び出しましょう。
#dyncode("sum1 (n)") の減少戦略は単純です:
もし #dyncode("n") が #dyncode("1") よりも大きければ、
#dyncode("sum1 (n)") の値はより単純な問題である #dyncode("sum1 (n-1)") にできます。
")#comment("para")
")

#langeng("
#para("\
We can also solve the problem by implementing the following
recursive function #dyncode("sum2") that sums up all the integers in a
given range:

#dats2xhtml("\
fun sum2
  (m: int, n: int): int =
  if m <= n then m + sum2 (m+1, n) else 0
// end of [sum2]
")

This time, we call #dyncode("sum2 (1, n)") in order to find out the sum of
all the integers ranging from #dyncode("1") to #dyncode("n").  The
reduction strategy for #dyncode("sum2 (m, n)") is also straightforward: If
#dyncode("m") is less than #dyncode("n"), then we can readily find the
value of #dyncode("sum2 (m, n)") by solving a simpler problem, that is,
finding the value of #dyncode("sum2 (m+1, n)"). The reason for #dyncode("sum2
(m+1, n)") being simpler than #dyncode("sum2 (m, n)") is that
#dyncode("m+1") is closer to #dyncode("n") than #dyncode("m") is.
")#comment("para")
")
#langja("
#para("\
与えられた範囲の整数の和を得るような次の再帰関数 #dyncode("sum2") を実装して問題解決することもできます:

#dats2xhtml("\
fun sum2
  (m: int, n: int): int =
  if m <= n then m + sum2 (m+1, n) else 0
// end of [sum2]
")

#dyncode("1") から #dyncode("n") の範囲の全ての整数の和を取るために、ここで
#dyncode("sum2 (1, n)") を呼び出してみましょう。
#dyncode("sum2 (m, n)") の減少戦略もまた単純です:
もし #dyncode("m") が #dyncode("n") より小さいならば、
#dyncode("sum2 (m, n)") の値をより単純な問題である #dyncode("sum2 (m+1, n)") にできます。
#dyncode("sum2 (m+1, n)") が #dyncode("sum2 (m, n)") よりも単純な理由は、
#dyncode("m+1") が #dyncode("m") よりも #dyncode("n") に近いことです。
")#comment("para")
")

#langeng("
#para("\
Given integers m and n, there is another strategy for summing up all
the integers from m to n: If m does not exceed n, we can find the sum of
all the integers from m to (m+n)/2-1 and then the sum of all the integers
from (m+n)/2+1 to n and then sum up these two sums and (m+n)/2. The
following recursive function #dyncode("sum3") is implemented precisely
according to this strategy:

#dats2xhtml("\
fun sum3
  (m: int, n: int): int =
  if m <= n
    then let
      val mn2 = (m+n)/2
    in
      sum3 (m, mn2-1) + mn2 + sum3 (mn2+1, n)
    end // end of [then]
    else 0 // end of [else]
// end of [sum3]
")

It should be noted that the division involved in the expression
#dyncode("(m+n)/2") is integer division for which rounding is done by
truncation.\

")#comment("para")
")
#langja("
#para("\
整数 m と n が与えられた時、m から n までの全ての整数の和を取るために、また別の戦略があります:
それは、もし m が n を超えないとすると、 m から (m+n)/2-1 までの全ての整数の和を取り、
さらに (m+n)/2+1 から n までの全ての整数の和を取り、最後に左記2つの和と (m+n)/2 の和を取ることです。
次の再帰関数 #dyncode("sum3") はこの戦略に忠実に実装されています:

#dats2xhtml("\
fun sum3
  (m: int, n: int): int =
  if m <= n
    then let
      val mn2 = (m+n)/2
    in
      sum3 (m, mn2-1) + mn2 + sum3 (mn2+1, n)
    end // end of [then]
    else 0 // end of [else]
// end of [sum3]
")

式 #dyncode("(m+n)/2 ") に含まれる除算は整数の除算であるため、切り捨てが発生することに注意すべきです。\

")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="evaluation-of-recursive-function-calls">
#langeng("
#title("Evaluation of Recursive Function Calls")
")
#langja("
#title("再帰関数呼び出しの評価")
")

#langeng("
#para("\
Evaluating a call to a recursive function is not much different from
evaluating one to a non-recursive function.  Let #dyncode("fib") be the
following defined function for computing the Fibonacci numbers:

#dats2xhtml("\
fun fib
  (n: int): int =
  if n >= 2 then fib(n-1) + fib(n-2) else n
// end of [fib]
")

Suppose that we are to evaluate #dyncode("fib(2)") under some environment
ENV0. Given that #dyncode("2") is already a value, we extend ENV0 to ENV1
with a binding between #dyncode("n") and #dyncode("2") and start to
evaluate the body of #dyncode("fib") under ENV1; clearly, this evaluation
leads to the evaluation of #dyncode("fib(n-1) + fib(n-2)"); it is easy to
see that evaluating #dyncode("fib(n-1)") and #dyncode("fib(n-2)") under
ENV1 leads to #dyncode("1") and #dyncode("0"), respectively, and the
evaluation of #dyncode("fib(n-1) + fib(n-2)") eventually returns
#dyncode("1") (as the result of #dyncode("1+0")); thus the evaluation of
#dyncode("fib(2)") under ENV0 yields the integer value #dyncode("1").
")#comment("para")
")
#langja("
#para("\
再帰関数呼び出しの評価は、再帰でない関数呼び出しの評価と比べてもそう難しくはありません。
フィボナッチ数を計算する関数として #dyncode("fib") を次のように定義しましょう:

#dats2xhtml("\
fun fib
  (n: int): int =
  if n >= 2 then fib(n-1) + fib(n-2) else n
// end of [fib]
")

ENV0 環境の下で #dyncode("fib(2)") を評価することを考えてみましょう。
#dyncode("2") が値として与えられた時、
#dyncode("n") と #dyncode("2") を束縛して ENV0 を ENV1 に拡張し、
そして ENV1 の下で #dyncode("fib") の本体の評価を開始します;
明らかにこの評価は #dyncode("fib(n-1) + fib(n-2)") の評価を導きます;
ENV1 の下で #dyncode("fib(n-1)") と #dyncode("fib(n-2)") を評価してそれぞれ #dyncode("1") と #dyncode("0")
が得られ、 #dyncode("fib(n-1) + fib(n-2)") の評価は結局 (#dyncode("1+0") を計算して) #dyncode("1")
を返すことは理解しやすいでしょう;
したがって ENV0 の下で #dyncode("fib(2)") を評価すると整数値 #dyncode("1") が得られます。
")#comment("para")
")

#langeng("
#para("\
Let us now evaluate #dyncode("fib(3)") under ENV0; we extend ENV0
to ENV2 with a binding between #dyncode("n") and #dyncode("3"), and start
to evaluate the body of #dyncode("fib") under ENV2; we then reach the
evaluation of #dyncode("fib(n-1) + fib(n-2)") under ENV2; evaluating
#dyncode("fib(n-1)") under ENV2 leads to the evaluation of
#dyncode("fib(2)") under ENV2, which eventually returns #dyncode("1");
evaluating #dyncode("fib(n-2)") under ENV2 leads to the evaluation of
#dyncode("fib(1)") under ENV2, which eventually returns #dyncode("1");
therefore, evaluating #dyncode("fib(3)") under ENV0 returns #dyncode("2")
(as the result of #dyncode("1+1")).
")#comment("para")
")
#langja("
#para("\
さらに ENV0 の下で #dyncode("fib(3)") を評価してみましょう;
#dyncode("n") と #dyncode("3") の間に束縛を作り ENV0 を ENV2 に拡張した後、
ENV2 の下で #dyncode("fib") の本体の評価を開始します;
それから ENV2 の下で #dyncode("fib(n-1) + fib(n-2)") の評価に辿り着きます;
ENV2 の下で #dyncode("fib(n-1)") を評価して ENV2 の下で #dyncode("fib(2)") の評価を導き、結局
#dyncode("1") を返します;
ENV2 の下で #dyncode("fib(n-2)") を評価して ENV2 の下で #dyncode("fib(1)") の評価を導き、結局
#dyncode("1") を返します;
したがって ENV0 の下で #dyncode("fib(3)") を評価すると(#dyncode("1+1") の結果) #dyncode("2") が返ることになります。
")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-coin-changes-for-fun">
#langeng("
#title("Example: Coin Changes for Fun")
")
#langja("
#title("例: コインチェンジ遊び")
")

#langeng("
#para("\
Let S be a finite set of positive numbers.  The problem we want to
solve is to find out the number of distinct ways for a given integer x to
be expressed as the sum of multiples of the positive numbers chosen from
S. If we interpret each number in S as the denomination of a coin, then the
problem asks how many distinct ways there exist for a given value x to be
expressed as the sum of a set of coins. If we use cc(S, x) for this number,
then we have the following properties on the function cc:

<itemizedlist>

<listitem>
#para("\
cc(S, 0) = 1 for any S.
")
</listitem>

<listitem>
#para("\
If x < 0, then cc(S, x) = 0 for any S.
")
</listitem>

<listitem>
#para("\
If S is empty and x > 0, then cc(S, x) = 0.
")
</listitem>

<listitem>
#para("\
If S contains a number c, then
cc(S, x) = cc(S<subscript>1</subscript>, x) + cc(S, x-c),
where S<subscript>1</subscript> is the set formed by removing c from S.
")
</listitem>

</itemizedlist>

In the following implementation, we fix S to be the set consisting of
1, 5, 10 and 25.

#dats2xhtml("\
//
typedef
int4 = (int, int, int, int)
//
val theCoins = (1, 5, 10, 25): int4
//
fun coin_get
  (n: int): int =
(
  if n = 0 then theCoins.0
  else if n = 1 then theCoins.1
  else if n = 2 then theCoins.2
  else if n = 3 then theCoins.3
  else ~1 (* erroneous value *)
) (* end of [coin_get] *)
//
fun coin_change
  (sum: int): int = let
  fun aux (sum: int, n: int): int =
    if sum > 0 then
     (if n >= 0 then aux (sum, n-1) + aux (sum-coin_get(n), n) else 0)
    else (if sum < 0 then 0 else 1)
  // end of [aux]
in
  aux (sum, 3)
end // end of [coin_change]
//
")

The auxiliary function #dyncode("aux") defined in the body of
the function #dyncode("coin_change") corresponds to the cc function
mentioned above.

When applied to #dyncode("1000"), the function #dyncode("coin_change")
returns #dyncode("142511").
")#comment("para")
")
#langja("
#para("\
S を正の数の有限集合としましょう。
解決したい問題とは、与えられた整数 x を、S から選択した正の数の倍数の和として表現する、異なる方法の数を見つけることです。
S 中のそれぞれの数をコインの額面に見立てると、
この問題は、与えられた値 x をコインの集合の和で表わす異なる方法がいくつあるか調べることになります。
この数を cc(S, x) で表わすと、関数 cc は次の特性を持ちます:

<itemizedlist>

<listitem>
#para("\
どのような S に対しても cc(S, 0) = 1
")
</listitem>

<listitem>
#para("\
どのような S に対しても、もし x < 0 ならば cc(S, x) = 0
")
</listitem>

<listitem>
#para("\
S が空で x > 0 ならば cc(S, x) = 0
")
</listitem>

<listitem>
#para("\
S が数 c を含むならば、S<subscript>1</subscript> が S から c を削除した集合の時
cc(S, x) = cc(S<subscript>1</subscript>, x) + cc(S, x-c)
")
</listitem>

</itemizedlist>

次の実装では、S を 1, 5, 10, 25 からなる集合に設定しています。

#dats2xhtml("\
//
typedef
int4 = (int, int, int, int)
//
val theCoins = (1, 5, 10, 25): int4
//
fun coin_get
  (n: int): int =
(
  if n = 0 then theCoins.0
  else if n = 1 then theCoins.1
  else if n = 2 then theCoins.2
  else if n = 3 then theCoins.3
  else ~1 (* erroneous value *)
) (* end of [coin_get] *)
//
fun coin_change
  (sum: int): int = let
  fun aux (sum: int, n: int): int =
    if sum > 0 then
     (if n >= 0 then aux (sum, n-1) + aux (sum-coin_get(n), n) else 0)
    else (if sum < 0 then 0 else 1)
  // end of [aux]
in
  aux (sum, 3)
end // end of [coin_change]
//
")

関数 #dyncode("coin_change") の本体の中で定義されている補助関数 #dyncode("aux")
は上記で述べた cc 関数に該当します。

#dyncode("1000") に適用すると、関数 #dyncode("coin_change") は #dyncode("142511") を返します。
")#comment("para")
")

#langeng("
#para("\
Note that the entire code in this section plus some additional
code for testing is available #mycodelink("CHAP_FUNCTION/coinchange.dats", "on-line").
")
")
#langja("
#para("\
この章で紹介したコード全体と追加のテストコードは
#mycodelink("CHAP_FUNCTION/coinchange.dats", "オンライン")
から入手できます。
")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="tail-call-and-tail-recursion">
#langeng("
#title("Tail-Call and Tail-Recursion")
")
#langja("
#title("末尾呼出と末尾再帰")
")

#langeng("
#para("\

Suppose that a function foo makes a call in its body to a function
bar, where foo and bar may be the same function. If the return value of the
call to bar is also the return value of foo, then this call to bar is a
tail-call. If foo and bar are the same, then this is a (recursive) self
tail-call. For instance, there are two recursive calls in the body of the
function #dyncode("f91") defined as follows:

#dats2xhtml("\
fun f91 (n: int): int =
  if n >= 101 then n - 10 else f91 (f91 (n+11))
")

where the outer recursive call is a self tail-call while the inner one is
not.\

")#comment("para")
")
#langja("
#para("\

関数本体で関数 bar を呼び出す関数 foo を考えましょう。
ここで foo と bar は同じ関数でも問題ありません。
もし bar を呼び出した返値が foo の返値にもなるとしたら、この bar 呼び出しは末尾呼出です。
もし foo と bar が同じ関数の場合、この呼び出しは(再帰)自己末尾呼出です。
例えば、次のように定義された関数 #dyncode("f91") の本体で2つの再帰呼出があるとします:

#dats2xhtml("\
fun f91 (n: int): int =
  if n >= 101 then n - 10 else f91 (f91 (n+11))
")

ここで外側の f91 (f91 (n+11)) は末尾呼出は自己末尾呼出ですが、内側の f91 (n+11) はそうではありません。\

")#comment("para")
")

#langeng("
#para("\

If each recursive call in the body of a function is a tail-call,
then this function is a tail-recursive function. For instance, the
following function #dyncode("sum_iter") is tail-recursive:

#dats2xhtml("\
fun sum_iter
  (n: int, res: int): int =
  if n > 0 then sum_iter(n-1, n+res) else (res)
// end of [sum_iter]
")

A tail-recursive function is often referred to as an iterative function.\

")#comment("para")
")
#langja("
#para("\

関数本体中のそれぞれの再帰呼出が末尾呼出なら、この関数は末尾再帰関数です。
例えば、次の関数 #dyncode("sum_iter") は末尾再帰です:

#dats2xhtml("\
fun sum_iter
  (n: int, res: int): int =
  if n > 0 then sum_iter (n-1, n+res) else res
// end of [sum_iter]
")

末尾再帰関数はしばしば反復関数と呼ばれます。\

")#comment("para")
")

#langeng("
#para("\

In ATS, the single most important optimization is probably the one
that turns a self tail-call into a local jump. This optimization
effectively turns every tail-recursive function into the equivalent of a
loop. Although ATS provides direct syntactic support for constructing
for-loops and while-loops, the preferred approach to loop construction in
ATS is in general through the use of tail-recursive functions. This is the
case primarily due to the fact that the syntax for writing tail-recursive
functions is compatible with the syntax for other programming features in
ATS while the syntax for loops is much less so.\

")
")
#langja("
#para("\

ATS において唯一もっとも重要な最適化は、
おそらく自己末尾呼出をローカルへのジャンプに変換することでしょう。
この最適化はあらゆる末尾再帰関数を同等のループに効果的に変換します。
ATS は for ループと while ループを生成する構文を直接サポートしていますが、
ATS においてループを生成する好ましいアプローチは、一般に末尾再帰関数を使用することです。
これは、末尾再帰関数を書くための構文が ATS
における他のプログラミング機能の構文と適合できることが主たる理由です。
ループ構文はあまり適合しません。\

")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-the-eight-queens-puzzle">
#langeng("
#title("Example: The Eight-Queens Puzzle")
")
#langja("
#title("例: エイト・クイーンパズル")
")

#langeng("
#para("\
The eight-queens puzzle is the problem of positioning on a 8x8
chessboard 8 queen pieces so that none of them can capture any other pieces
using the standard chess moves defined for a queen piece. I will present as
follows a solution to this puzzle in ATS, reviewing some of the programming
features that have been covered so far. In particular, please note that
every recursive function implemented in this solution is tail-recursive.
")#comment("para")
")
#langja("
#para("\
エイト・クイーンパズルは 8x8 のチェスボードの上に8つのクイーンのコマを、
他のコマを取れるようなコマが全くないように配置する問題です。
ATS でこのパズルの解法を次に示すことで、
これまで紹介してきたプログラミングの機能のいくつかを復習します。
特にこの章で実装する全ての再帰関数は末尾再帰であることに注意してください。
")#comment("para")
")

#langeng("
#para("\
First, let us introduce a name for the integer constant 8 as follows:

#sats2xhtml("\
\#define N 8
")

After this declaration, each occurrence of the name #dyncode("N") is to
be replaced with 8. For representing board configurations, we define
a type #dyncode("int8") as follows:

#sats2xhtml("\
typedef int8 =
(
  int, int, int, int, int, int, int, int
) // end of [int8]
")

A value of the type #dyncode("int8") is a tuple of 8 integers where the
first integer states the column position of the queen piece on the first
row (row 0), and the second integer states the column position of the queen
piece on the second row (row 1), and so on.
")#comment("para")
")
#langja("
#para("\
まずはじめに、次のように整数の定数8に名前を付けます:

#sats2xhtml("\
\#define N 8
")

この宣言の後では、名前 #dyncode("N") は8に置換されます。
ボードの配置を表現するために、次のような #dyncode("int8") 型を定義します:

#sats2xhtml("\
typedef int8 =
(
  int, int, int, int, int, int, int, int
) // end of [int8]
")

#dyncode("int8") 型の値は8つの整数のタプルです。
1番目の整数は1番目の行 (row 0) 上のクイーンの列の位置を表現していて、
2番目の整数は2番目の行 (row 1) 上のクイーンの列の位置を表現していて、などと続きます。
")#comment("para")
")

#langeng("
#para("\
In order to print out a board configuration, we define the following
functions:

#dats2xhtml('\
fun print_dots (i: int): void =
  if i > 0 then (print ". "; print_dots (i-1)) else ()
// end of [print_dots]

fun print_row (i: int): void =
(
  print_dots (i); print "Q "; print_dots (N-i-1); print "\\\n";
) // end of [print_row]

fun print_board (bd: int8): void =
(
  print_row (bd.0); print_row (bd.1); print_row (bd.2); print_row (bd.3);
  print_row (bd.4); print_row (bd.5); print_row (bd.6); print_row (bd.7);
  print_newline ()
) // end of [print_board]
')

The function #dyncode("print_newline") prints out a newline symbol and then
flushes the buffer associated with the standard output. If the reader is
unclear about what buffer flushing means, please feel free to ignore this
aspect of #dyncode("print_newline").\

")#comment("para")
")
#langja("
#para("\
ボードの配置を印字するために、次の関数群を定義します:

#dats2xhtml('\
fun print_dots (i: int): void =
  if i > 0 then (print ". "; print_dots (i-1)) else ()
// end of [print_dots]

fun print_row (i: int): void =
(
  print_dots (i); print "Q "; print_dots (N-i-1); print "\\\n";
) // end of [print_row]

fun print_board (bd: int8): void =
(
  print_row (bd.0); print_row (bd.1); print_row (bd.2); print_row (bd.3);
  print_row (bd.4); print_row (bd.5); print_row (bd.6); print_row (bd.7);
  print_newline ()
) // end of [print_board]
')

関数 #dyncode("print_newline") は改行記号を印字して、標準出力のバッファをフラッシュします。
読者がバッファのフラッシュに詳しくない場合には、
#dyncode("print_newline") のこの側面を無視してかまいません。\

")#comment("para")
")

#langeng("
#para("\

As an example, if #dyncode("print_board") is called on the board
configuration represented by @(0, 1, 2, 3, 4, 5, 6, 7), then the following
8 lines are printed out:

#atscode("\
Q . . . . . . . 
. Q . . . . . . 
. . Q . . . . . 
. . . Q . . . . 
. . . . Q . . . 
. . . . . Q . . 
. . . . . . Q . 
. . . . . . . Q 
")
")#comment("para")
")
#langja("
#para("\

例として、
@(0, 1, 2, 3, 4, 5, 6, 7) で表わされたボード配置に #dyncode("print_board") を呼び出すと、
次の8行が印字されます:

#atscode("\
Q . . . . . . . 
. Q . . . . . . 
. . Q . . . . . 
. . . Q . . . . 
. . . . Q . . . 
. . . . . Q . . 
. . . . . . Q . 
. . . . . . . Q 
")
")#comment("para")
")

#langeng("
#para("\

Given a board and the row number of a queen piece on the board, the
following function #dyncode("board_get") returns the column number of the piece:

#dats2xhtml("\
fun board_get
  (bd: int8, i: int): int =
  if i = 0 then bd.0
  else if i = 1 then bd.1
  else if i = 2 then bd.2
  else if i = 3 then bd.3
  else if i = 4 then bd.4
  else if i = 5 then bd.5
  else if i = 6 then bd.6
  else if i = 7 then bd.7
  else ~1 // end of [if]
// end of [board_get]
")
")#comment("para")
")
#langja("
#para("\

ボードとボード上に行の数だけクイーンのコマが与えられた時、
次の関数 #dyncode("board_get") は列のコマの数を返します:

#dats2xhtml("\
fun board_get
  (bd: int8, i: int): int =
  if i = 0 then bd.0
  else if i = 1 then bd.1
  else if i = 2 then bd.2
  else if i = 3 then bd.3
  else if i = 4 then bd.4
  else if i = 5 then bd.5
  else if i = 6 then bd.6
  else if i = 7 then bd.7
  else ~1 // end of [if]
// end of [board_get]
")
")#comment("para")
")

#langeng("
#para("\

Given a board, a row number i and a column number j, the following function
#dyncode("board_set") returns a new board that are the same as the original
board except for j being the column number of the queen piece on row i:

#dats2xhtml("\
fun board_set
  (bd: int8, i: int, j:int): int8 = let
  val (x0, x1, x2, x3, x4, x5, x6, x7) = bd
in
  if i = 0 then let
    val x0 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 1 then let
    val x1 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 2 then let
    val x2 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 3 then let
    val x3 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 4 then let
    val x4 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 5 then let
    val x5 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 6 then let
    val x6 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 7 then let
    val x7 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else bd // end of [if]
end // end of [board_set]
")

Clearly, the functions #dyncode("board_get") and #dyncode("board_set") are
defined in a rather unwieldy fashion. This is entirely due to the use of
tuples for representing board configurations. If we could use an array to
represent a board configuration, then the implementation would be much
simpler and cleaner. However, we have not yet covered arrays at this point.\

")#comment("para")
")
#langja("
#para("\

ボードと行の数 i と列の数 j が与えられた時、
次の関数 #dyncode("board_set") は、
行 i のクイーンの列の数が j である点を除いて元のボードと同じ新しいボードを返します:

#dats2xhtml("\
fun board_set
  (bd: int8, i: int, j:int): int8 = let
  val (x0, x1, x2, x3, x4, x5, x6, x7) = bd
in
  if i = 0 then let
    val x0 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 1 then let
    val x1 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 2 then let
    val x2 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 3 then let
    val x3 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 4 then let
    val x4 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 5 then let
    val x5 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 6 then let
    val x6 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 7 then let
    val x7 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else bd // end of [if]
end // end of [board_set]
")

関数 #dyncode("board_get") と #dyncode("board_set") の定義はいくらか不恰好です。
これはタプルをボード配置の表現に使っていることに由来します。
ボード配置の表現に配列を使うことができるようになったら、この実装はより単純に明解になるでしょう。
けれども、ここではまだ配列を紹介していません。\

")#comment("para")
")

#langeng("
#para("\

Let us now implement two testing functions #dyncode("safety_test1") and
#dyncode("safety_test2") as follows:

#dats2xhtml("\
fun safety_test1
(
  i0: int, j0: int, i1: int, j1: int
) : bool =
(*
** [abs]: the absolute value function
*)
  j0 != j1 andalso abs (i0 - i1) != abs (j0 - j1)
// end of [safety_test1]

fun safety_test2
(
  i0: int, j0: int, bd: int8, i: int
) : bool =
  if i >= 0 then
    if safety_test1 (i0, j0, i, board_get (bd, i))
      then safety_test2 (i0, j0, bd, i-1) else false
    // end of [if]
  else true // end of [if]
// end of [safety_test2]
")

The functionalities of these two functions can be described as such:

<itemizedlist>
<listitem>
#para("\

The function #dyncode("safety_test1") tests whether a queen piece on row
#dyncode("i0") and column #dyncode("j0") can capture another one on row
#dyncode("i") and column #dyncode("j").\

")
</listitem>

<listitem>
#para("\

The function #dyncode("safety_test2") tests whether a queen piece on row
#dyncode("i0") and column #dyncode("j0") can capture any other pieces on a
given board with a row number less than or equal to #dyncode("i").\

")
</listitem>
</itemizedlist>
")#comment("para")
")
#langja("
#para("\

2つのテスト関数 #dyncode("safety_test1") と #dyncode("safety_test2") を次のように実装しましょう:

#dats2xhtml("\
fun safety_test1
(
  i0: int, j0: int, i1: int, j1: int
) : bool =
(*
** [abs]: the absolute value function
*)
  j0 != j1 andalso abs (i0 - i1) != abs (j0 - j1)
// end of [safety_test1]

fun safety_test2
(
  i0: int, j0: int, bd: int8, i: int
) : bool =
  if i >= 0 then
    if safety_test1 (i0, j0, i, board_get (bd, i))
      then safety_test2 (i0, j0, bd, i-1) else false
    // end of [if]
  else true // end of [if]
// end of [safety_test2]
")

これら2つの関数の機能は次のように表現できます:

<itemizedlist>
<listitem>
#para("\

関数 #dyncode("safety_test1") は、行 #dyncode("i0") 列 #dyncode("j0") にあるクイーンが、行 #dyncode("i") 列 #dyncode("j") にあるクイーンを取ることができるかどうかテストします。\

")
</listitem>

<listitem>
#para("\

関数 #dyncode("safety_test2") は、行 #dyncode("i0") 列 #dyncode("j0") にあるクイーンが、
与えられたボード上の #dyncode("i") 以下の行番号にあるどれかのクイーンを取ることができるかどうかテストします。\

")
</listitem>
</itemizedlist>
")#comment("para")
")

#langeng("
#para("\

We are now ready to implement the following function
#dyncode("search") based on a standard depth-first search (DFS) algorithm:

#dats2xhtml('\
fun search
(
  bd: int8, i: int, j: int, nsol: int
) : int = (
//
if
(j < N)
then let
  val test = safety_test2 (i, j, bd, i-1)
in
  if test
    then let
      val bd1 = board_set (bd, i, j)
    in
      if i+1 = N
        then let
          val () = print! ("Solution #", nsol+1, ":\\\n\\\n")
          val () = print_board (bd1)
        in
          search (bd, i, j+1, nsol+1)
        end // end of [then]
        else (
          search (bd1, i+1, 0(*j*), nsol) // positioning next piece
        ) (* end of [else] *)
      // end of [if]
    end // end of [then]
    else search (bd, i, j+1, nsol)
  // end of [if]
end // end of [then]
else (
  if i > 0
    then search (bd, i-1, board_get (bd, i-1) + 1, nsol) else nsol
  // end of [if]
) (* end of [else] *)
//
) (* end of [search] *)
')

The return value of #dyncode("search") is the number of distinct solutions
to the eight queens puzzle. The symbol #dyncode("print!") in the body of
#dyncode("search") is a special identifier in ATS: It takes an indefinite
number of arguments and then applies #dyncode("print") to each of
them. Following is the first solution printed out by
#dyncode("print_board") during a call to the function #dyncode("search"):

#atscode("\
Q . . . . . . . 
. . . . Q . . . 
. . . . . . . Q 
. . . . . Q . . 
. . Q . . . . . 
. . . . . . Q . 
. Q . . . . . . 
. . . Q . . . . 
")

There are 92 distinct solutions in total.\

")#comment("para")
")
#langja("
#para("\

これで、深さ優先探索 (DFS) アルゴリズムを使って、次のような関数 #dyncode("search") を実装する準備が整いました:

#dats2xhtml('\
fun search
(
  bd: int8, i: int, j: int, nsol: int
) : int = (
//
if
(j < N)
then let
  val test = safety_test2 (i, j, bd, i-1)
in
  if test
    then let
      val bd1 = board_set (bd, i, j)
    in
      if i+1 = N
        then let
          val () = print! ("Solution #", nsol+1, ":\\\n\\\n")
          val () = print_board (bd1)
        in
          search (bd, i, j+1, nsol+1)
        end // end of [then]
        else (
          search (bd1, i+1, 0(*j*), nsol) // positioning next piece
        ) (* end of [else] *)
      // end of [if]
    end // end of [then]
    else search (bd, i, j+1, nsol)
  // end of [if]
end // end of [then]
else (
  if i > 0
    then search (bd, i-1, board_get (bd, i-1) + 1, nsol) else nsol
  // end of [if]
) (* end of [else] *)
//
) (* end of [search] *)
')

#dyncode("search") の返値はエイト・クイーンパズルの解の総数です。
#dyncode("search") の本体の中のシンボル #dyncode("print!") は ATS における特別な識別子です:
この識別子は任意の数の引数を取り、それぞれの引数に #dyncode("print") を適用します。
これは #dyncode("search") 関数を呼び出すと印字される最初の解です:

#atscode("\
Q . . . . . . . 
. . . . Q . . . 
. . . . . . . Q 
. . . . . Q . . 
. . Q . . . . . 
. . . . . . Q . 
. Q . . . . . . 
. . . Q . . . . 
")

解の総数は92になります。\

")#comment("para")
")

#langeng("
#para("\

Note that the entire code in this section plus some additional code for
testing is available #mycodelink("CHAP_FUNCTION/queens.dats", "on-line").\

")
")
#langja("
#para("\

この章で紹介した全コードと追加のテストコードは
#mycodelink("CHAP_FUNCTION/queens.dats", "オンライン")
から入手できます。\

")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="mutually-recursive-functions">
#langeng("
#title("Mutually Recursive Functions")
")
#langja("
#title("相互再帰関数")
")

#langeng("
#para("\

A collection of functions are defined mutually recursively if each function
can make calls in its body to any functions in this collection.  Mutually
recursive functions are commonly encountered in practice.

")
")
#langja("
#para("\

ある関数群のそれぞれの関数がその本体からその関数群の関数を呼び出している時、
その関数群は相互再帰的に定義されています。
相互再帰関数は実際の場面で一般に使われます。

")
")

#langeng("
#para("\

As an example, let P be a function on natural numbers defined as follows:

<itemizedlist>
<listitem>
#para("P(0) = 1")
</listitem>
<listitem>
#para("\
P(n+1) = 1 + the sum of the products of i and P(i) for i ranging from 1 to n
")
</listitem>
</itemizedlist>

Let us introduce a function Q such that Q(n) is the sum of the products of
i and P(i) for i ranging from 1 to n. Then the functions P and Q can be
defined mutually recursively as follows:

<itemizedlist>
<listitem>
#para("P(0) = 1")
</listitem>
<listitem>
#para("P(n+1) = 1 + Q(n)")
</listitem>

<listitem>
#para("Q(0) = 0")
</listitem>
<listitem>
#para("Q(n+1) = Q(n) + (n+1) * P(n+1)")
</listitem>
</itemizedlist>

The following implementation of P and Q is a direct translation of their
definitions into ATS:

#dats2xhtml("\
fun P (n:int): int = if n > 0 then 1 + Q(n-1) else 1
and Q (n:int): int = if n > 0 then Q(n-1) + n * P(n) else 0
")

Note that the keyword #dyncode("and") is used to combine function
definitions.\

")#comment("para")
")
#langja("
#para("\

例として、P を次のような自然数の関数とします:

<itemizedlist>
<listitem>
#para("P(0) = 1")
</listitem>
<listitem>
#para("\
P(n+1) = 1 + (i の範囲が 1 から n までの時、i と P(i) の積の合計)
")
</listitem>
</itemizedlist>

1 から n までの範囲を i が取る時、i と P(i) の積の合計を Q(n) とするような関数 Q を導入しましょう。
すると関数 P と Q は次のように相互再帰的に定義できます:

<itemizedlist>
<listitem>
#para("P(0) = 1")
</listitem>
<listitem>
#para("P(n+1) = 1 + Q(n)")
</listitem>

<listitem>
#para("Q(0) = 0")
</listitem>
<listitem>
#para("Q(n+1) = Q(n) + (n+1) * P(n+1)")
</listitem>
</itemizedlist>

次の P と Q の実装はこれらの定義を直接 ATS に翻訳したものです:

#dats2xhtml("\
fun P (n:int): int = if n > 0 then 1 + Q(n-1) else 1
and Q (n:int): int = if n > 0 then Q(n-1) + n * P(n) else 0
")

キーワード #dyncode("and") を使って関数定義を結合していることに注意してください。\

")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="mutual-tail-recursion">
#langeng("
#title("Mutually Defined Tail-Recursion")
")
#langja("
#title("相互に定義された末尾再帰")
")

#langeng("
#para("\

Suppose that foo and bar are two mutually defined recursive functions.  In
the body of foo or bar, a tail-call to foo or bar is a mutually recursive
tail-call. For instance, the following two functions #dyncode("isevn") and
#dyncode("isodd") are mutually recursive:

#dats2xhtml("\
//
fun
isevn (n: int): bool = if n > 0 then isodd (n-1) else true
//
and
isodd (n: int): bool = if n > 0 then isevn (n-1) else false
//
")

The mutually recursive call to #dyncode("isodd") in the body of
#dyncode("isevn") is a tail-call, and the mutually recursive call to
#dyncode("isevn") in the body of #dyncode("isodd") is also a tail-call.  If
we want that these two tail-calls be compiled into local jumps, we should
replace the keyword #dyncode("fun") with the keyword #dyncode("fnx") as
follows:

#dats2xhtml("\
//
fnx
isevn (n: int): bool = if n > 0 then isodd (n-1) else true
//
and
isodd (n: int): bool = if n > 0 then isevn (n-1) else false
//
")

What the ATS compiler does in this case is to combine these two functions
into a single one so that each mutually recursive tail-call in their bodies
can be turned into a self tail-call in the body of the combined function,
which is then ready to be compiled into a local jump.\

")#comment("para")
")
#langja("
#para("\

foo と bar が2つの相互再帰関数として定義されているとします。
foo もしくは bar の本体にある、foo もしくは bar への末尾呼出は相互末尾再帰呼出です。
例えば、次の2つの関数 #dyncode("isevn") と #dyncode("isodd") は相互再帰です:

#dats2xhtml("\
//
fun
isevn (n: int): bool = if n > 0 then isodd (n-1) else true
//
and
isodd (n: int): bool = if n > 0 then isevn (n-1) else false
//
")

#dyncode("isevn") の本体内の #dyncode("isodd") への相互再帰呼出は末尾呼出です。
#dyncode("isodd") の本体内の #dyncode("isevn") への相互再帰呼出もまた末尾呼出です。
もしこれら2つの末尾呼出をローカルジャンプにコンパイルしたい場合には、
次のようにキーワード #dyncode("fun") をキーワード #dyncode("fnx") で置き換えるべきです:

#dats2xhtml("\
//
fnx
isevn (n: int): bool = if n > 0 then isodd (n-1) else true
//
and
isodd (n: int): bool = if n > 0 then isevn (n-1) else false
//
")

この場合、ATS コンパイラはこれら2つの関数を1つの関数に結合します。
そのためそれぞれの本体にある相互末尾再帰呼出を、結合された関数本体の自己末尾呼出に変換できます。
そしてこれらの呼出はローカルジャンプへとコンパイルされます。\

")#comment("para")
")

#langeng("
#para("\
When writing code corresponding to embedded loops in an imperative
programming language such as C or Java, we often need to make sure that
mutually recursive tail-calls are compiled into local jumps. The following
function #dyncode("print_multable") is implemented to print out a standard
multiplication table for nonzero digits:

#dats2xhtml('\
fun
print_multable
  ((*void*)) = let
//
\#define N 9
//
fnx
loop1
  (i: int): void =
  if i <= N then loop2 (i, 1) else ()
//
and
loop2
  (i: int, j: int): void =
  if j <= i
    then let
      val () = if j >= 2 then print " "
      val () = $extfcall(void, "printf", "%dx%d=%2.2d", j, i, j*i)
    in
      loop2 (i, j+1) 
    end // end of [then]
    else let
      val () = print_newline () in loop1 (i+1)
    end // end of [else]
  // end of [if]
//
in
  loop1 (1)
end // end of [print_multable]
')

The functions #dyncode("loop1") and #dyncode("loop2") are defined
mutually recursively, and the mutually recursive calls in their bodies are
all tail-calls. The keyword #dyncode("fnx") indicates to the ATS compiler
that the functions #dyncode("loop1") and #dyncode("loop2") should be
combined so that these tail-calls can be compiled into local jumps. In a
case where #dyncode("N") is a large number (e.g., 1,000,000), calling
#dyncode("loop1") may run the risk of stack overflow if these tail-calls
are not compiled into local jumps.
")#comment("para")
")
#langja("
#para("\
C言語や Java のような命令型プログラミング言語の組み込みループに相当するコードを書く場合には、
相互末尾再帰呼出がローカルジャンプにコンパイルされるかしばしば確認する必要があります。
次の関数 #dyncode("print_multable") ではゼロではない桁の九九の表の印字を実装しています:

#dats2xhtml('\
fun
print_multable
  ((*void*)) = let
//
\#define N 9
//
fnx
loop1
  (i: int): void =
  if i <= N then loop2 (i, 1) else ()
//
and
loop2
  (i: int, j: int): void =
  if j <= i
    then let
      val () = if j >= 2 then print " "
      val () = $extfcall(void, "printf", "%dx%d=%2.2d", j, i, j*i)
    in
      loop2 (i, j+1) 
    end // end of [then]
    else let
      val () = print_newline () in loop1 (i+1)
    end // end of [else]
  // end of [if]
//
in
  loop1 (1)
end // end of [print_multable]
')

関数 #dyncode("loop1") と #dyncode("loop2") は相互再帰的に定義されています。
そしてこれらの本体におけるこの相互再帰呼出は全て末尾呼出です。
キーワード #dyncode("fnx") は、
これらの末尾呼出がローカルジャンプにコンパイルできるように関数 #dyncode("loop1") と #dyncode("loop2")
は結合すべきであることを、ATS コンパイラに指示します。
この例では #dyncode("N") が大きい数(例えば1,000,000)なので、
もしこれらの末尾呼出がローカルジャンプにコンパイルされない場合、
#dyncode("loop1") の呼び出しによってスタックオーバーフローが起きる危険性があります。
")#comment("para")
")

#langeng("
#para("\

When called, the function #dyncode("print_multable") prints out the
following multiplication table:

#atscode("\
1x1=01
1x2=02 2x2=04
1x3=03 2x3=06 3x3=09
1x4=04 2x4=08 3x4=12 4x4=16
1x5=05 2x5=10 3x5=15 4x5=20 5x5=25
1x6=06 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36
1x7=07 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49
1x8=08 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64
1x9=09 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81
")

")#comment("para")
")
#langja("
#para("\

呼び出されると、関数 #dyncode("print_multable") は次のような九九の表を印字します:

#atscode("\
1x1=01
1x2=02 2x2=04
1x3=03 2x3=06 3x3=09
1x4=04 2x4=08 3x4=12 4x4=16
1x5=05 2x5=10 3x5=15 4x5=20 5x5=25
1x6=06 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36
1x7=07 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49
1x8=08 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64
1x9=09 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81
")

")#comment("para")
")

#langeng("
#para("\

In summary, the very ability to turn mutually recursive tail-calls into
local jumps makes it possible to implement embedded loops as mutually
tail-recursive functions. This ability is indispensable for advocating the
practice of replacing loops with recursive functions in ATS.\

")
")
#langja("
#para("\

要約すると、
相互末尾再帰呼出をローカルジャンプへ変換する能力は、
組み込みループを相互末尾再帰関数で実装することを可能にします。
この能力は、ループを ATS の再帰関数で置換するのに実用上不可欠です。\

")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="envless-functions-and-function-closures">
#langeng("
#title("Envless Functions and Closure-Functions")
")
#langja("
#title("無環境関数とクロージャ関数")
")

#langeng("
#para("\

I use <emphasis>envless</emphasis> as a shorthand for environmentless,
which is not a legal word but I suppose that you have no problem figuring
out what it means.\

")
")
#langja("
#para("\

<emphasis>無環境 (envless)</emphasis> という単語は一般的な単語ではなく、
私は \"環境の無い (environmentless)\" の略記として使いますが、
その意味をあなたは問題なく想像できるでしょう。\

")
")

#langeng("
#para("\

An envless function is represented by a pointer pointing to some place in a
code segment where the object code for executing a call to this function is
located. Every function in the programming language C is envless. A
closure-function is also represented by a pointer, but the pointer points
to some place in a heap where a tuple is allocated (at run-time). Usually,
the first component of this tuple is a pointer representing an envless
function and the rest of the components represent some bindings. A tuple as
such is often referred to as a closure-function or simply closure, which
can be thought of as an envless function paired with an environment. It is
possible that the environment of a closure-function is empty, but this does
not equate a closure-function with an envless function. Every function in
functional languages such as ML and Haskell is a closure-function.\

")#comment("para")
")
#langja("
#para("\

無環境関数は、この関数の呼び出しを実行するオブジェクトコードが配置されているコードセグメントを指し示すポインタによって表現されます。
C言語において、全ての関数は無環境です。
クロージャ関数もまたポインタで表現されますが、
そのポインタはヒープ中の(実行時に)割り当てられたタプルがある場所を指し示しています。
通常、このタプルの1つ目の要素は無環境関数を表わすポインタで、残りの要素は束縛群を表わしています。
そのようなタプルはしばしばクロージャ関数もしくは単純にクロージャと呼ばれ、
環境とペアになった無環境関数であると考えることができます。
クロージャ関数の環境が空であっても問題ありませんが、
これは無環境関数のクロージャ関数と同じではありません。
ML や Haskell のような関数型言語の全ての関数はクロージャ関数です。\

")#comment("para")
")

#langeng("
#para("\

In the following example, the function #dyncode("sum"), which is assigned
the type #dyncode("(int) -> int"), sums up all the integers between 1 and a
given natural number:

#dats2xhtml("\
fun sum
  (n: int): int = let
  fun loop
  (
    i: int, res: int
  ) :<cloref1> int =
    if i <= n then loop (i+1, res+i) else res
  // end of [loop]
in
  loop (1(*i*), 0(*res*))
end // end of [sum]
")

The inner function #dyncode("loop") is a closure-function as is indicated
by the special syntax #dyncode(":&lt;cloref1&gt;"), and the type assigned
to #dyncode("loop") is denoted by #dyncode("(int, int) -&lt;cloref1&gt;
int"). Hence, envless functions and closure-functions can be distinguished
at the level of types.\

")#comment("para")
")
#langja("
#para("\

次の例では、型 #dyncode("(int) -> int") が割り当てられた関数 #dyncode("sum")
は1から与えられた自然数までの全ての整数を合計します:

#dats2xhtml("\
fun sum
  (n: int): int = let
  fun loop
  (
    i: int, res: int
  ) :<cloref1> int =
    if i <= n then loop (i+1, res+i) else res
  // end of [loop]
in
  loop (1(*i*), 0(*res*))
end // end of [sum]
")

内側の関数 #dyncode("loop") は特別な構文 #dyncode(":&lt;cloref1&gt;") で示されるクロージャ関数です。
また #dyncode("loop") に割り当てられた型は #dyncode("(int, int) -&lt;cloref1&gt; int") です。
それゆえ無環境関数とクロージャ関数は型レベルで見分けることができます。\

")#comment("para")
")

#langeng("
#para("\

If the syntax #dyncode(":&lt;cloref1&gt;") is replaced with the colon
symbol #dyncode(":") alone, the code can still pass typechecking but its
compilation may eventually lead to a warning or even an error indicating
that #dyncode("loop") cannot be compiled into a toplevel function in C. The
reason for this warning/error is due to the body of #dyncode("loop")
containing a variable #dyncode("n") that is neither at toplevel nor a part
of the arguments of #dyncode("loop") itself. It is straightforward to make
#dyncode("loop") an envless function by including #dyncode("n") as an
argument in addition to the original ones:

#dats2xhtml("\
fun sum
  (n: int): int = let
  fun loop
  (
    n:int, i: int, res: int
  ) : int =
    if i <= n then loop (n, i+1, res+i) else res
  // end of [loop]
in
  loop (n, 1(*i*), 0(*res*))
end // end of [sum]
")

As a matter of fact, what happens during compilation is that the first
implementation of #dyncode("sum") and #dyncode("loop") gets translated,
more or less, into the second implementation, and there is #emphasis("no")
actual creation of closures at run-time.\

")#comment("para")
")
#langja("
#para("\

もし構文 #dyncode(":&lt;cloref1&gt;") を単独なコロン記号 #dyncode(":") に置き換えたとしてもコードは型検査を通りますが、#dyncode("loop") をC言語のトップレベル関数にコンパイルできないことを示す警告もしくはエラーを引き起こす可能性があります。
この警告/エラーの理由は、トップレベルでもなく #dyncode("loop") 関数自身の引数でもない値 #dyncode("n") が
#dyncode("loop") の本体に含まれていることにあります。
#dyncode("n") を元の関数への追加の引数として #dyncode("loop") を無環境関数にするのは簡単です:

#dats2xhtml("\
fun sum
  (n: int): int = let
  fun loop
  (
    n:int, i: int, res: int
  ) : int =
    if i <= n then loop (n, i+1, res+i) else res
  // end of [loop]
in
  loop (n, 1(*i*), 0(*res*))
end // end of [sum]
")

実際のコンパイルの中では、
#dyncode("sum") と #dyncode("loop") の最初の実装はおおよそ2番目の実装に変換され、
実行時に実際のクロージャが作られるわけでは#emphasis("ありません")。\

")#comment("para")
")

#langeng("
#para("\

The need for creating closures often appears when a function is not
directly applied. For instance, the return value of a function call may
also be a function. In the following code, the defined function
#dyncode("addx") returns another function when applied to a given integer
#dyncode("x"), and the returned function is a closure-function, which
always adds the integer #dyncode("x") to its own argument:

#dats2xhtml("\
//
fun addx (x: int): int -<cloref1> int = lam y => x + y
//
val plus1 = addx (1) // [plus1] is of the type int -<cloref1> int
val plus2 = addx (2) // [plus2] is of the type int -<cloref1> int
//
")

It should be clear that #dyncode("plus1(0)") and #dyncode("plus2(0)")
return #dyncode("1") and #dyncode("2"), respectively.  The closure-function
that is given the name #dyncode("plus1") consists of an envless function
and an environment binding #dyncode("x") to #dyncode("1"). The envless
function can essentially be described by the pseudo syntax #dyncode("lam
(env, y) => env.x + y"), where #dyncode("env") and #dyncode("env.x") refer
to an environment and the value to which #dyncode("x") is bound in that
environment. When evaluating #dyncode("plus1(0)"), we can first bind
#dyncode("env") and #dyncode("y") to the environment in #dyncode("plus1")
and the argument #dyncode("0"), respectively, and then start to evaluate
the body of the envless function in #dyncode("plus1"), which is
#dyncode("env.x + y"). Clearly, this evaluation yields the value
#dyncode("1") as is expected.\

")#comment("para")
")
#langja("
#para("\

関数が直接適用されない時でも、しばしばクロージャを作る必要があります。
例えば、関数呼び出しの返値もまた関数であるかもしれません。
次のコードで定義された関数 #dyncode("addx") は与えられた整数 #dyncode("x") に適用した別の関数を返します。
そしてこの返される関数はクロージャ関数で、
常に自分の引数に整数 #dyncode("x") を加算します:

#dats2xhtml("\
//
fun addx (x: int): int -<cloref1> int = lam y => x + y
//
val plus1 = addx (1) // [plus1] is of the type int -<cloref1> int
val plus2 = addx (2) // [plus2] is of the type int -<cloref1> int
//
")

#dyncode("plus1(0)") と #dyncode("plus2(0)") がそれぞれ #dyncode("1") と #dyncode("2") を返すのは自明でしょう。
#dyncode("plus1") の名前が与えられたクロージャ関数は無環境関数と
#dyncode("x") を #dyncode("1") に束縛した環境から構成されています。
#dyncode("env") と #dyncode("env.x") が環境とその環境で #dyncode("x") に束縛された値を参照する時、
この無環境関数は仮構文を使って本質的に #dyncode("lam (env, y) => env.x + y") と表現できます。
#dyncode("plus1(0)") を評価すると、
はじめに #dyncode("env") と #dyncode("y") をそれぞれ #dyncode("plus1") 内の環境と引数 #dyncode("0")
に束縛します。
それから、 #dyncode("env.x + y") である #dyncode("plus1") 内の無環境関数の本体の評価を開始します。
この評価によって期待通り値 #dyncode("1") が生成されることは明確です。\

")#comment("para")
")

#langeng("
#para("\

Closures are often passed as arguments to functions that are referred
to as higher-order functions.  It is also fairly common for closures to
be embedded in data structures.\

")
")
#langja("
#para("\

クロージャはしばしば高階関数と呼ばれる関数への引数として渡されることがあります。
クロージャがデータ構造に埋め込まれることも一般的です。\

")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="higher-order-functions">
#langeng("
#title("Higher-Order Functions")
")
#langja("
#title("高階関数")
")

#langeng("
#para("\
A higher-order function is a function that take another function as
its argument. For instance, the following defined function
#dyncode("rtfind") is a higher-order one:

#dats2xhtml("\
fun rtfind
  (f: int -> int): int = let
  fun loop (
    f: int -> int, n: int
  ) : int =
    if f(n) = 0 then n else loop (f, n+1)
  // end of [loop]
in
  loop (f, 0)
end // end of [rtfind]
")

Given a function from integers to integers, #dyncode("rtfind") searches
for the first natural number that is a root of the function. For instance,
calling #dyncode("rtfind") on the polynomial function #dyncode("lam x => x * x
- x - 110") returns #dyncode("11").  Note that #dyncode("rtfind")
loops forever if it is applied to a function that does not have a root.
")#comment("para")
")
#langja("
#para("\
高階関数とは別の関数を引数として取るような関数です。
例えば、次に定義する関数 #dyncode("rtfind") は高階関数の例です:

#dats2xhtml("\
fun rtfind
  (f: int -> int): int = let
  fun loop (
    f: int -> int, n: int
  ) : int =
    if f(n) = 0 then n else loop (f, n+1)
  // end of [loop]
in
  loop (f, 0)
end // end of [rtfind]
")

整数から整数への関数が与えられた時、
#dyncode("rtfind") は関数の根となるような最初の自然数を探します。
例えば、 #dyncode("rtfind") を多項式の関数 #dyncode("lam x => x * x - x - 110") に呼び出すと
#dyncode("11") が返ります。
もし根を持たない関数に適用されると、 #dyncode("rtfind") は無限ループすることに注意してください。
")#comment("para")
")

#langeng("
#para("\
Higher-order functions can greatly facilitate code reuse, and I now
present a simple example to illustrate this point.  The following defined
functions #dyncode("sum") and #dyncode("prod") compute the sum and
product of the integers ranging from 1 to a given natural number,
respectively:

#dats2xhtml("\
fun sum (n: int): int = if n > 0 then sum (n-1) + n else 0
fun prod (n: int): int = if n > 0 then prod (n-1) * n else 1
")

The similarity between the functions #dyncode("sum") and #dyncode("prod")
is evident.  We can define a higher-function #dyncode("ifold") and then
implement #dyncode("sum") and #dyncode("prod") based on
#dyncode("ifold"):

#dats2xhtml("\
//
fun ifold
  (n: int, f: (int, int) -> int, ini: int): int =
  if n > 0 then f (ifold (n-1, f, ini), n) else ini
//
fun sum (n: int): int = ifold (n, lam (res, x) => res + x, 0)
fun prod (n: int): int = ifold (n, lam (res, x) => res * x, 1)
//
")

If we ever want to compute the sum of the squares of the integers ranging
from 1 to a given natural number n, we can readily do it by defining a
function based on #dyncode("ifold") as follows:

#dats2xhtml("\
fun sqrsum (n: int): int = ifold (n, lam (res, x) => res + x * x, 0)
")

Suppose we generalize #dyncode("sqrsum") to the following function
#dyncode("sqrmodsum") in order to compute the sum of the squares of the
integers ranging from 1 to n that are multiples of a given number d:

#dats2xhtml("\
fun sqrmodsum
  (n: int, d: int): int =
  ifold (n, lam (res, x) => if x mod d = 0 then res + x * x else res, 0)
// end of [sqrmodsum]
")

For someone unfamilar with the distinction between an envless function and
a closure-function, it may be a bit suprising to learn that this
generalization does not actually work. The simple reason is that
#dyncode("ifold") expects its second argument to be an envless function but
the function passed to #dyncode("ifold") in the body of
#dyncode("sqrmodsum") is clearly not envless (due to its use of
#dyncode("d")). To address the issue, we can implement a variant of
#dyncode("ifold") as follows and then implement #dyncode("sqrmodsum") based
on this variant:

#dats2xhtml("\
//
fun
ifold2
(
  n: int, f: (int, int) -<cloref1> int, ini: int
) : int =
  if n > 0 then f (ifold2 (n-1, f, ini), n) else ini
// end of [ifold2]
//
fun
sqrmodsum (n: int, d: int): int =
  ifold2 (n, lam (res, x) => if x mod d then res + x * x else res, 0)
// end of [sqrmodsum]
//
")

While #dyncode("ifold2") is indeed more general than #dyncode("ifold"),
this generality does come with a price. Whenever #dyncode("sqrmodsum") is
called, a closure-function must be created on heap and then passed to
#dyncode("ifold2"); this closure-function is of no further use after the
call returns and the memory it occupies can only be properly relcaimed
through garbage collection (GC). Therefore, calling functions like
#dyncode("sqrmodsum") can readily result in memory leaks in a setting where
GC is not available. Fortunately, there are also linear closure-functions
in ATS, which do not cause any memory leaks even in the absence of GC as
they are required to be explicitly freed by the programmer. I will cover
this interesting programming feature elsewhere.\

")#comment("para")
")
#langja("
#para("\
高階関数はコードの再利用を促進します。ここではその単純な例を示そうと思います。
次に定義する関数 #dyncode("sum") と #dyncode("prod") は 1 から与えられた自然数までの和と積をそれぞれ計算します:

#dats2xhtml("\
fun sum (n: int): int = if n > 0 then sum (n-1) + n else 0
fun prod (n: int): int = if n > 0 then prod (n-1) * n else 1
")

関数 #dyncode("sum") と #dyncode("prod") の間における類似点は明白です。
高階関数 #dyncode("ifold") を定義して、
#dyncode("sum") と #dyncode("prod") を #dyncode("ifold") にもとづいて実装することができます:

#dats2xhtml("\
//
fun ifold
  (n: int, f: (int, int) -> int, ini: int): int =
  if n > 0 then f (ifold (n-1, f, ini), n) else ini
//
fun sum (n: int): int = ifold (n, lam (res, x) => res + x, 0)
fun prod (n: int): int = ifold (n, lam (res, x) => res * x, 1)
//
")

もし 1 から与えられた自然数 n までの範囲の整数の二乗の和を計算するのであれば、
#dyncode("ifold") を使って次のようにたやすく定義できます:

#dats2xhtml("\
fun sqrsum (n: int): int = ifold (n, lam (res, x) => res + x * x, 0)
")

1 から n までの整数の中で与えられた数 d の倍数を選んで二乗の和を計算するために、
#dyncode("sqrsum") を一般化して次の関数 #dyncode("sqrmodsum") を作ることを考えましょう:

#dats2xhtml("\
fun sqrmodsum
  (n: int, d: int): int =
  ifold (n, lam (res, x) => if x mod d = 0 then res + x * x else res, 0)
// end of [sqrmodsum]
")

無環境関数とクロージャ関数の差異に慣れていない人にとって、
この一般化が実際には動かないことは少し意外かもしれません。
その単純な理由は #dyncode("ifold") は二番目の引数に無環境関数が渡されることを期待していますが、
#dyncode("sqrmodsum") の本体で #dyncode("ifold") に渡す関数は #dyncode("d")
を使っているため明らかに無環境ではないためです。
この問題に対処するために、次のような #dyncode("ifold") の変形を実装し、
それからその変形にもとづいて #dyncode("sqrmodsum") を実装することができます:

#dats2xhtml("\
//
fun
ifold2
(
  n: int, f: (int, int) -<cloref1> int, ini: int
) : int =
  if n > 0 then f (ifold2 (n-1, f, ini), n) else ini
// end of [ifold2]
//
fun
sqrmodsum (n: int, d: int): int =
  ifold2 (n, lam (res, x) => if x mod d then res + x * x else res, 0)
// end of [sqrmodsum]
//
")

#dyncode("ifold2") は確かに #dyncode("ifold") よりも一般的ですが、代償を伴います。
#dyncode("sqrmodsum") が呼び出されると、クロージャ関数をヒープの中に生成してから
#dyncode("ifold2") に渡さなければなりません;
このクロージャ関数は関数が返った後はもはや使いません。
そのメモリはガベージコレクション (GC) が回収するまで解放されません。
そのため GC が無効な場合 #dyncode("sqrmodsum") のような関数呼び出しは、
たやすくメモリリークを引き起こしてしいまいます。
幸運にも、明示的にプログラマが解放することで、
GC がなくともメモリリークを引き起こさない線形クロージャ関数も ATS は備えています。
この興味深いプログラミングの機能は別の章で紹介します。\

")#comment("para")
")

#langeng("
#para("\

As more features of ATS are introduced, higher-order functions will become
even more effective in facilitating code reuse.\

")#comment("para")
")
#langja("
#para("\

より多くのATSの機能が導入されれば、高階関数はより効果的にコードの再利用ができるようになるでしょう。\

")#comment("para")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-binary-search-for-fun">
#langeng("
#title("Example: Binary Search for Fun")
")
#langja("
#title("例: 二分探索遊び")
")

#langeng("
#para("\

While binary search is often performed on an ordered array to check whether
a given element is stored in that array, it can also be employed to compute
the inverse of an increasing or decreasing function on integers. In the
following code, the defined function #dyncode("bsearch_fun") returns an
integer i0 such that f(i) <= x0 holds for i ranging from lb to i0,
inclusive, and x0 < f(i) holds for i ranging from i0+1 to ub, inclusive:

#dats2xhtml("\
//
// The type [uint] is for unsigned integers
//
fun bsearch_fun
(
  f: int -<cloref1> uint
, x0: uint, lb: int, ub: int
) : int =
  if lb <= ub then let
    val mid = lb + (ub - lb) / 2
  in
    if x0 < f (mid) then
      bsearch_fun (f, x0, lb, mid-1)
    else
      bsearch_fun (f, x0, mid+1, ub)
    // end of [if]
  end else ub // end of [if]
// end of [bsearch_fun]
")

As an example, the following function #dyncode("isqrt") is defined based
on #dyncode("bsearch_fun") to compute the integer square root of a given
natural number, that is, the largest integer whose square is less than or
equal to the given natural number:

#dats2xhtml("\
//
// Assuming that [uint] is of 32 bits
//
val
ISQRT_MAX = (1 << 16) - 1 // = 65535
//
fun isqrt
  (x: uint): int =
  bsearch_fun (lam i => square(g0i2u(i)), x, 0, ISQRT_MAX)
// end of [isqrt]
")

Note that the function #dyncode("g0i2u") is for casting a signed integer
into an unsigned one and the function #dyncode("square") returns the square
of its argument.\

")#comment("para")
")
#langja("
#para("\

与えられた要素が配列に保存されているか検査するために、
しばしば順序付けられた配列に対して二分探索を行なうことがあります。
また整数に対して増加や減少する関数の逆関数を作るのに使うこともできます。
次のコードで定義している関数 #dyncode("bsearch_fun") は、
i が lb から i0 までの範囲では f(i) <= x0 を維持し、
i が i0+1 から ub までの範囲では x0 < f(i) を維持するような整数 i0 を返します:

#dats2xhtml("\
//
// The type [uint] is for unsigned integers
//
fun bsearch_fun
(
  f: int -<cloref1> uint
, x0: uint, lb: int, ub: int
) : int =
  if lb <= ub then let
    val mid = lb + (ub - lb) / 2
  in
    if x0 < f (mid) then
      bsearch_fun (f, x0, lb, mid-1)
    else
      bsearch_fun (f, x0, mid+1, ub)
    // end of [if]
  end else ub // end of [if]
// end of [bsearch_fun]
")

例として、次の関数 #dyncode("isqrt") は #dyncode("bsearch_fun") にもとづいて定義されていて、
与えられた自然数の整数平方根、
つまり二乗が与えられた自然数以下であるような最も大きい整数を返します:

#dats2xhtml("\
//
// Assuming that [uint] is of 32 bits
//
val ISQRT_MAX = (1 << 16) - 1 // = 65535
fun isqrt
  (x: uint): int =
  bsearch_fun (lam i => square ((g0i2u)i), x, 0, ISQRT_MAX)
// end of [isqrt]
")

関数 #dyncode("g0i2u") は符号付き整数を符号なし整数にキャストし、
関数 #dyncode("square") は引数の二乗を返すことに注意してください。\

")#comment("para")
")

#langeng("
#para("\
Please find #mycodelink("CHAP_FUNCTION/bsearch.dats", "on-line")
the entire code in this section plus some additional code for testing.
")
")
#langja("
#para("\
この章で紹介したコード全体と追加のテストコードは
#mycodelink("CHAP_FUNCTION/bsearch.dats", "オンライン")
から入手できます。
(訳注: このコードを atscc でコンパイルする際には -DATS_MEMALLOC_LIBC オプションが必要です。)
")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-a-higher-order-fun-puzzle">
#langeng("
#title("Example: A Higher-Order Fun Puzzle")
")
#langja("
#title("例: 高階関数パズル")
")

#langeng("
#para("\

Let us first introduce a type definition as follows:

#sats2xhtml("\
typedef I (a:t@ype) = a -<cloref1> a
")

Given a type T, I(T) is for a closure-function that maps a given input
value of type T to an output value of the same type T. Given a function f
of type I(T), we can compose f with itself to form another function, which
just applies f twice to a given argument. The following function template
#dyncode("twice") does precisely the described function composition:

#dats2xhtml("\
fn{a:t0p}
twice (f: I(a)):<cloref> I(a) = lam (x) => f (f (x))
")

Let us now take a look at some interesting code involving #dyncode("twice")
that is also likely to be puzzling:

#dats2xhtml("\
//
typedef I0 = int
typedef I1 = I(I0)
typedef I2 = I(I1)
typedef I3 = I(I2)
//
val Z = 0
val S = lam (x: int): int =<cloref> x + 1
val ans0 = twice<I0>(S)(Z)
val ans1 = twice<I1>(twice<I0>)(S)(Z)
val ans2 = twice<I2>(twice<I1>)(twice<I0>)(S)(Z)
val ans3 = twice<I3>(twice<I2>)(twice<I1>)(twice<I0>)(S)(Z)
//
")

Note that the type definitions
#stacode("I0"),
#stacode("I1"),
#stacode("I2"), and
#stacode("I3") are introduced to make the above code more easily
accessible.\

")
")
#langja("
#para("\

はじめに次のような型定義を導入しましょう:

#sats2xhtml("\
typedef I (a:t@ype) = a -<cloref1> a
")

型 T が与えられた時 I(T) は、与えられた入力である型 T の値を、出力としての型 T
の値へ写像するクロージャ関数です。
型 I(T) の関数 f が与えられた時、
単に与えられた引数に f を2度適用するような別の関数を作ることができます。
次の関数テンプレート #dyncode("twice") は左記に説明した関数を正確に構成しています:

#dats2xhtml("\
fn{a:t0p}
twice (f: I(a)):<cloref> I(a) = lam (x) => f (f (x))
")

#dyncode("twice") を使った興味深いコードを見てみましょう。
それはパズルのようにも見えます:

#dats2xhtml("\
//
typedef I0 = int
typedef I1 = I(I0)
typedef I2 = I(I1)
typedef I3 = I(I2)
//
val Z = 0
val S = lam (x: int): int =<cloref> x + 1
val ans0 = twice<I0>(S)(Z)
val ans1 = twice<I1>(twice<I0>)(S)(Z)
val ans2 = twice<I2>(twice<I1>)(twice<I0>)(S)(Z)
val ans3 = twice<I3>(twice<I2>)(twice<I1>)(twice<I0>)(S)(Z)
//
")

上記のコードを読みやすくするために、型宣言
#stacode("I0"),
#stacode("I1"),
#stacode("I2"),
#stacode("I3")
が導入されていることに注意してください。\

")
")

#langeng("
#para("\

Obviously, #dyncode("Z") stands for the integer 0 and #dyncode("S") for the
successor function on integers. Also, #dyncode("ans0") equals 2 as it is
the result of applying #dyncode("S") to #dyncode("Z") twice. Let
#dyncode("S2") be the function that applies #dyncode("S") twice.  It is
clear that #dyncode("ans1") is the result of applying #dyncode("S2") to
#dyncode("Z") twice and thus equals 4. With a bit more effort, one should
be able to figure out that the value of #dyncode("ans2") is 16. What is the
value of #dyncode("ans3")? In general, what is the nth value in the
sequence of #dyncode("ans0"), #dyncode("ans1"), #dyncode("ans2"), etc.?
I leave these questions as exercises for the interested reader.

")
")
#langja("
#para("\

明らかに #dyncode("Z") は整数 0 を表わし、#dyncode("S") は整数の後者関数 (Successor Function)
を表わしています。
また #dyncode("ans0") は #dyncode("S") を #dyncode("Z") に2度適用した結果なので、2 に等しくなります。
#dyncode("S2") を #dyncode("S") を2度適用する関数とします。
#dyncode("ans1") は #dyncode("S2") を #dyncode("Z")
に2度適用した結果となり、すなわち 4 に等しくなることは明確です。
もう少し考えると、 #dyncode("ans2") の値が 16 になることが分かるはずです。
#dyncode("ans3") の値はいくつでしょうか？
一般に、#dyncode("ans0"), #dyncode("ans1"), #dyncode("ans2"), などの数列の n
番目の値はいくつになるのでしょうか？
これらの疑問点は興味を持った読者への練習問題とします。

")
")

#langeng("
#para("\
Please find #mycodelink("CHAP_FUNCTION/twice.dats", "on-line")
the entire code in this section plus some additional code for testing.
")
")
#langja("
#para("\
この章のコード全体とテストのための追加コードは
#mycodelink("CHAP_FUNCTION/twice.dats", "オンライン")
から入手できます。
(訳注: このコードを atscc でコンパイルする際には -DATS_MEMALLOC_LIBC オプションが必要です。)
")
")

</sect1>

<!-- ****** ****** -->

<sect1
id="currying-and-uncurrying">
#langeng("
#title("Currying and Uncurrying")
")
#langja("
#title("カリー化とアンカリー化")
")

#langeng("
#para("\

Currying, which is named after the logician Haskell Curry, means to
turn a function taking multiple arguments simultaneously into a function of
the same body (modulo corresponding recursive function calls being changed
accordingly) that takes these arguments sequentially. Uncurrying means
precisely the opposite of currying. In the following code, both of the
defined functions #dyncode("acker1") and #dyncode("acker2") implement the
Ackermann's function (which is famous for being recursive but not primitive
recursive):

#dats2xhtml('\
fun acker1
  (m: int, n: int): int =
(
  if m > 0 then
    if n > 0 then acker1 (m-1, acker1 (m, n-1)) else acker1 (m-1, 1)
  else n+1 // end of [if]
)

fun acker2
  (m: int) (n: int): int =
(
  if m > 0 then
    if n > 0 then acker2 (m-1) (acker2 m (n-1)) else acker2 (m-1) 1
  else n+1 // end of [if]
)
')

The function #dyncode("acker2") is a curried version of #dyncode("acker1")
while the function #dyncode("acker1") in an uncurried version of
#dyncode("acker2"). Applying #dyncode("acker2") to an integer value
generates a closure-function, which causes a memory-leak unless it can be
reclaimed by garbage collection (GC) at run-time.\

")#comment("para")
")
#langja("
#para("\

論理学者 Haskell Curry の名前に由来するカリー化は、
同時に複数の引数を取る関数をそれらの引数を連続して取るような関数に本体は同じまま変換することを意味します。
アンカリー化はカリー化の反対です。
次のコードでは、
定義された関数 #dyncode("acker1") と #dyncode("acker2") はアッカーマン関数を実装しています。
この関数は原始再帰関数でない再帰として有名です:

#dats2xhtml('\
fun acker1
  (m: int, n: int): int =
(
  if m > 0 then
    if n > 0 then acker1 (m-1, acker1 (m, n-1)) else acker1 (m-1, 1)
  else n+1 // end of [if]
)

fun acker2
  (m: int) (n: int): int =
(
  if m > 0 then
    if n > 0 then acker2 (m-1) (acker2 m (n-1)) else acker2 (m-1) 1
  else n+1 // end of [if]
)
')

関数 #dyncode("acker2") は #dyncode("acker1") のカリー化されたバージョンです。
また関数 #dyncode("acker1") は #dyncode("acker2") のアンカリー化されたバージョンです。
#dyncode("acker2") を整数の値に適用するとクロージャ関数を生成します。
実行時にガベージコレクション (GC) によって回収されないと、
このクロージャ関数はメモリリークを引き起こします。\

")#comment("para")
")

#langeng("
#para("\

In functional languages such as ML and Haskell, a function of multiple
arguments needs to be either curried or translated into a corresponding
unary function of a single argument that itself is a tuple. In such
languages, currying often leads to better performance at run-time and thus
is preferred. In ATS, functions of multiple arguments are supported
directly. Also, given a function of multiple arguments, a curried version
of the function is likely to perform less efficiently at run-time than the
function itself (due to the treatment of curried functions by the ATS
compiler <command>atsopt</command>).  Therefore, the need for currying in
ATS is greatly diminished. Unless convincing reasons can be given, currying
is in general #emphasis("not") a recommended programming style in ATS.\

")#comment("para")
")
#langja("
#para("\

ML や Haskell のような関数型言語では、
複数引数の関数はカリー化するか、唯一の引数としてタプルを取る関数に変換する必要があります。
そのような言語では、カリー化はしばしば実行時の効率を向上させるので好んで使用されんます。
ATS では複数引数の関数が直接サポートされています。
また複数引数の関数が与えられた時、
その関数のカリー化されたバージョンは元のバージョンより実行時の効率が悪くなることがあります。
これは ATS コンパイラ <command>atsopt</command> のカリー化された関数の取り扱いに起因します。
そのため、ATS においてカリー化の必要性はとても小さいことになります。
一般に説得力のある理由なしに、
カリー化は ATS において推奨されるプログラミングスタイルでは#emphasis("ありません")。\

")#comment("para")
")

#langeng("
#para("\

Please find
#mycodelink("CHAP_FUNCTION/acker.dats", "on-line")
the entire code in this section plus some additional
code for testing.\

")#comment("para")
")
#langja("
#para("\

この章のコード全体と追加のテストコードは
#mycodelink("CHAP_FUNCTION/acker.dats", "オンライン")
から入手できます。
(訳注: このコードを atscc でコンパイルする際には -DATS_MEMALLOC_LIBC オプションが必要です。) \

")#comment("para")
")

</sect1>

</chapter><!--id="functions"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
