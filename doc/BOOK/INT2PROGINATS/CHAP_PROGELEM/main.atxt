%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="elements_of_programming">
#langeng("
#title("Elements of Programming")
")
#langja("
#title("プログラミングの構成要素")
")

#langeng("
#para("\
The core of ATS is a call-by-value functional programming language. I will
explain the meaning of #emphasis("call-by-value") in a moment. As
for functional programming, there is really no precise definition.  The
most important aspect of functional programming that I want to explore is
the notion of binding, which relates names to expressions.\
")
")
#langja("
#para("\
ATSのコアは即時評価(call-by-value)の関数型言語です。
この章ではしばらく #emphasis("call-by-value") の意味について説明します。
関数型プログラミングとしては厳密な定義がないためです。
これから探検する関数型プログラミングの最も重要な側面は束縛の概念です。
それは名前と式の関係を表わしています。 \
")
")

<sect1 id="expressions_and_values">
#langeng("
#title("Expressions and Values")
")
#langja("
#title("式と値")
")

#langeng("
#para("\

ATS is both syntax-rich and feature-rich, and its grammar is probably more
complex than most existing programming languages. In ATS, there are a large
variety of forms of expressions, which I will introduce gradually.\
")
")
#langja("
#para("\

ATSは豊かな構文と高機能を両立しています。
そしてその文法は多くの既存のプログラミング言語よりも、おそらく複雑です。
ATSには多様な形の式があります。
それらを少しずつ説明します。\
")
")

#langeng("
#para("\

Let us first start with some integer arithmetic expressions (IAEs):
#dyncode("1"), #dyncode("~2"), #dyncode("1+2"), #dyncode("1+2*3-4"),
#dyncode("(1+2)/(3-4)"), etc. Note that the negative sign is represented by
the tilde symbol (#dyncode("~")) in ATS.  There is also support for
floating point numbers, and some floating point constants are given here:
#dyncode("1.0"), #dyncode("~2.0"), #dyncode("3."), #dyncode("0.12345"),
#dyncode("2.71828"), #dyncode("31416E-4"), etc. Note that #dyncode("3.")
and #dyncode("31416E-4") are the same as #dyncode("3.0") and
#dyncode("3.1416"), respectively. What I really want to emphasize at this
point is that #dyncode("1") and #dyncode("1.0") are two distinct numbers in
ATS: the former is an integer while the latter is a floating point number
(of double precision).\
")
")
#langja("
#para("\

まず整数の算術式(IAE)からはじめましょう:
#dyncode("1"), #dyncode("~2"), #dyncode("1+2"), #dyncode("1+2*3-4"),
#dyncode("(1+2)/(3-4)"), などです。
負の符号はATSではチルダ (#dyncode("~")) で表わすことに注意してください。
また浮動小数点数もサポートしています。
浮動小数点数の定数をいくつか挙げてみましょう:
#dyncode("1.0"), #dyncode("~2.0"), #dyncode("3."), #dyncode("0.12345"),
#dyncode("2.71828"), #dyncode("31416E-4"), などです。
#dyncode("3.") と #dyncode("31416E-4") は
#dyncode("3.0") と #dyncode("3.1416") にそれぞれ等価であることに注意してください。
ここで強調したいことは、ATSにおいて #dyncode("1") と #dyncode("1.0")
とは全く別の数だということです。
前者は整数であるのに対して、後者は(倍精度の)浮動小数点数なのです。 \
")
")

#langeng("
#para("\

また真理値の定数もあり: #dyncode("true") と #dyncode("false") です。
真理値の式は次のような形です: #dyncode("1 >= 0"),
#dyncode("not(2-1 >= 2)"), #dyncode("(1 < 2) andalso (2 < 3)"),
#dyncode("(~1 > 1) orelse (~1 <= 1)") などです。

There are also boolean constants: #dyncode("true") and #dyncode("false").
We can form boolean expressions such as #dyncode("1 >= 0"),
#dyncode("not(2-1 >= 2)"), #dyncode("(1 < 2) andalso (2 < 3)") and
#dyncode("(~1 > 1) orelse (~1 <= 1)"), where #dyncode("not"),
#dyncode("andalso") and #dyncode("orelse") stand for negation, conjunction
and disjunction, respectively. For programmers familiar with C-like syntax,
I point out that operators #dyncode("&&") and #dyncode("||") are synonyms
for #dyncode("andalso") and #dyncode("orelse"), respectively.  \

")
")
#langja("
#para("\

また真理値の定数もあり、それは: #dyncode("true") と #dyncode("false") です。
真理値の式は次のような形です: #dyncode("1 >= 0"),
#dyncode("not(2-1 >= 2)"), #dyncode("(1 < 2) andalso (2 < 3)"),
#dyncode("(~1 > 1) orelse (~1 <= 1)") などです。
これらの式では
#dyncode("not"), #dyncode("andalso"), #dyncode("orelse")
はそれぞれ 否定, 論理積, 論理和 を表わします。
C言語の文法に馴染んだプログラマには
演算子 #dyncode("&&") と #dyncode("||") はそれぞれ
#dyncode("andalso") と #dyncode("orelse") が同じ意味であると言えばわかるでしょう。 \

")
")

#langeng("
#para('\

Other commonly used constant values include characters and strings.  For
instance, following are some character constants: #dyncode("'a'"),
#dyncode("'B'"), #dyncode("'\\\\n'") (newline), #dyncode("'\\\\t'") (tab),
#dyncode("'\\\\('") (left parenthesis), #dyncode("')'") (right
parenthesis), #dyncode("'\\\\{'") (left curly brace), #dyncode("'}'")
(right curly brace), etc; following are some string constants:
#dyncode('"My name is Zoe"'), #dyncode('"Don\'t call me \\\\"Cloe\\\\""'),
#dyncode('"this is a newline:\\\\n"'), etc.\

')
")
#langja("
#para('\

一般に使われる定数には他に文字と文字列があります。
例えば次に示すのは文字の定数です:
#dyncode("'a'"), #dyncode("'B'"), #dyncode("'\\\\n'") (改行), #dyncode("'\\\\t'") (タブ),
#dyncode("'\\\\('") (左丸括弧), #dyncode("')'") (右丸括弧),
#dyncode("'\\\\{'") (左波括弧), #dyncode("'}'") (右波括弧) などです。
さらに次に示すのは文字列の定数です:
#dyncode('"My name is Zoe"'), #dyncode('"Don\'t call me \\\\"Cloe\\\\""'),
#dyncode('"this is a newline:\\\\n"') などです。 \

')
")

#langeng("
#para("\

Given a (function) name, say, foo, and an expression exp, the expression
foo(exp) is a function application or function call. The parentheses in
foo(exp) may be dropped if no ambiguity is created by doing so. For
instance, #dyncode('print("Hello")') is a function application, which can
also be written as #dyncode('print "Hello"').  If foo is a nullary
function, then a function application foo() can be formed.  If foo is a
binary function, then a function application foo(exp1, exp2) can be formed
for expressions exp1 and exp2. Functions of more arguments can be treated
accordingly.\

")
")
#langja("
#para("\

関数名fooと式expが与えられた時、式 foo(exp) は関数適用または関数呼び出しです。
あいまいさがない場合には foo(exp) の小括弧ははずすことができます。
例えば #dyncode('print("Hello")') は関数適用であり、
また #dyncode('print "Hello"') と書くこともできます。

もしfooが引数のない関数であった場合、 foo() という関数適用を取れます。
もしfooが2引数の関数でありexp1とexp2が式であった場合、 foo(exp1, exp2) という関数適用を取れます。
より多くの引数を取る関数についてはわかると思います。\

")
")

#langeng("
#para("\

Note that we cannot write #dyncode("+(1,2)") as the name #dyncode("+") has
already been given the infix status requiring that it be treated as an
infix operator.  However, we can write #dyncode("op+(1,2)"), where
#dyncode("op") is a keyword in ATS that can be used to temporarily suspend
the infix status of any name immediately following it. I will explain in
detail the issue of fixity (prefix, infix and postfix) elsewhere.\

")
")
#langja("
#para("\

#dyncode("+(1,2)") とは書けないことに注意してください。
#dyncode("+") という名前は中置演算子として既に定義されてしまっています。
けれども #dyncode("op+(1,2)") と書くことはできます。
ATSにおいて #dyncode("op") はキーワードで、後ろに続く名前の中置記法設定を一時的に無効化します。
結合性(前置, 中置, 後置)についての詳細は別の章で説明します。 \

")
")

#langeng("
#para("\

Values are essentially expressions of certain special forms, which cannot
be reduced or simplified further. For instance, integer constants such as
#dyncode("1") and #dyncode("~2") are values, but the integer expression
#dyncode("1+2") is not a value, which can be reduced to the value
#dyncode("3").  Evaluation refers to the computational process that reduces
a given expression into a value. However, certain expressions such as
#dyncode("1/0") cannot be reduced to a value, and evaluating such an
expression must abort at some point. I will gradually present more
information on evaluation.\

")
")
#langja("
#para("\

値は、これ以上単純化できない特殊な形の式でです。
例えば #dyncode("1") や #dyncode("~2") のような整数の定数は値です。
しかし整数の式 #dyncode("1+2") は値ではありません。
なぜなら値 #dyncode("3") に単純化できるからです。
評価とは与えられた式を値になるまで単純化する計算過程です。
けれども #dyncode("1/0") のような式は単純化して値にすることができません。
このような式の評価はどこかで中断されなければなりません。
評価については後でゆっくり説明します。 \

")
")

</sect1><!--id="expressions_and_values"-->

#comment(" ****** ****** ")

<sect1 id="names_and_bindings">
#langeng("
#title("Names and Bindings")
")
#langja("
#title("名前と束縛")
")

#langeng("
#para("\

A crucial aspect of a programming language is the mechanism it provides for
binding names, which are themselves expressions, to expressions. For
instance, a declaration is introduced by the following syntax that declares
a binding between the name #dyncode("x"), which is also referred to as a
variable, and the expression #dyncode("1+2"):\

")
")
#langja("
#para("\

プログラミング言語の決定的な側面は名前を式に束縛するためのしくみです。
さらにその名前自身が式になります。

例えば次の構文で表わされるのは、
式 #dyncode("1+2") を名前 #dyncode("x") に束縛すする宣言です。
また #dyncode("x") も値として参照されます。\

")
")

<informalexample><programlisting>
val x = 1 + 2
</programlisting></informalexample>

#langeng("
#para("\

Note that #dyncode("val") is a keyword in ATS, and the declaration is
classified as a val-declaration. Conceptually, what happens at run-time in
a call-by-value language such as ATS is that the expression #dyncode("1+2")
is first evaluated to the value #dyncode("3"), and then the binding between
#dyncode("x") and #dyncode("1+2") is #emphasis("finalized") into a binding
between #dyncode("x") and #dyncode("3"). Essentially, call-by-value means
that a binding between a name and an expression needs to be finalized into
one between the name and the value of the expression before it can be used
in evaluation subsequently. As another example, the following syntax
declares three bindings, two of which are formed simultaneously in the
first line:\

")
")
#langja("
#para("\

ATSでは  #dyncode("val") はキーワードであることに注意してください。
またその宣言はval宣言として分類されます。

概念上、ATSのような即時評価(call-by-value)の言語において実行時に起きることは、
まずはじめに式 #dyncode("1+2") が値 #dyncode("3") に評価されます。
次に #dyncode("x") と #dyncode("1+2") の間に束縛ができ、
#dyncode("x") と #dyncode("3") の間に束縛が #emphasis("決着(finalized)") します。
本質的に即時評価とは、
名前と式の束縛はそれ以降の評価で使われる前に、
その名前とその式の値の束縛に決着されなければならないことを意味します。
別の例としては、次の構文では3つの束縛を宣言しています。
最初の行ではその内2つが同時に宣言されています。 \

")
")

<informalexample><programlisting>
val PI = 3.14 and radius = 10.0
val area = PI * radius * radius
</programlisting></informalexample>

#langeng("
#para("\

Note that it is unspecified in ATS as to which of the first two bindings
(connected by the keyword #dyncode("and")) is finalized ahead of the other
at run-time. However, it is guaranteed that the third binding is finalized
after the first two are done. To see this issue from a different angle, we
can try to typecheck the following code:

<informalexample><programlisting>
val x = 0 and y = x + 1
</programlisting></informalexample>

The error message reported in this case indicates that the name (or dynamic
identifier) #dyncode("x") in the expression #dyncode("x + 1") is unbound.
In particular, the two occurrences of #dyncode("x") in the above code are
unrelated.

")
")
#langja("
#para("\

#dyncode("and") キーワードで繋がっている最初の2つの束縛のどちらが先に実行時に決着されるかは、
ATSにおいては未定義であることに注意してください。
けれども3つ目の束縛は最初の2つが完了した後に決着されることは保証されています。
この論点を別の角度から見るために、次のコードを型検査してみましょう。

<informalexample><programlisting>
val x = 0 and y = x + 1
</programlisting></informalexample>

この場合、エラーメッセージは式 #dyncode("x + 1")
の中にある名前(もしくは動的な識別子) #dyncode("x") が束縛されていないことを示しています。
具体的には上記のコードの中にある2つの #dyncode("x") 同士に関係がないのです。

")
")

</sect1><!--id="names_and_bindings"-->

<!-- ****** ****** -->

<sect1 id="scopes_for_bindings">
#langeng("
#title("Scopes for Bindings")
")
#langja("
#title("束縛のスコープ")
")

#langeng("
#para("\

Each binding is given a fixed scope in which the binding is considered
legal or effective. The scope of a toplevel binding in a file starts from
the point where the binding is introduced until the very end of the
file. The bindings introduced in the following example between the keywords
#dyncode("let") and #dyncode("in") are effective until the keyword
#dyncode("end") is reached:\

")
")
#langja("
#para("\

それぞれの束縛は、それが有効である固定のスコープを持っています。
ファイルの中にあるトップレベルの束縛のスコープは束縛が作られた場所からファイルの終端までです。
次の例では #dyncode("let") と #dyncode("in") キーワードの間で束縛が作られていて、
その束縛は #dyncode("end") キーワードまで有効です。 \

")
")

<informalexample><programlisting>
val area = let
  val PI = 3.14 and radius = 10.0 in PI * radius * radius
end // end of [let]
</programlisting></informalexample>

#langeng("
#para("\

Such bindings are referred to as local bindings, and the names such as
#dyncode("PI") and #dyncode("radius") are referred to as local names.  This
example can also be written in the following style:\

")
")
#langja("
#para("\

このような束縛はローカル束縛と呼ばれていて、
#dyncode("PI") や #dyncode("radius") のような名前はローカル名と呼ばれています。
この例は以下のようなスタイルでも書くことができます。 \

")
")

<informalexample><programlisting>
val area =
  PI * radius * radius where {
  val PI = 3.14 and radius = 10.0 // simultaneous bindings
} // end of [where] // end of [val]
</programlisting></informalexample>

#langeng("
#para("\

The keyword #dyncode("where") appearing immediately after an expression
introduces bindings that are solely effective for evaluating names
contained in the expression.  Note that expressions formed using the
keywords #dyncode("let") and #dyncode("where") are often referred to as
let-expressions and where-expressions, respectively. The former can always
be translated into the latter directly and vice versa.  Which style is
better? I have not formed my opinion yet. The answer seems to entirely
depend on the taste of the programmer.\

")
")
#langja("
#para("\

式の直後に現われるキーワード #dyncode("where") は、
その式に含まれている名前を評価するためのみ有効な束縛を表わしています。
しばしば、キーワード #dyncode("let") と #dyncode("where")
を使って構成された式は、それぞれlet式とwhere式と呼ばれます。
前者はかならず後者に変換でき、また逆にもかならず変換できます。
どちらがより良いスタイルなのでしょうか？
私はまだ自分の意見を持っていません。
その答はプログラマの好みに完全に依存していると思われます。 \

")
")

#langeng("
#para("\

The following example demonstrates an alternative approach to introducing
local bindings:

<informalexample><programlisting>
local

val PI = 3.14 and radius = 10.0

in (* in of [local] *)

val area = PI * radius * radius

end // end of [local]
</programlisting></informalexample>

where the bindings introduced between the keywords #dyncode("local") and
#dyncode("in") are effective until the keyword #dyncode("end") is
reached. Note that the bindings introduced between the keywords
#dyncode("in") and #dyncode("end") are themselves toplevel bindings. The
difference between #dyncode("let") and #dyncode("local") should be clear:
The former is used to form an expression while the latter is used to
introduce a sequence of declarations.\

")
")
#langja("
#para("\

次の例はローカル束縛を作るまた別のアプローチを示しています。

<informalexample><programlisting>
local

val PI = 3.14 and radius = 10.0

in (* in of [local] *)

val area = PI * radius * radius

end // end of [local]
</programlisting></informalexample>

キーワード #dyncode("local") と #dyncode("in") の間で作られた束縛は、
キーワード #dyncode("end") に逹っするまで有効です。
#dyncode("in") と #dyncode("end")の間で作られた束縛は、
トップレベルの束縛になることに注意してください。
#dyncode("let") と #dyncode("local") の違いは明確です。
前者は式を構成するのに使い、後者は宣言を列挙するのに使います。 \

")
")

</sect1><!--id="scopes_for_bindings"-->

<!-- ****** ****** -->

<sect1 id="environments_for_evaluation">
#langeng("
#title("Environments for Evaluation")
")
#langja("
#title("評価のための環境")
")

#langeng("
#para("\
Evaluation is the computational process that reduces expressions to
values.  When performing evaluation, we need not only the expression to be
evaluated but also a collection of bindings that map names in the
expression to values. This collection of bindings, which is just a finite
mapping, is often referred to as an environment (for evaluation). For
instance, suppose that we want to evaluate the following expression:

<informalexample><programlisting>
let
  val PI = 3.14 and radius2 = 10.0 * 10.0 in PI * radius2
end
</programlisting></informalexample>

We start with the empty environment ENV0; we evaluate #dyncode("3.14") to
itself and #dyncode("10.0 * 10.0") to #dyncode("100.0") under the
environment ENV0; we then extend ENV0 to ENV1 with two bindings mapping
#dyncode("PI") to #dyncode("3.14") and #dyncode("radius2") to
#dyncode("100.0"); we then evaluate #dyncode("PI * radius2") under ENV1
to #dyncode("3.14 * radius2"), then to #dyncode("3.14 * 100.0"), and
finally to #dyncode("314.0"), which is the value of the let-expression.\
")
")
#langja("
#para("\
評価とは式を値になるまで単純化する計算過程です。
評価を実行するには、評価される式だけではなく、
その式の中にある名前を値に変換するために束縛の集合も必要です。
この束縛の集合は単なる連想配列で、しばしば(評価のための)環境と呼ばれます。
例えば次の式を評価することを考えてみましょう。

<informalexample><programlisting>
let
  val PI = 3.14 and radius2 = 10.0 * 10.0 in PI * radius2
end
</programlisting></informalexample>

空の環境であるENV0から開始します。
まず環境ENV0において #dyncode("3.14") をそれ自身に、
#dyncode("10.0 * 10.0") を #dyncode("100.0") に評価します。
次にENV0拡張して、
#dyncode("PI") から #dyncode("3.14") に #dyncode("radius2") から #dyncode("100.0")
に変換する2つの束縛をともなうENV1を作ります。
それからENV1において #dyncode("PI * radius2") を #dyncode("3.14 * radius2") に評価し、
さらに #dyncode("3.14 * 100.0") に評価します。
最後に #dyncode("314.0") が得られて、これがlet式の値になります。 \
")
")

</sect1><!--id="environments_for_evaluation"-->

<!-- ****** ****** -->

<sect1 id="static_semantics">
#langeng("
#title("Static Semantics")
")
#langja("
#title("静的な意味論")
")

#langeng("
#para("\
ATS is a programming language equipped with a highly expressive type
system rooted in the #emphasis("Applied Type System") framework,
which also gives ATS its name. I will gradually introduce the type system
of ATS, which is probably the most outstanding and interesting part of this
book.\
")
")
#langja("
#para("\
ATSは #emphasis("Applied Type System") フレームワークを根源とする、
高度に表現力のある型システム備えたプログラミング言語です。
それはまたATSという言語の名前にもなっています。
ATSの型システムを徐々に説明します。
おそらくこの本で最も突出していて興味深い部分でしょう。 \
")
")

#langeng("
#para("\
It is common to treat a type as the set of values it classifies.
However, I find it more approriate to treat a type as a form of
meaning. There are formal rules for assigning types to expressions, which
are referred to as typing rules.  If a type T can be assigned to an
expression, then I say that the expression possesses the static meaning
(semantics) represented by the type T. Note that an expression may be
assigned many distinct static meanings.  An expression is well-typed if
there exists a type T such that the expression can be assigned the type T.\
")
")
#langja("
#para("\
一般には、型を分類された値の集合のように扱います。
けれども、私は型を意味の形として扱う方がより適切であることを見つけました。
式に型を割り振る形式的な規則があり、それは型付け規則と呼ばれています。
もし式に型Tを割り振ることができるとします。
するとその式は型Tで表現された静的な意味(意味論)を持つと言えるのです。
一つの式には複数の異なる静的な意味論を割り振られる可能性があることに注意してください。
もし式に割り振り可能な型Tが唯一1つだけ存在するなら、その式は正しい型付けをされていることになります。 \
")
")

#langeng("
#para("\
If there is a binding between a name and an expression and the
expression is of some type T, then the name is assumed to be of the type T
in the effective scope of the binding. In other words, the name assumes the
static meaning of the expression it refers to.\
")
")
#langja("
#para("\
もし型Tを持つ式と名前とを繋ぐ束縛が存在するなら、
束縛が有効なスコープにおいてその名前は型Tであると見なされます。
言い方を代えると、その名前は対応する式の持つ静的な意味を取るということになります。 \
")
")

#langeng("
#para("\

Let exp0 be an expression of some type T, that is, the type T can be
assigned to exp0 according to certain typing rules. If we can evaluate exp0
to exp1, then exp1 can also be assigned the type T. In other words, static
meaning is an invariant under evaluation. This property is often referred
to as #emphasis("type preservation"), which is part of the soundness of the
type system of ATS. Based on this property, we can readily infer that any
value is of the type T if exp0 can be evaluated to it (in many steps).\

")
")
#langja("
#para("\

exp0が型Tの式であるとしましょう。
つまり型Tがexp0に型付け規則によって割り振られたとします。
exp0をexp1に評価できるなら、exp1もまた型Tが割り振れることになります。
別の言い方をすると、静的な意味は評価の中で不変であると言えるわけです。
この特性はしばしば #emphasis("型保存(type preservation)") と呼ばれます。
これはATSの型システムにおける健全性の一部です。
この特性に基づくと、私達はexp0がいくつかのステップで評価されて値をになるとしても、
型Tの取りうる値をたやすく推察することができるのです。 \

")
")

#langeng("
#para("\

Let exp0 be an expression of some type T. Assume that exp0 is not a value.
Then exp0 can always be evaluated one step further to another expression
exp1. This property is often referred to as #emphasis("progress"), which is
another part of the soundness of the type system of ATS.\

")
")
#langja("
#para("\

exp0が型Tの式であり、またexp0は値ではないとします。
するとexp0は1ステップで別の式であるexp1に評価することがいつでも可能です。
この特性はしばしば #emphasis("プログレス(progress)") と呼ばれます。
そしてこれはATSの型システムにおける健全性のもう一つの部分です。 \

")
")

</sect1><!--id="static_semantics"-->

<!-- ****** ****** -->

<sect1 id="primitive_types">
#langeng("
#title("Primitive Types")
")
#langja("
#title("プリミティブ型")
")

#langeng("
#para("\

The simplest types in ATS are primitive types, which are used to classify
primitive values. For instance, we have the primitive types #dyncode("int")
and #dyncode("double"), which classify integers (in a fixed range) and
floating point numbers (of double precision), respectively.\

")
")
#langja("
#para("\

ATSにおいて最も単純な型は、プリミティブな値を分類するのに使われるプリミティブ型です。
例えば #dyncode("int") と #dyncode("double") というプリミティブ型があります。

これらはそれぞれ固定長の整数の整数と倍精度の浮動小数点数を分類しています。 \

")
")

#langeng("
#para("\

In the current implementation of ATS (Postiats), a program in ATS is first
compiled into one in C (conforming to the C99 standard), which can then be
compiled to object code by a compiler for C such as gcc. In the compilation
from ATS to C, the type #dyncode("int") in ATS is translated to the type of
the same name in C. Similarly, the type #dyncode("double") in ATS is
translated to the type of the same name in C.\

")
")
#langja("
#para("\

ATS (Postiats)の現時点でも実装では、ATSプログラムはまずC99に従ったC言語にコンパイルされます。
それからgccのようなC言語コンパイラによってオブジェクトコードにコンパイルすることができます。
ATSからC言語へのコンパイルにおいて、
ATSの #dyncode("int") 型はC言語の同名の型に変換されます。
同様にATSの #dyncode("double") 型はC言語の同名の型に変換されます。 \

")
")

#langeng("
#para("\

There are many other primitive types in ATS, and I will introduce
them gradually.  Some commonly used primitive types are listed as follows:

<itemizedlist>

<listitem>
#para("\
#stacode("bool"):
This type is for boolean values #dyncode("true") and #dyncode("false"),
and it is translated into the int type in C.\
")
</listitem>

<listitem>
#para("\
#stacode("char"):
This type is translated into the type in C for characters.\
")
</listitem>

<listitem>
#para("\
#stacode("schar"):
This type is translated into the type in C for signed characters.\
")
</listitem>

<listitem>
#para("\
#stacode("uchar"):
This type is translated into the type in C for unsigned characters.\
")
</listitem>

<listitem>
#para("\
#stacode("float"):
This type is translated into the type in C for floating point numbers of
single precision.\
")
</listitem>

<listitem>
#para("\
#stacode("uint"):
This type is translated into the type in C for unsigned integers.\
")
</listitem>

<listitem>
#para("\
#stacode("lint"):
This type is translated into the type in C for long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("ulint"):
This type is translated into the type in C for unsigned long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("llint"):
This type is translated into the type in C for long long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("ullint"):
This type is translated into the type in C for unsigned long long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("size_t"):
This type is translated into the type in C of the same name, which is for
unsigned integers of certain precision. Usually, the type #stacode("size_t")
can be treated as the type #stacode("ulint") and vice versa.\
")
</listitem>

<listitem>
#para("\
#stacode("ssize_t"):
This type is translated into the type in C of the same name, which is for
signed integers of certain precision. Usually, the type #stacode("ssize_t")
can be treated as the type #stacode("lint") and vice versa.\
")
</listitem>

<listitem>
#para("\
#stacode("string"):
This type is for strings, and its translation in C is the type for
pointers. I will explain this translation elsewhere.\
")
</listitem>

<listitem>
#para("\
#stacode("void"):
This type is for the void value, and its translation in C is the type of
the same name. It should be noted that the void value is unspecified in
ATS. I often say that a function returns no value if it returns the void
value, and vice versa.\
")
</listitem>

</itemizedlist>

I will gradually present programming examples involving various primitive types and
values.\

")
")
#langja("
#para("\

ATSでは他にも多くのプリミティブ型がありますが、少しづつ解説します。
一般的に使われるいくつかのプリミティブ型を次に示します。

<itemizedlist>

<listitem>
#para("\
#stacode("bool"):
この型は真理値の #dyncode("true") か #dyncode("false") を取り、C言語のint型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("char"):
この型はC言語の文字型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("schar"):
この型はC言語の符号付き文字型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("uchar"):
この型はC言語の符号無し文字型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("float"):
この型はC言語の単精度浮動小数点型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("uint"):
この型はC言語の符号無し整数型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("lint"):
この型はC言語の長整数型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("ulint"):
この型はC言語の符号無し長整数型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("llint"):
この型はC言語の長長整数型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("ullint"):
この型はC言語の符号無し長長整数型に変換されます。 \
")
</listitem>

<listitem>
#para("\
#stacode("size_t"):
この型はC言語の同名の型に変換されます。
これは符号無し整数型と同じ精度です。
通常 #stacode("size_t") 型は #stacode("ulint") 型と等価に扱われます。 \
")
</listitem>

<listitem>
#para("\
#stacode("ssize_t"):
この型はC言語の同名の型に変換されます。
これは符号無し整数型と同じ精度です。
通常 #stacode("ssize_t") 型は #stacode("lint") 型と等価に扱われます。 \
")
</listitem>

<listitem>
#para("\
#stacode("string"):
この型は文字列のためのもので、C言語のポインタ型に変換されます。
この変換については別の章で解説します。 \
")
</listitem>

<listitem>
#para("\
#stacode("void"):
この型はvoid値のためのもので、C言語の同名の型に変換されます。
ATSにおいてvoid値が未定義であることに注意すべきでしょう。
関数がvoid値を返す場合には、しばしば関数が値を返さないと言うことがあります。 \
")
</listitem>

</itemizedlist>

様々なプリミティブ型と値を含むプログラム例を徐々に紹介します。 \

")
")

</sect1><!--id="primitive_types"-->

<!-- ****** ****** -->

<sect1 id="tuples_and_tuple_types">
#langeng("
#title("Tuples and Tuple Types")
")
#langja("
#title("タプルとタプル型")
")

#langeng("
#para("\

Given two types T1 and T2, we can form a tuple type (T1, T2), which can
also be written as @(T1, T2).  Assume that exp1 and exp2 are two
expressions of the types T1 and T2, respectively. Then the expression
(exp1, exp2), which can also be written as @(exp1, exp2), refers to a tuple
of the tuple type (T1, T2). Accordingly, we can form tuples and tuple types
of more components. In order for a tuple type to be assigned to a tuple,
the tuple and the tuple type must have the equal number of components.\

")
")
#langja("
#para("\

2つの型T1とT2が与えられた時、タプル型である (T1, T2) を作ることがきます。
これは @(T1, T2) のように書くこともできます。
exp1とexp2がそれぞれT1とT2型の式であるとしましょう。
すると式 (exp1, exp2) または @(exp1, exp2) は (T1, T2) 型のタプルであることになります。
さらに、より多くの要素を持つタプルとタプル型を作ることもできます。
タプルにタプル型を割り振るために、
そのタプルとそのタプル型は持っている要素が同じ数でなければなりません。 \

")
")

#langeng("
#para("\

When evaluating a tuple expression, we evaluate all of its components
#emphasis("sequentially"). Suppose that the expression contains n
components, then the value of the expression is the tuple consisting of the
n values of the n components listed in the order as the components
themselves.\

")
")
#langja("
#para("\

タプルの式を評価する時、その要素すべてを #emphasis("連続して(sequentially)") 評価します。
その式がn個の要素を持っていたと想像してみましょう。
するとその式の値は、
要素の順に列挙されたn個の要素の値によって構成されているタプルであることになります。 \

")
")

#langeng("
#para("\

A tuple of length n for n >= 2 is just a record of field names ranging from
0 until n-1, inclusive. Given an expression exp of some tuple type (T1,
T2), we can form expressions (exp).0 and (exp).1, which are of types T1 and
T2, respectively. Note that the expression exp does not have to be a tuple
expression. For instance, exp may be a name or a function application. If
exp evaluates to a tuple of two values, then exp.0 evaluates to the first
value and exp.1 the second value. Clearly, if the tuple type of exp
contains more components, what is stated can be generalized accordingly.\

")
")
#langja("
#para("\

2以上の長さnのタプルは、フィールド名は0からn-1までの範囲を取る単なるレコードです。
タプル型 (T1, T2) の式 exp が与えられた時、
(exp).0 や (exp).1 のような式を作ることができます。
これらはそれぞれT1型とT2型を取ります。
式expは必ずしもタプルの式である必要はないことに注意してください。
例えば、expは名前や関数適用であってもかまいません。
もしexpを評価して2つの値を持つタプルになった場合、
exp.0は1番目の値に評価され、exp.1は二番目の値に評価されることになります。
expのタプル型がより多くの要素を持っていた場合、
当然このような式は一般化できます。 \

")
")

#langeng("
#para("\

In the following example, we first construct a tuple of length 3 and then
introduce bindings between 3 names and all of the 3 components of the
tuple:

<informalexample><programlisting>
val xyz = ('A', 1, 2.0)
val x = xyz.0 and y = xyz.1 and z = xyz.2
</programlisting></informalexample>

Note that the constructed tuple can be assigned the tuple type
#stacode("(char, int, double)"). Another method for selecting components in
a given tuple is based on pattern matching, which is employed in the
following example:

<informalexample><programlisting>
val xyz = ('A', 1, 2.0)
val (x, y, z) = xyz // x = 'A'; y = 1; z = 2.0
</programlisting></informalexample>

Note that #dyncode("(x, y, z)") is a pattern that can match any tuples of
exact 3 components. I will say more about pattern matching elsewhere.
")
")
#langja("
#para("\

次に占めす例では、はじめに長さが3のタプルを作り、
そのタプルの3つの要素全てに3つの名前を束縛しています。

<informalexample><programlisting>
val xyz = ('A', 1, 2.0)
val x = xyz.0 and y = xyz.1 and z = xyz.2
</programlisting></informalexample>

作られたタプルには #stacode("(char, int, double)") というタプル型が割り振られることに注意してください。
タプルの要素を選択する他の方法には、次の例に示すパターンマッチがあります。

<informalexample><programlisting>
val xyz = ('A', 1, 2.0)
val (x, y, z) = xyz // x = 'A'; y = 1; z = 2.0
</programlisting></informalexample>

#dyncode("(x, y, z)")
は、ぴったり3要素のタプルにマッチするパターンであることに注意してください。
その他のパターンマッチについては別の章で説明します。
")
")

#langeng("
#para("\

The tuples introduced above are often referred to as flat tuples, native
tuples or unboxed tuples. There is another kind of tuples supported in ATS,
which are called boxed tuples. A boxed tuple is essentially a pointer
pointing to some heap location where a flat tuple is stored.\

")
")
#langja("
#para("\

ここまで紹介してきたタプルはしばしば
フラットタプル、ネイティブタプル、アンボックス化タプルなどと呼ばれます。
ATSはまた別の種類のタプルをサポートしており、それはボックス化タプルと呼ばれています。
ボックス化タプルは本質的に、フラットタプルが配置されたヒープを指すポインタです。 \

")
")

#langeng("
#para("\

Assume that exp1 and exp2 are two expressions of the types T1 and T2,
respectively. Then the expression '(exp1, exp2), refers to a tuple of the
tuple type '(T1, T2). Accordingly, we can form boxed tuples and boxed tuple
types of fewer or more components. What should be noted immediately is that
every boxed tuple is of the size of a pointer, and can thus be stored in
any place where a pointer can. Using boxed tuples is rather similar to
using unboxed ones. For instance, the meaning of the following code should
be evident:

<informalexample><programlisting>
val xyz = '( 'A', 1, 2.0 )
val x = xyz.0 and y = xyz.1 and z = xyz.2
</programlisting></informalexample>

Note that a space is needed between #dyncode("'(") and #dyncode("'A'")
for otherwise the current parser (for ATS/Postiats) would be confused.\

")
")
#langja("
#para("\

またexp1とexp2がそれぞれ型T1とT2の式であるとします。
式 '(exp1, exp2) はタプル型 '(T1, T2) のタプルになります。
結果的に、異なる要素数のボックス化タプルとボックス化タプル型も作ることができます。
注意するべきなのは、全てのボックス化タプルのサイズはポインタのものと同じであるということです。
そのためポインタが格納できる場所であれば、ボックス化タプルも格納することができます。
ボックス化タプルの使い方はアンボックス化タプルの使い方とよく似ています。
例えば、次のコードの意味はすぐにわかります。

<informalexample><programlisting>
val xyz = '( 'A', 1, 2.0 )
val x = xyz.0 and y = xyz.1 and z = xyz.2
</programlisting></informalexample>

#dyncode("'(") と #dyncode("'A'") の間に空白を入れないと、
ATS/Postiats の今のパーサが混乱してしまうことに注意してください。 \

")
")

#langeng("
#para("\

Given the availability of flat and boxed tuples, one naturally wants to
know whether there is a simple way to determine which kind is preferred
over the other. Unfortunately, there is no simple way to do this as far as
I can tell. In order to be certain, some kind of profiling is often
needed. However, if we want to run code with no support of garbage
collection (GC), then we should definitely avoid using boxed tuples.\

")
")
#langja("
#para("\

フラットタプルとボックス化タプルの可用性があると、
どちらの種類がより良いのか決める手掛かりを当然知りたくなるでしょう。
残念ながら私の知るかぎり、そのような方法はありません。
確実に言えることは、プロファイリングすることがしばしば必要になるということです。
けれども、もしGCを含まないコードを実行したいのであれば、
明らかにボックス化タプルを使うべきではありません。 \

")
")

</sect1><!--id="tuples_and_tuple_types"-->

<!-- ****** ****** -->

<sect1 id="records_and_record_types">
#langeng("
#title("Records and Record Types")
")
#langja("
#title("レコードとレコード型")
")

#langeng("
#para("\
A record is just like a tuple except that each field name of the
record is chosen by the programmer (instead of being fixed). Similarly, a
record type is just like a tuple type.  For instance, a record type
#stacode("point2D") is defined as follows:

<informalexample><programlisting>
typedef point2D = @{ x= double, y= double }
</programlisting></informalexample>

where #dyncode("x") and #dyncode("y") are the names of the two fields in
a record value of this type. We also refer to a field in a record as a
component. The special symbol #dyncode("@{") indicates that the formed
type is for flat/native/unboxed records. A value of the type
#stacode("point2D") is constructed as follows and given the name
#dyncode("theOrigin"):

<informalexample><programlisting>
val theOrigin = @{ x= 0.0, y= 0.0 } : point2D
</programlisting></informalexample>
")
")
#langja("
#para("\
レコードそれぞれのフィールド名をプログラマによって決定できるという点を除けば、
レコードはタプルと良く似ています。
同様にレコード型もタプル型と良く似ています。
例えばレコード型 #stacode("point2D") は以下のように定義できます。

<informalexample><programlisting>
typedef point2D = @{ x= double, y= double }
</programlisting></informalexample>

#dyncode("x") と #dyncode("y") はこの型のレコード値における2つのフィールドの名前です。
またレコードのフィールドのことを要素と呼ぶことがあります。

特殊な記号である #dyncode("@{") はその型が
フラット/ネイティブ/アンボックス化 レコードであることを表わします。
型 #stacode("point2D") の値は次のように #dyncode("theOrigin") という名前で生成することができます。

<informalexample><programlisting>
val theOrigin = @{ x= 0.0, y= 0.0 } : point2D
</programlisting></informalexample>
")
")

#langeng("
#para("\
We can use the standard dot notation to extract out a selected component in
a record, and this is shown in the next line of code:

<informalexample><programlisting>
val theOrigin_x = theOrigin.x and theOrigin_y = theOrigin.y
</programlisting></informalexample>

Alternatively, we can use pattern matching for doing component extraction
as is done in the next line of code:

<informalexample><programlisting>
val @{ x= theOrigin_x, y= theOrigin_y } = theOrigin
</programlisting></informalexample>

In this case, the names #dyncode("theOrigin_x") and
#dyncode("theOrigin_y") are bound to the components in
#dyncode("theOrgin") that are named #dyncode("x") and #dyncode("y"),
respectively. If we only need to extract out a selected few of components
(instead of all the available ones), we can make use of the following
kind of patterns:

<informalexample><programlisting>
val @{ x= theOrigin_x, ... } = theOrigin // the x-component only 
val @{ y= theOrigin_y, ... } = theOrigin // the y-component only 
</programlisting></informalexample>

If you find all this syntax for component extraction to be confusing, then
I suggest that you stick to the dot notation. I myself rarely use pattern
matching on record values.
")
")
#langja("
#para("\
レコードから要素を選択するために一般的なドット表記を使うことができます。
次のようなコードになります。

<informalexample><programlisting>
val theOrigin_x = theOrigin.x and theOrigin_y = theOrigin.y
</programlisting></informalexample>

あるいは要素の選択にパターンマッチを使うこともできます。
これは次のようなコードになります。

<informalexample><programlisting>
val @{ x= theOrigin_x, y= theOrigin_y } = theOrigin
</programlisting></informalexample>

この例では #dyncode("theOrigin_x") と #dyncode("theOrigin_y") の名前はそれぞれ、
#dyncode("theOrgin") の中にある #dyncode("x") と #dyncode("y") という名前の要素に束縛されています。
もし要素全てではなく一部を選択したい場合には、次のようなパターンマッチを使うことができます。

<informalexample><programlisting>
val @{ x= theOrigin_x, ... } = theOrigin // the x-component only 
val @{ y= theOrigin_y, ... } = theOrigin // the y-component only 
</programlisting></informalexample>

もしもこの文法に混乱するようであれば、ドット表記を使うことをおすすめします。
レコード値のパターンマッチは私自身あまり使いません。
")
")

#langeng("
#para("\
Compared with handling native/flat/unboxed records, the only change
needed for handling boxed records is to replace the special symbol
#dyncode("@{") with another one: #dyncode("'{"), which is a quote
followed immediately by a left curly brace.\
")
")
#langja("
#para("\
ネイティブ/フラット/アンボックス化 レコードと比較してボックス化レコードを扱うのに必要なことは、
特殊記号を代えるだけです。
つまり #dyncode("@{") を #dyncode("'{") に代えるだけです。 \
")
")

</sect1><!--id="records_and_record_types"-->

<!-- ****** ****** -->

<sect1 id="conditional_expressions">
#langeng("
#title("Conditional Expressions")
")
#langja("
#title("条件式")
")

#langeng("
#para("\
A conditional expression consists of a test and two branches. For instance,
the following expression is conditional:

<informalexample><programlisting>
if (x >= 0) then x else ~x
</programlisting></informalexample>

where #dyncode("if"), #dyncode("then") and #dyncode("else") are keywords
in ATS. In a conditional expression, the expression following
#dyncode("if") is the test and the expressions following #dyncode("then")
and #dyncode("else") are referred to as the then-branch and the
else-branch (of the conditional expression), respectively.
")
")
#langja("
#para("\
条件式は比較と2つの分岐から構成されています。
例えば次の式は条件式です。

<informalexample><programlisting>
if (x >= 0) then x else ~x
</programlisting></informalexample>

#dyncode("if"), #dyncode("then"), #dyncode("else") はATSのキーワードです。
条件式では#dyncode("if") 直後の式が比較式、
#dyncode("then") と #dyncode("else") 直後の式はそれぞれthen分岐とelse分岐と呼ばれます。
")
")

#langeng("
#para("\

In order to assign a type T to a conditional expression, we need to assign
the type #dyncode("bool") to the test and the type T to both of the
then-branch and the else-branch. For instance, the type #dyncode("int") can
be assigned to the above conditional expression if the name #dyncode("x")
is given the type #dyncode("int").  ")
")
#langja("
#para("\

型Tを条件式に割り振るために、 #dyncode("bool") 型をその比較に割り振り、
型Tをthen分岐とelse分岐の両方に割り振る必要があります。
例えば名前 #dyncode("x") が #dyncode("int") 型であれば、
先の例の条件式には #dyncode("int") 型を割り振ることができます。 ")
")

#langeng("
#para("\

Suppose that we have a conditional expression that is well-typed. When
evaluating it, we first evaluate the test to a value, which is guaranteed
to be either #dyncode("true") or #dyncode("false"); if the value is
#dyncode("true"), then we continue to evaluate the then-branch; otherwise,
we continue to evaluate the else-branch.  ")
")
#langja("
#para("\

条件式が正しく型付けできていることを想像してみましょう。
その条件式が評価されるとまずはじめに比較を評価して値を得ることになります。
この値は #dyncode("true") もしくは #dyncode("false") であることが保証されています。
値が #dyncode("true") であればthen分岐が評価されます。
そうでなければelse分岐が評価されることになるわけです。 ")
")

#langeng("
#para("\

It is also allowed to form a conditional expression where the else-branch
is missing or truncated. For instance, we can form an expression as follows:

<informalexample><programlisting>
if (x >= 0) then print(x)
</programlisting></informalexample>

which is equivalent to the following conditional expression:

<informalexample><programlisting>
if (x >= 0) then print(x) else ()
</programlisting></informalexample>

Note that #dyncode("()") stands for the void value (of the type
#stacode("void")). If a type can be assigned to a conditional expression
in the truncated form, then the type must be #stacode("void").\
")
")
#langja("
#para("\

else分岐を省略した条件式を作ることもできます。
例えば次のような式を作ることができます。

<informalexample><programlisting>
if (x >= 0) then print(x)
</programlisting></informalexample>

これは次の条件式と等価です。

<informalexample><programlisting>
if (x >= 0) then print(x) else ()
</programlisting></informalexample>

#dyncode("()") は #stacode("void") 型であるvoid値を表わすことに注意してください。
省略された形の条件式に割り当てる型は #stacode("void") でなければなりません。 \
")
")

</sect1><!--id="conditional_expressions"-->

<!-- ****** ****** -->

<sect1 id="sequence_expressions">
#langeng("
#title("Sequence Expressions")
")
#langja("
#title("シーケンス式(逐次実行)")
")

#langeng("
#para("\

Assume that exp1 and exp2 are expressions of types T1 and T2 respectively,
where T1 is #dyncode("void"). Then a sequence expression (exp1; exp2) can
be formed that is of the type T2.  When evaluating the sequence expression
(exp1; exp2), we first evaluate exp1 to the void value and then evaluate
exp2 to some value, which is also the value of the sequence expression.
When more expressions are sequenced, all of them but the last one need to
be of the type #dyncode("void") and the type of the last expression is also
the type of the sequence expression being formed.  Evaluating a sequence of
more expressions is analogous to evaluating a sequence of two. The
following example is a sequence expression:
 
<informalexample><programlisting>
(print 'H'; print 'e'; print 'l'; print 'l'; print 'o')
</programlisting></informalexample>

Evaluating this sequence expression prints out (onto the console) the
5-letter string \"Hello\". Instead of parentheses, we can also use the
keywords #dyncode("begin") and #dyncode("end") to form a sequence
expression:

<informalexample><programlisting>
begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o'
end // end of [begin]
</programlisting></informalexample>

If we like, we may also add a semicolon immediately after the last
expression in a sequence as long as the last expression is of the type
#dyncode("void"). For instance, the above example can also be written as
follows:

<informalexample><programlisting>
begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o';
end // end of [begin]
</programlisting></informalexample>

I also want to point out the following style of sequencing:

<informalexample><programlisting>
let
  val () = print 'H'
  val () = print 'e'
  val () = print 'l'
  val () = print 'l'
  val () = print 'o'
in
  // nothing
end // end of [let]
</programlisting></informalexample>

which is quite common in functional programming.\
")
")
#langja("
#para("\

exp1とexp2がそれぞれ型T1とT2であり、T1は #dyncode("void") 型であったとしましょう。
このときシーケンス式 (exp1; exp2) を作ることができ、その型は T2 になります。
シーケンス式 (exp1; exp2) を評価すると、まずはじめにexp1をvoid値に評価し、
さらにexp2を評価してなんらかの値を得ます。
またこの値はシーケンス式全体の値になります。

より多くの式を列にする場合、最後以外の式は全て #dyncode("void") 型であるべきで、
やはり最後の式はシーケンス式の型になります。
より多くの式からなるシーケンス式を評価するのは、2つの式からなるシーケンス式を評価するのと似ています。
次の例はシーケンス式です。
 
<informalexample><programlisting>
(print 'H'; print 'e'; print 'l'; print 'l'; print 'o')
</programlisting></informalexample>

このシーケンス式を評価するとコンソールに5つの文字 \"Hello\" が印字されます。
小括弧のかわりにキーワード #dyncode("begin") と #dyncode("end")
を使ってシーケンス式を作ることもできます。

<informalexample><programlisting>
begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o'
end // end of [begin]
</programlisting></informalexample>

好みによっては最後の式の直後にセミコロンを付けることもできます。
その場合、最後の式は #dyncode("void") 型でなければなりません。
例えば、先の例は次のようにも書けます。

<informalexample><programlisting>
begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o';
end // end of [begin]
</programlisting></informalexample>

また次のようなスタイルのシーケンスにも注目してください。

<informalexample><programlisting>
let
  val () = print 'H'
  val () = print 'e'
  val () = print 'l'
  val () = print 'l'
  val () = print 'o'
in
  // nothing
end // end of [begin]
</programlisting></informalexample>

これは関数型プログラミングで幾分一般的なものです。 \
")
")

</sect1><!--id="sequence_expression"-->

<!-- ****** ****** -->

<sect1 id="comments_in_code">
#langeng("
#title("Comments in Code")
")
#langja("
#title("コード中のコメント")
")

#langeng("
#para("\
ATS currently supports four forms of comments: line comment, block
comment of ML-style, block comment of C-style, and rest-of-file comment.

<itemizedlist>

<listitem>
#para("\
A line comment starts with the double slash symbol
(#dyncode("//")) and extends until the end of the current line.\
")
</listitem>

<listitem>
#para("
A block comment of ML-style starts and closes with the tokens
#dyncode("(*") and #dyncode("*)"), respectively. Note that nested block
comments of ML-style are allowed, that is, one block comment of ML-style
can occur within another one of the same style.\
")
</listitem>

<listitem>
#para("\
A block comment of C-style starts and closes with the tokens
#dyncode("/*") and #dyncode("*/"), respectively. Note that block comments
of C-style cannot be nested.  The use of block comments of C-style is
primarily in code that is supposed to be shared by ATS and C. In other
cases, block comments of ML-style should be the preferred choice.\
")
</listitem>

<listitem>
#para("\
A rest-of-file comment starts with the quadruple slash
symbol (#dyncode("////")) and extends until the end of the file. Comments
of this style of are primarily useful for developing or debugging programs.\
")
</listitem>

</itemizedlist>

")#comment("para")
")
#langja("
#para("\
ATSは現時点で4つのコメント形式をサポートしています。
ラインコメント、MLスタイルのブロックコメント、C言語スタイルのブロックコメント、ファイル末尾のコメント
です。

<itemizedlist>

<listitem>
#para("\
ラインコメントは2重スラッシュ記号 (#dyncode("//")) から始まり、その行の終端で終わります。 \
")
</listitem>

<listitem>
#para("
MLスタイルのブロックコメントの始まりと終わりは、それぞれトークン #dyncode("(*") と #dyncode("*)") です。
ネストされたMLスタイルのブロックコメントが許されていることに注意してください。
すなわちMLスタイルのブロックコメントはもう一つの同じスタイルのコメントの中に書くことができるのです。 \
")
</listitem>

<listitem>
#para("\
C言語スタイルのブロックコメントの始まりと終わりは、それぞれトークン
#dyncode("/*") と #dyncode("*/") です。
C言語スタイルのブロックコメントはネストできないことに注意してください。
C言語スタイルのブロックコメントは、ATSとC言語で共有されるコードで主に使われます。
その他の場合にはMLスタイルのブロックコメントを選ぶべきでしょう。 \
")
</listitem>

<listitem>
#para("\
ファイル末尾のコメントは4重スラッシュ記号 (#dyncode("////")) で始まり、ファイル終端まで続きます。
このスタイルのコメントは開発途中やプログラムのデバッグに便利です。 \
")
</listitem>

</itemizedlist>

")#comment("para")
")

</sect1><!--id="comments_in_code"-->

</chapter><!--id="elements_of_programming"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
