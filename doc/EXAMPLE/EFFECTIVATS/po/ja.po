# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-05-20 18:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: queue-sllist2/main.html:6 loop-as-tailrec/main.html:6 word-counting/main.html:6 stack-array/main.html:6 DiningPhil2/main.html:6 mergesort/main.html:6 IPC-redis/main.html:6 Readers-and-Writers/main.html:6 file-copying/main.html:6 DiningPhil/main.html:6 Producer-Consumer/main.html:6
#, no-wrap
msgid ""
"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n"
"   \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n"
"<html xmlns=\"http://www.w3.org/1999/xhtml\">\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-queue-sllist2</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:30 loop-as-tailrec/main.html:30 word-counting/main.html:30 stack-array/main.html:30 DiningPhil2/main.html:30 mergesort/main.html:30 IPC-redis/main.html:30 Readers-and-Writers/main.html:30 file-copying/main.html:30 DiningPhil/main.html:30 Producer-Consumer/main.html:30
msgid "</head>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:32 loop-as-tailrec/main.html:32 word-counting/main.html:32 stack-array/main.html:32 DiningPhil2/main.html:32 mergesort/main.html:32 IPC-redis/main.html:32 Readers-and-Writers/main.html:32 file-copying/main.html:32 DiningPhil/main.html:32 Producer-Consumer/main.html:32
msgid "<body>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:36
msgid "<h1> Effective ATS: An Amortized Implementation of Queues </h1>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:41
msgid ""
"Queues are a common data structure in practice. In the following "
"presentation, I would like to give a simple 2-list-based implementation of "
"queues for which both insertion (enqueue) and removal (dequeue) are "
"guaranteed to be amortized O(1)-time operations."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:45
msgid "<h2> A Simple Interface for Queues </h2>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:47
msgid "Let us first declare as follows a linear abstract type for queues:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:53
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">absvtype</span> queue_vtype <span "
"class=\"keyword\">(</span>a<span class=\"keyword\">:</span><span "
"class=\"keyword\">viewt@ype</span><span class=\"keyword\">,</span> n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> ptr</span> <span "
"class=\"keyword\">vtypedef</span> <span class=\"staexp\">queue <span "
"class=\"keyword\">(</span><span class=\"staexp\">a<span "
"class=\"keyword\">:</span>vt0p</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n<span class=\"keyword\">:</span>int</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"staexp\">queue_vtype</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:57
msgid ""
"The full name of the declared abstract type is [queue_vtype] and it is given "
"an alias [queue]. Given a type T, which may be linear, and an integer N, the "
"type [queue(T, N)] is for queues containing N elements of type T."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:61
msgid ""
"Obviously, N should be a natural number if there is ever a queue of the type "
"[queue(T, N)]. This is captured by the type of the following function (or "
"more precisely, proof-function):"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:68
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"prfexp\"><span class=\"keyword\">prfun</span>\n"
"lemma_queue_param\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">queue</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">[</span>n &gt;= 0<span "
"class=\"keyword\">]</span></span> <span "
"class=\"staexp\">void</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:70
msgid "The following function is to be called to create a queue of size 0:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:75
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span><span class=\"keyword\">}</span></span> "
"queue_make_nil <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">queue</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">0</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:80
msgid ""
"By declaring [queue_make_nil] as a function template, we have a better "
"chance to expect that its definition be inlined during compilation. This "
"makes sense as [queue_make_nil] should really just be a function of a tiny "
"body."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:82 queue-sllist2/main.html:126 queue-sllist2/main.html:141 queue-sllist2/main.html:159 queue-sllist2/main.html:166 queue-sllist2/main.html:259 queue-sllist2/main.html:313 loop-as-tailrec/main.html:45 loop-as-tailrec/main.html:71 loop-as-tailrec/main.html:155 loop-as-tailrec/main.html:178 loop-as-tailrec/main.html:237 loop-as-tailrec/main.html:277 loop-as-tailrec/main.html:333 loop-as-tailrec/main.html:360 word-counting/main.html:85 word-counting/main.html:163 word-counting/main.html:193 word-counting/main.html:302 word-counting/main.html:479 word-counting/main.html:497 stack-array/main.html:85 stack-array/main.html:107 stack-array/main.html:126 stack-array/main.html:164 stack-array/main.html:213 stack-array/main.html:268 DiningPhil2/main.html:61 mergesort/main.html:114 mergesort/main.html:153 mergesort/main.html:185 mergesort/main.html:288 mergesort/main.html:302 mergesort/main.html:317 mergesort/main.html:338 IPC-redis/main.html:66 IPC-redis/main.html:80 IPC-redis/main.html:97 IPC-redis/main.html:114 IPC-redis/main.html:168 IPC-redis/main.html:173 Readers-and-Writers/main.html:117 Readers-and-Writers/main.html:206 file-copying/main.html:86 file-copying/main.html:133 file-copying/main.html:242 DiningPhil/main.html:70 DiningPhil/main.html:87 DiningPhil/main.html:204 Producer-Consumer/main.html:142 Producer-Consumer/main.html:162 Producer-Consumer/main.html:185 Producer-Consumer/main.html:205 Producer-Consumer/main.html:239 Producer-Consumer/main.html:246 Producer-Consumer/main.html:299 Producer-Consumer/main.html:304 Producer-Consumer/main.html:422 Producer-Consumer/main.html:469 Producer-Consumer/main.html:481 Producer-Consumer/main.html:529
msgid "<p>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:85
msgid ""
"The following function is to be called to destroy a queue of size 0 (and "
"free the memory it occupies):"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:90
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span><span class=\"keyword\">}</span></span> "
"queue_free_nil <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">:</span> <span "
"class=\"staexp\">queue</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">0</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:93
msgid ""
"Clearly, we also need to test whether a given queue is empty. So let us "
"declare the following function for this purpose:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:100
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span><span "
"class=\"keyword\">}</span></span>\n"
"queue_is_empty\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">queue</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">bool</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"staexp\">==</span><span "
"class=\"staexp\">0</span><span class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:103
msgid ""
"Similarly, let us declare the following function for testing whether a given "
"queue is not empty:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:110
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span><span "
"class=\"keyword\">}</span></span>\n"
"queue_isnot_empty\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">queue</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">bool</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span> <span class=\"staexp\"><span "
"class=\"keyword\">&gt;</span></span> <span class=\"staexp\">0</span><span "
"class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:112
msgid "As for enqueueing, we declare the following function:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:119
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"queue_insert_atend<span class=\"staexp\"><span "
"class=\"keyword\">{</span>n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"keyword\">(</span>que<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">queue</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">queue</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"staexp\">+</span><span class=\"staexp\">1</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:124
msgid ""
"Note that the syntax indicates that [que] is a call-by-value argument and "
"the type of the queue it refers to changes from [queue(T, N)] to [queue(T, "
"N+1)] for some type T and integer N. Obviously, the increased size is due to "
"one element being inserted into the queue."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:128
msgid "As for dequeueing, we declare the following function:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:134
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> queue_takeout_atbeg<span "
"class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>int <span class=\"keyword\">|</span> n <span "
"class=\"keyword\">&gt;</span> 0<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">queue</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">queue</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"staexp\">-</span><span class=\"staexp\">1</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">a</span></span> </pre>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:139
msgid ""
"Note that the syntax indicates that [que] is a call-by-value argument and "
"the type of the queue it refers to changes from [queue(T, N)] to [queue(T, "
"N-1)] for some type T and <em>positive</em> integer N. Obviously, the "
"decreased size is due to one element being removed from the queue."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:144
msgid ""
"Now it is ready for us to implement the abstract type [queue_vtype] and the "
"functions associated with it."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:148
msgid "<h2> A 2-List-Based Implementation of Queues </h2>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:157
msgid ""
"In a functional programming setting, a queue is often represented as two "
"lists: the front part and the rear part. For enqueueing, the rear part is "
"replaced with a new list whose head is the enqueued element and whose tail "
"is the original rear part. For dequeueing, if the front part is empty, then "
"it is first replaced with the reverse of the rear part while the rear part "
"is replaced with the empty list; if the front part is not empty, then it is "
"replaced with its own tail while its head is returned as the dequeued "
"element."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:164
msgid ""
"Clearly, this implementation guarantees that enqueueing is always O(1)-time "
"but dequeueing may be O(n)-time, where n is the size of the rear part of the "
"queue. It can also be readily noted that enqueueing and dequeueing are both "
"O(1)-time if amortized time-complexity is of the concern."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:171
msgid ""
"Let us now see the actual code for this 2-list-based implementation of "
"queues.  Instead of functional lists, which require the presence of GC to "
"avoid memory leaks, the code makes use of linear singly-linked lists (of the "
"type [sllist]), performing memory allocation/deallocation explicitly."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:175
msgid ""
"<pre class=\"patsyntax\"> <span class=\"keyword\">staload</span> "
"\"libats/SATS/sllist.sats\""
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:180
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">datavtype</span>\n"
"queue <span class=\"staexp\"><span class=\"keyword\">(</span>a<span "
"class=\"keyword\">:</span><span class=\"keyword\">viewt@ype+</span><span "
"class=\"keyword\">,</span> n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">)</span></span> <span class=\"keyword\">=</span>\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>f<span "
"class=\"keyword\">,</span>r<span class=\"keyword\">:</span>nat <span "
"class=\"keyword\">|</span> f+r==n<span class=\"keyword\">}</span></span> "
"QUEUE <span class=\"keyword\">of</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">sllist</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">f</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">sllist</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">r</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">// end of [queue]</span>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:183
msgid ""
"<span class=\"staexp\"><span class=\"keyword\">assume</span> queue_vtype "
"<span class=\"keyword\">(</span>a<span class=\"keyword\">,</span> n<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> queue <span "
"class=\"keyword\">(</span>a<span class=\"keyword\">,</span> n<span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:186
msgid ""
"Clearly, the above code indicates that the size of a queue equals the sum of "
"lengths of its front and rear parts."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:192
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">implement</span><span class=\"keyword\">{</span><span "
"class=\"staexp\"><span class=\"keyword\">}</span></span> queue_make_nil "
"<span class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> QUEUE <span class=\"keyword\">(</span>sllist_nil "
"<span class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> sllist_nil <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:195
msgid ""
"The function [queue_make_nil] is called to create a queue of size 0, which "
"consists of an empty front part and an empty rear part."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:213
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\"><span "
"class=\"keyword\">}</span></span>\n"
"queue_free_nil <span class=\"keyword\">(</span>que<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val+</span><span "
"class=\"keyword\">~</span>QUEUE <span class=\"keyword\">(</span>f<span "
"class=\"keyword\">,</span> r<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> que</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> lemma_sllist_param <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> lemma_sllist_param <span "
"class=\"keyword\">(</span>r<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> sllist_free_nil <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> sllist_free_nil <span "
"class=\"keyword\">(</span>r<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">in</span>\n"
"  <span class=\"comment\">// nothing</span>\n"
"<span class=\"keyword\">end</span></span></span> <span class=\"comment\">// "
"end of [queue_free_nil]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:218
msgid ""
"The function [queue_free_nil] is called to destroy a queue of size 0.  As "
"the elements in a queue may be of a linear type, that is, they may contain "
"resources, a queue can be safely freed only if it contains no elements."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:228
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\"><span "
"class=\"keyword\">}</span></span>\n"
"queue_is_empty <span class=\"keyword\">(</span>que<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val+</span>QUEUE <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">,</span> r<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> que</span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> sllist_is_nil <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span> <span "
"class=\"keyword\">then</span> sllist_is_nil <span "
"class=\"keyword\">(</span>r<span class=\"keyword\">)</span> <span "
"class=\"keyword\">else</span> false\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[queue_is_empty]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:230
msgid "A queue is empty if and only if both of its front and rear parts are empty."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:240
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\"><span "
"class=\"keyword\">}</span></span>\n"
"queue_isnot_empty <span class=\"keyword\">(</span>que<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val+</span>QUEUE <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">,</span> r<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> que</span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> sllist_is_cons <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span> <span "
"class=\"keyword\">then</span> true <span class=\"keyword\">else</span> "
"sllist_is_cons <span class=\"keyword\">(</span>r<span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[queue_isnot_empty]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:244
msgid ""
"A queue is not empty if and only if either its front or its rear is not "
"empty. It is also possible to implement [queue_isnot_empty] directly based "
"on [queue_is_empty] as is shown below:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:252
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\"><span "
"class=\"keyword\">}</span></span>\n"
"queue_isnot_empty <span class=\"keyword\">(</span>que<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> lemma_queue_param <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">)</span></span> <span "
"class=\"keyword\">in</span> not <span "
"class=\"keyword\">(</span>queue_is_empty <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[queue_isnot_empty]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:257
msgid ""
"Note that the negation of a value of the type [bool(N == 0)] for some N is "
"of the type [bool(N != 0)].  In order to show that [N != 0] implies [N > 0], "
"we need to prove that [N >= 0], which is achieved by calling "
"[lemma_queue_param]."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:265
msgid ""
"The functions [queue_insert_atend] and [queue_takeout_atbeg] are implemented "
"as follows:"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:278
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"queue_insert_atend <span class=\"keyword\">(</span>que<span "
"class=\"keyword\">,</span> x<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val+</span><span "
"class=\"keyword\">@</span>QUEUE <span class=\"keyword\">(</span>f<span "
"class=\"keyword\">,</span> r<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> que</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> r := sllist_cons <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">,</span> r<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">fold@</span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">in</span>\n"
"  <span class=\"comment\">// nothing</span>\n"
"<span class=\"keyword\">end</span></span></span> <span class=\"comment\">// "
"end of [queue_insert_atend]</span>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:307
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"queue_takeout_atbeg <span class=\"keyword\">(</span>que<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val+</span><span "
"class=\"keyword\">@</span>QUEUE <span class=\"keyword\">(</span>f<span "
"class=\"keyword\">,</span> r<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> que</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> lemma_sllist_param <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> lemma_sllist_param <span "
"class=\"keyword\">(</span>r<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> iscons <span "
"class=\"keyword\">=</span> sllist_is_cons <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> iscons <span class=\"keyword\">then</span> "
"<span class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x <span "
"class=\"keyword\">=</span> sllist_uncons <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"  <span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">fold@</span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"  x\n"
"<span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> sllist_free_nil <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> f := sllist_reverse <span "
"class=\"keyword\">(</span>r<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> r := sllist_nil <span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x <span "
"class=\"keyword\">=</span> sllist_uncons <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"  <span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">fold@</span> <span "
"class=\"keyword\">(</span>que<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"  x\n"
"<span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[if]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[queue_takeout_atbeg]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:311
msgid ""
"By following the description given at the beginning of this section, one "
"should find it straightforward to understand the code for enqueueing and "
"dequeueing."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:316
msgid ""
"For a running implementation, please find in queue-sllist2.dats the entirety "
"of the above presented code plus some code for testing."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:318 loop-as-tailrec/main.html:385 word-counting/main.html:503 stack-array/main.html:336 DiningPhil2/main.html:217 mergesort/main.html:358 IPC-redis/main.html:189 Readers-and-Writers/main.html:391 file-copying/main.html:307 DiningPhil/main.html:211 Producer-Consumer/main.html:534
msgid "<hr size=\"2\">"
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:320 loop-as-tailrec/main.html:387 word-counting/main.html:505 stack-array/main.html:338 DiningPhil2/main.html:219 mergesort/main.html:360 IPC-redis/main.html:191 Readers-and-Writers/main.html:393 file-copying/main.html:309 DiningPhil/main.html:213 Producer-Consumer/main.html:536
msgid ""
"This article is written by <a href=\"http://www.cs.bu.edu/~hwxi/\">Hongwei "
"Xi</a>."
msgstr ""

#. type: Plain text
#: queue-sllist2/main.html:323 loop-as-tailrec/main.html:390 word-counting/main.html:508 stack-array/main.html:341 DiningPhil2/main.html:222 mergesort/main.html:363 IPC-redis/main.html:194 Readers-and-Writers/main.html:396 file-copying/main.html:312 DiningPhil/main.html:216 Producer-Consumer/main.html:539
msgid "</body> </html>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-loop-as-tailrec</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:36
msgid "<h1> Effective ATS: Loops as Tail-Recursive Functions </h1>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:43
msgid ""
"Although language constructs are available in ATS to support direct "
"construction of for-loops and while-loops, it is strongly recommended that "
"loops be implemented as tail-recursive functions (a.k.a. iterative "
"functions). A primary advantage of doing so is that this style of loop "
"implementation can be readily combined with theorem-proving as is supported "
"in ATS, thus facilitating program verification involving loops."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:48
msgid ""
"Please see tailrec.dats for the entirety of the code given in the followng "
"presentation."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:52
msgid "<h2> What is tail-recursion? </h2>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:59
msgid ""
"Suppose that [foo] and [bar] are two functions and there is a call to [bar] "
"in the body of [foo]. This call is a tail-call if what it returns is also "
"the return value of [foo]. In other words, a function call in the body of "
"some calling function is a tail-call if the return value of the call is also "
"the return value of the calling function. For instance, the call to [bar] is "
"a tail-call in the following code but the call to [baz] is not:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:65
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> foo <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> x <span class=\"keyword\">&gt;</span> "
"<span class=\"dynexp\">0</span> <span class=\"keyword\">then</span> bar<span "
"class=\"keyword\">(</span>x<span class=\"keyword\">)</span> <span "
"class=\"keyword\">else</span> baz<span class=\"keyword\">(</span>x<span "
"class=\"keyword\">)</span>+<span class=\"dynexp\">1</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:69
msgid ""
"By the way, even if baz(x)+1 is changed into baz(x)+0, the call to [baz] is "
"still not considered a tail-call unless baz(x)+0 can somehow be translated "
"into baz(x)."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:78
msgid ""
"If the calling function calls itself in a tail-call, then this tail-call is "
"often referred to as a tail-recursive call. A function is tail-recursive if "
"every recursive call in its body is a tail-call. Note that a tail-recursive "
"function is also referred to as an iterative function in the literature.  In "
"the following example, the outside call to [f91] is tail-recursive but the "
"inside one is not:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:84
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> f91 <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> x &gt;= <span "
"class=\"dynexp\">101</span> <span class=\"keyword\">then</span> x-<span "
"class=\"dynexp\">10</span> <span class=\"keyword\">else</span> f91<span "
"class=\"keyword\">(</span>f91<span class=\"keyword\">(</span>x+<span "
"class=\"dynexp\">11</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:86
msgid "By definition, [f91] is not a tail-recursive function."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:90
msgid "<h2> Why is tail-recursion desirable? </h2>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:100
msgid ""
"Each tail-recursive function can be readily implemented as a loop.  Assume "
"that a call stack is employed to implement function calls, which is by far "
"the most common implementation strategy in practice.  Then calling a "
"tail-recursive function only requires a fixed amount of stack space. In a "
"setting where stack space is greatly limited (e.g., low-level embedded "
"programming), tail-recursion is often the only form of recursion that is "
"legally allowed.  In short, tail-recursion is desirable because it can be "
"implemented in a much more efficient manner, both time-wise and memory-wise, "
"when compared with general recursion."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:104
msgid "<h2> Translating recursion into tail-recursion </h2>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:112
msgid ""
"Given the advantage of tail-recursion, it is natural to encounter the need "
"for turning a recursive (but not tail-recursive) function into an equivalent "
"one that is also tail-recursive. While there is a systematic approach to "
"translating recursion into tail-recursion (CPS-translation), this approach "
"is in general not what one wants to use if one's focus is on "
"efficiency. Instead, one mostly relies on ad hoc methods or tricks to handle "
"each individual case."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:119
msgid ""
"<h4> Example 1 </h4> Let us now take a look at a concrete example. The "
"following code implements a function [tally] that sums up all the integers "
"between 1 and a given number n, inclusive:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:125
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> tally <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> n <span class=\"keyword\">&gt;</span> "
"<span class=\"dynexp\">0</span> <span class=\"keyword\">then</span> n + "
"tally <span class=\"keyword\">(</span>n-<span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">else</span> <span "
"class=\"dynexp\">0</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:128
msgid ""
"Clearly, [tally] is not tail-recursive. If we translate this implementation "
"of [tally] into C, we essentially obtain the following code:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:135
#, no-wrap
msgid ""
"<pre>\n"
"int tally (int n)\n"
"{\n"
"  return (n > 0) ? n + tally (n-1) : 0 ;\n"
"}\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:138
msgid ""
"This implementation of [tally] in C is a bit unusual as a standard one is "
"expected to be based on a for-loop:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:148
#, no-wrap
msgid ""
"<pre>\n"
"int tally2 (int n)\n"
"{\n"
"  int i ;\n"
"  int res = 0 ;\n"
"  for (i = n ; i > 0 ; i--) res += i ;\n"
"  return res ;\n"
"}\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:153
msgid ""
"It should be pointed out that the equivalence between [tally] and [tally2] "
"relies on the fact that integer addition is <em>associative</em>. If "
"addition is replaced with subtraction, which is not associative, then these "
"two implementations are no longer equivalent."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:158
msgid ""
"A straightforward translation of the above implementation of [tally2] in C "
"into ATS yields the following code:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:172
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> tally2\n"
"  <span class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> loop\n"
"  <span class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">,</span> res<span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span> <span class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> n <span class=\"keyword\">&gt;</span> "
"<span class=\"dynexp\">0</span> <span class=\"keyword\">then</span> loop "
"<span class=\"keyword\">(</span>n-<span class=\"dynexp\">1</span><span "
"class=\"keyword\">,</span> res+n<span class=\"keyword\">)</span> <span "
"class=\"keyword\">else</span> res</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  loop <span class=\"keyword\">(</span>n<span class=\"keyword\">,</span> "
"<span class=\"dynexp\">0</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[tally2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:176
msgid ""
"Please note that the inner function [loop] is tail-recursive. The compiler "
"of ATS (ATS/Postiats) essentially compiles [loop] into some code in C that "
"is equivalent to the for-loop mentioned above."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:185
msgid ""
"In general, the process of translating a recursive function into a "
"tail-recursive one hinges on finding an efficient way to encode the stack "
"generated during the execution of the function. For instance, suppose we "
"call [tally] on 100; this call generates a recursive call on 99, and then a "
"recursive call on 98, and so on; when [tally] is called on 50, the call "
"stack essentially represents the following evaluation context:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:189
msgid "<pre> 100 + (99 + (98 + (... + (51 + []) ...)))  </pre>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:194
msgid ""
"where the symbol [] is to be replaced with the return value of tally(50).  "
"As integer addition is associative, we can use the sum (100+99+98+...+51)  "
"to represent this evaluation context. This is precisely the idea behind the "
"implementation of the inner function [loop] in the body of [tally2]."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:200
msgid ""
"<h4> Example 2 </h4> Let us take a look at another example. The following "
"code implements a function named [fib] for computing Fibonacci numbers:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:206
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> fib <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> n &gt;= <span class=\"dynexp\">2</span> "
"<span class=\"keyword\">then</span> fib<span "
"class=\"keyword\">(</span>n-<span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span> + fib<span class=\"keyword\">(</span>n-<span "
"class=\"dynexp\">2</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">else</span> n</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:210
msgid ""
"Clearly, neither of the two recursive calls in the body of [fib] is "
"tail-recursive. Another function named [fib2] is presented as follows for "
"computing Fibonacci numbers:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:224
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> fib2\n"
"  <span class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> loop\n"
"  <span class=\"keyword\">(</span>i<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">,</span> f0<span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span><span "
"class=\"keyword\">,</span> f1<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> i <span class=\"keyword\">&lt;</span> n "
"<span class=\"keyword\">then</span> loop <span "
"class=\"keyword\">(</span>i+<span class=\"dynexp\">1</span><span "
"class=\"keyword\">,</span> f1<span class=\"keyword\">,</span> f0+f1<span "
"class=\"keyword\">)</span> <span class=\"keyword\">else</span> f0</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  loop <span class=\"keyword\">(</span><span class=\"dynexp\">0</span><span "
"class=\"keyword\">,</span> <span class=\"dynexp\">0</span><span "
"class=\"keyword\">,</span> <span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[fib2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:235
msgid ""
"It is evident that the inner funtion [loop] in the body of [fib2] is "
"tail-recursive. Suppose we want to evaluate fib2(100), which generates a "
"call of the form loop(0, 0, 1), which then generates a call of the form "
"loop(1, 1, 1), which then generates a call of the form loop(2, 1, 2), etc.  "
"If loop(i, f0, f1) is among this sequence of calls, then f0 is Fibonacci "
"number i and f1 is Fibonacci number i+1. This implies that the value "
"returned by the last call in this sequence is Fibonacci number 100 (as i "
"reaches 100 at that point). This argument, though informal, should probably "
"be enough to convince one that [fib] and [fib2] are equivalent, that is, "
"they return the same result when applied to a given integer."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:241
msgid ""
"The very idea behind translating [fib] into [fib2] lies in the simple "
"observation that only the two previously computed Fibonacci numbers need to "
"be kept in order to compute Fibonacci number n for every n >= 2."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:245
msgid "<h4> Example 3 </h4>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:249
msgid ""
"The next example we see involves list-processing.  The following code "
"implements the standard concatenation of two given lists:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:266
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span>\n"
"<span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span><span class=\"keyword\">t@ype</span><span "
"class=\"keyword\">}</span></span>\n"
"list_append\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>\n"
"  xs<span class=\"keyword\">:</span> <span class=\"staexp\">list</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">,</span> ys<span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"<span class=\"keyword\">(</span>\n"
"<span class=\"keyword\">case+</span> xs <span class=\"keyword\">of</span>\n"
"<span class=\"keyword\">|</span> list_cons\n"
"    <span class=\"keyword\">(</span>x<span class=\"keyword\">,</span> "
"xs<span class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> "
"list_cons <span class=\"keyword\">(</span>x<span class=\"keyword\">,</span> "
"list_append <span class=\"keyword\">(</span>xs<span "
"class=\"keyword\">,</span> ys<span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">|</span> list_nil <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> ys\n"
"<span class=\"keyword\">)</span></span> <span class=\"comment\">// end of "
"[list_append]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:275
msgid ""
"The type assigned to [list_append] means that the function returns a list of "
"length m+n when applied to two lists xs and ys of length m and n, "
"respectively.  Note that this is so-called functional list concatenation as "
"neither of the input lists gets modified. Clearly, [list_append] is not "
"tail-recursive as the recursive call in its body is not a tail-call. If the "
"first argument of a call to [list_append] is long (e.g., containing 1M "
"elements), then it is very likely that an execution of this call overflows "
"the call stack and thus causes a crash."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:285
msgid ""
"In order to translate [list_append] into a tail-recursive implementation, we "
"need some knowledge about list construction. There are essentially two steps "
"involved in evaluating list_cons(x, xs); certain memory needs to be first "
"allocated for storing a list node; then this node is initialized with x and "
"xs. In ATS, it is allowed to formally separate these two steps, and this "
"separation is key to obtaining a proper tail-recursive implementation of "
"list concatenation as is shown in the following code:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:324
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span>\n"
"<span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span><span class=\"keyword\">t@ype</span><span "
"class=\"keyword\">}</span></span>\n"
"list_append2\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>\n"
"  xs<span class=\"keyword\">:</span> <span class=\"staexp\">list</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">,</span> ys<span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> loop<span "
"class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">:</span>nat<span class=\"keyword\">}</span></span>\n"
"<span class=\"keyword\">(</span>\n"
"  xs<span class=\"keyword\">:</span> <span class=\"staexp\">list</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">,</span> ys<span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">,</span> res<span class=\"keyword\">:</span> <span "
"class=\"staexp\">&amp;</span><span class=\"staexp\">ptr</span><span "
"class=\"staexp\">?</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">list</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span> <span class=\"keyword\">=</span>\n"
"<span class=\"keyword\">(</span>\n"
"<span class=\"keyword\">case+</span> xs <span class=\"keyword\">of</span>\n"
"<span class=\"keyword\">|</span> list_cons\n"
"    <span class=\"keyword\">(</span>x<span class=\"keyword\">,</span> "
"xs1<span class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> "
"<span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"comment\">// allocate a list node "
"with</span>\n"
"    res := list_cons<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>0<span "
"class=\"keyword\">}</span></span><span class=\"keyword\">(</span>x<span "
"class=\"keyword\">,</span> _<span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// uninitialized tail</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val+</span>list_cons "
"<span class=\"keyword\">(</span>_<span class=\"keyword\">,</span> res1<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> res</span> <span "
"class=\"comment\">// [res1] points to the tail</span>\n"
"    <span class=\"comment\">// put into [res1] the concatenation</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> loop <span class=\"keyword\">(</span>xs1<span "
"class=\"keyword\">,</span> ys<span class=\"keyword\">,</span> res1<span "
"class=\"keyword\">)</span></span> <span class=\"comment\">// of [xs1] and "
"[ys]</span>\n"
"  <span class=\"keyword\">in</span>\n"
"    <span class=\"keyword\">fold@</span><span "
"class=\"keyword\">(</span>res<span class=\"keyword\">)</span> <span "
"class=\"comment\">// folding translates into a no-op at run-time</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[list_cons]</span>\n"
"<span class=\"keyword\">|</span> list_nil <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> res := ys\n"
"<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">var</span> res<span class=\"keyword\">:</span> <span "
"class=\"staexp\">ptr</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> loop <span class=\"keyword\">(</span>xs<span "
"class=\"keyword\">,</span> ys<span class=\"keyword\">,</span> res<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  res\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[list_append2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:331
msgid ""
"Given xs, ys, and res, what the inner function [loop] does is to put the "
"concatenation of xs and ys into res.  In the body of [loop], we see that the "
"expression fold@(res) follows the recursive call to [loop].  However, this "
"call is considered a tail-call as fold@(res) is solely used for the purpose "
"of typechecking and erased afterwards.  Therefore, [loop] is a "
"tail-recursive function."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:338
msgid ""
"By the way, the style of recursion employed in the implementation of [loop] "
"is often dubbed <em>tail-recursion modulo allocation</em>, which commonly "
"appears in untyped or weakly-typed languages (e.g., LISP and C) but rarely "
"in a typed language (due to the great difficulty in properly typing it)."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:342
msgid "<h2> Mutually tail-recursive functions </h2>"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:346
msgid ""
"Sometimes, we need to combine functions together in order to turn mutually "
"tail-recursive calls into local jumps. For instance, in the following code, "
"[isevn] and [isodd] are defined mutually recursively:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:354
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> isevn <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> n <span class=\"keyword\">&gt;</span> "
"<span class=\"dynexp\">0</span> <span class=\"keyword\">then</span> isodd "
"<span class=\"keyword\">(</span>n-<span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">else</span> true\n"
"<span class=\"keyword\">and</span> isodd <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> n <span class=\"keyword\">&gt;</span> "
"<span class=\"dynexp\">0</span> <span class=\"keyword\">then</span> isevn "
"<span class=\"keyword\">(</span>n-<span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">else</span> "
"false</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:358
msgid ""
"The call to [isodd] in the body of [isevn] and the call to [isevn] in the "
"body of [isadd] are both tail-calls. As they are also mutually recursive "
"calls, they are referred to as mutually tail-recursive calls."
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:367
msgid ""
"When compiling this implementation of [isevn] and [isadd], the ATS compiler "
"(ATS/Postiats) handles [isevn] and [isodd] separately and thus is "
"<em>unable</em> to turn the call to [isodd] ([isevn]) in the body of [isevn] "
"([isodd]) into a local jump. In order to indicate to the compiler that these "
"two functions need to be combined for compilation, the keyword [fun] should "
"be replaced with another keyword [fnx]:"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:375
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fnx</span> isevn <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> n <span class=\"keyword\">&gt;</span> "
"<span class=\"dynexp\">0</span> <span class=\"keyword\">then</span> isodd "
"<span class=\"keyword\">(</span>n-<span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">else</span> true\n"
"<span class=\"keyword\">and</span> isodd <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span> <span "
"class=\"keyword\">=</span>\n"
"  <span class=\"keyword\">if</span> n <span class=\"keyword\">&gt;</span> "
"<span class=\"dynexp\">0</span> <span class=\"keyword\">then</span> isevn "
"<span class=\"keyword\">(</span>n-<span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">else</span> "
"false</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: loop-as-tailrec/main.html:383
msgid ""
"When compiling the above code, the ATS compiler puts inside the body of "
"[isevn] a copy of the body of [isodd] so that mutually tail-recursive calls "
"in the bodies of these two functions can be translated into local jumps.  "
"Also, please note that only the first of a sequence of mutually defined "
"functions following the keyword [fnx] is available for subsequent use. In "
"the above case, only the function [isevn] is available for subsequent use "
"whereas the function [isodd] is not."
msgstr ""

#. type: Plain text
#: word-counting/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-word-counting</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: word-counting/main.html:36
msgid "<h1> Effective ATS: Word Counting </h1>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:40
msgid ""
"I would like to present in this article a program that counts the number of "
"occurrences of each word in a given file. The focus of the presentation is "
"on the process that finally leads to the construction of the program."
msgstr ""

#. type: Plain text
#: word-counting/main.html:44
msgid "<h2> What kind of input is expected? </h2>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:47
msgid ""
"Basically, the input is a stream of words. So let us assume that we have a "
"function [word_get] of the following type:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:52
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> word_get <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">stropt</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:63
msgid ""
"Note that [stropt] is the type for an optional string, which is either a "
"valid string or a null pointer. If [word_get] returns a null pointer, then "
"it indicates that the end of a given stream (of words) is reached. Clearly, "
"this means that [word_get] is a stateful function, that is, it maintains an "
"internal state. In general, using stateful functions is considered a poor "
"style of programming.  For instance, the function [strtok] in libc is "
"infamous for its treachery of statefulness, and everyone bitten by it should "
"know this all too well. In ATS, there is a convenient approach to removing "
"stateful functions by simply turing them into templates.  For the moment, "
"let us focus on getting a running implementation."
msgstr ""

#. type: Plain text
#: word-counting/main.html:67
msgid "<h2> What kind of output is expected? </h2>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:74
msgid ""
"Let us say that we want to output all of the encountered words in an order "
"such that a word appears ahead of another one if there are more occurrences "
"of the former than the latter. This means that we need to build an "
"associative map that associates each word with the number of the occurrences "
"of this word. So we introduce the following abstract type [wcmap_type] for "
"such a map and [wcmap] as a shorthand for [wcmap_type]:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:80
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abstype</span> wcmap_type <span class=\"keyword\">=</span> "
"ptr</span> <span class=\"keyword\">typedef</span> <span "
"class=\"staexp\">wcmap <span class=\"keyword\">=</span> <span "
"class=\"staexp\">wcmap_type</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:83
msgid ""
"Note that [wcmap_type] is a boxed type, that is, the size of this type is "
"that of a pointer (of the type [ptr])."
msgstr ""

#. type: Plain text
#: word-counting/main.html:88
msgid ""
"How should a map of the type [wcmap] be created? We introduce a function for "
"creating an empty map:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:93
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> wcmap_create <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">wcmap</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:96
msgid ""
"If a word is encountered, we need to increase its number of occurrences by "
"1. This is done by the following function:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:101
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> wcmap_incby1 <span "
"class=\"keyword\">(</span>map<span class=\"keyword\">:</span> <span "
"class=\"staexp\">wcmap</span><span class=\"keyword\">,</span> w<span "
"class=\"keyword\">:</span> <span class=\"staexp\">string</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:104
msgid ""
"As we also need to sort words according to their numbers of occurrences, we "
"introduce a function for sequentializing a [wcmap]:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:109
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> wcmap_listize <span "
"class=\"keyword\">(</span>map<span class=\"keyword\">:</span> <span "
"class=\"staexp\">wcmap</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">list0</span> <span "
"class=\"keyword\">@(</span><span class=\"staexp\">string</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">int</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:116
msgid ""
"In libats, which is a part of ATS library, there are many implementations of "
"maps. For someone familiar with data structures, it should be clear that a "
"good fit for [wcmap] is a hashtable-based map implementation. Of course, a "
"map implementation based on some form of balanced-tree (e.g. AVL-tree)  "
"should work as well. My own experiment showed that the former was about 2-3 "
"times faster than the latter."
msgstr ""

#. type: Plain text
#: word-counting/main.html:120
msgid "<h2> Implementing WordCounting </h2>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:122
msgid "Let us declare the main function for counting words as follows:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:127
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> WordCounting <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">wcmap</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:131
msgid ""
"So by calling [WordCounting], we generate a [wcmap] that maps each "
"encountered word to its number of occurrences. An implementation of "
"[WordCounting] is given as follows:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:156
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"WordCounting <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> loop\n"
"  <span class=\"keyword\">(</span>map<span class=\"keyword\">:</span> <span "
"class=\"staexp\">wcmap</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> opt <span "
"class=\"keyword\">=</span> word_get <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> issome <span "
"class=\"keyword\">=</span> stropt_is_some <span "
"class=\"keyword\">(</span>opt<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> issome <span "
"class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> wcmap_incby1 <span "
"class=\"keyword\">(</span>map<span class=\"keyword\">,</span> stropt_unsome "
"<span class=\"keyword\">(</span>opt<span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span> <span class=\"keyword\">in</span> loop "
"<span class=\"keyword\">(</span>map<span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"<span class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"comment\">// end of [if]</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[loop]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> map <span "
"class=\"keyword\">=</span> wcmap_create <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> loop <span "
"class=\"keyword\">(</span>map<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  map\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[WordCounting]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: word-counting/main.html:161
msgid ""
"Essentially, what the inner function [loop] does is to enumerate a word by "
"calling [word_get] and then increase the count of the word by one; [loop] "
"terminates when [word_get] returns a null pointer (which makes "
"[stropt_is_some] to return false)."
msgstr ""

#. type: Plain text
#: word-counting/main.html:175
msgid ""
"I hope that the reader can truly appreciate the top-down style of "
"programming presented above, which makes effective use of abstract types in "
"ATS.  My own observation says that most programmers employ a bottom-up style "
"of progrmming in practice. When given the word-counting problem, they would "
"focus on implementing [wcmap] (and the functions associated with it)  and/or "
"functions like [word_get]. For a simple problem like word-counting, a "
"competent programmer can probably handle it with whatsoever approach he or "
"she chooses. However, when dealing with larger and more complex problems, "
"one can easily lose focus with a bottom-up approach, writing code that is "
"only to be abandoned later. To some extent, writing a program is like "
"telling a story: The story can hardly be coherent if the storyteller is out "
"of focus."
msgstr ""

#. type: Plain text
#: word-counting/main.html:179
msgid "<h2> How should [word_get] be implemented? </h2>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:182
msgid ""
"One way to implement [word_get] is to first assume that we have a function "
"[char_get] of the following type:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:187
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> char_get <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:191
msgid ""
"If [char_get] returns a non-negative integer, then the integer is the ASCII "
"encoding of a character; otherwise, it is the indication that no more "
"character is available."
msgstr ""

#. type: Plain text
#: word-counting/main.html:195
msgid ""
"A possible implementation of [word_get] based on [char_get] is given as "
"follows:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:219
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"word_get <span class=\"keyword\">(</span><span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">typedef</span>\n"
"<span class=\"staexp\">charlst <span class=\"keyword\">=</span> <span "
"class=\"staexp\">list0</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">char</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fnx</span> loop\n"
"<span class=\"keyword\">(</span>\n"
"<span class=\"comment\">// argmentless</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">charlst</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> i <span "
"class=\"keyword\">=</span> char_get <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> i &gt;= <span class=\"dynexp\">0</span> "
"<span class=\"keyword\">then</span>\n"
"<span class=\"keyword\">(</span>\n"
"  <span class=\"keyword\">if</span> isalpha <span "
"class=\"keyword\">(</span>i<span class=\"keyword\">)</span> <span "
"class=\"keyword\">then</span>\n"
"    loop2 <span class=\"keyword\">(</span>cons0<span class=\"staexp\"><span "
"class=\"keyword\">{</span>char<span class=\"keyword\">}</span></span><span "
"class=\"keyword\">(</span>int2char0<span class=\"keyword\">(</span>i<span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> nil0<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">else</span> loop <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"comment\">// end of [if]</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">else</span> "
"nil0<span class=\"keyword\">(</span><span "
"class=\"comment\">(*void*)</span><span class=\"keyword\">)</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[loop]</span>\n"
msgstr ""

#. type: Plain text
#: word-counting/main.html:241
#, no-wrap
msgid ""
"<span class=\"keyword\">and</span> loop2\n"
"<span class=\"keyword\">(</span>\n"
"  res<span class=\"keyword\">:</span> <span "
"class=\"staexp\">charlst</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">charlst</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> i <span "
"class=\"keyword\">=</span> char_get <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> isalpha <span "
"class=\"keyword\">(</span>i<span class=\"keyword\">)</span> <span "
"class=\"keyword\">then</span>\n"
"    loop2 <span class=\"keyword\">(</span>cons0<span class=\"staexp\"><span "
"class=\"keyword\">{</span>char<span class=\"keyword\">}</span></span><span "
"class=\"keyword\">(</span>int2char0<span class=\"keyword\">(</span>i<span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> res<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">else</span> res\n"
"  <span class=\"comment\">// end of [if]</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[loop2]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> cs <span "
"class=\"keyword\">=</span> loop <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">case+</span> cs <span class=\"keyword\">of</span>\n"
"<span class=\"keyword\">|</span> nil0 <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> stropt_none "
"<span class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">|</span> cons0 _ <span "
"class=\"keyword\">=&gt;</span> stropt_some <span "
"class=\"keyword\">(</span>string_make_rlist <span "
"class=\"keyword\">(</span>cs<span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[word_get]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: word-counting/main.html:249
msgid ""
"Note that [loop] is called to skip non-alphabetical chars while [loop2] is "
"called to accumulate alphabetical chars. The keyword [fnx] (in place of "
"[fun]) means that [loop] and [loop2] are compiled jointly so that the "
"tail-recursive calls in their bodies can all be turned into direct local "
"jumps.  The function [string_make_rlist] creates a string consisting of the "
"sequence of chars in the reverse of a given list. For instance, if the list "
"consists of 'a', 'b' and 'c', then the created string is \"cba\"."
msgstr ""

#. type: Plain text
#: word-counting/main.html:253
msgid "<h2> How should [wcmap] be implemented? </h2>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:257
msgid ""
"The following code gives a straightforward hashtable-based implementation of "
"[wcmap]. Some details on various hashtable-functions can be found <a "
"href=\"http://www.ats-lang.org/LIBRARY/libats/ML/hashtbl.html\">on-line</a>."
msgstr ""

#. type: Plain text
#: word-counting/main.html:268
msgid ""
"<pre class=\"patsyntax\"> <span class=\"keyword\">local</span> <span "
"class=\"comment\">//</span> <span class=\"keyword\">staload</span> HT <span "
"class=\"keyword\">=</span> \"libats/ML/SATS/hashtbl.sats\" <span "
"class=\"comment\">//</span> <span class=\"staexp\"><span "
"class=\"keyword\">assume</span> wcmap_type <span class=\"keyword\">=</span> "
"$HT<span class=\"keyword\">.</span>hashtbl <span "
"class=\"keyword\">(</span>string<span class=\"keyword\">,</span> int<span "
"class=\"keyword\">)</span></span> <span class=\"comment\">//</span> <span "
"class=\"keyword\">in</span> <span class=\"comment\">(* in of [local] "
"*)</span>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:273
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"wcmap_create <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span>\n"
"  $HT<span class=\"keyword\">.</span>hashtbl_make_nil <span "
"class=\"keyword\">(</span>i2sz<span class=\"keyword\">(</span><span "
"class=\"dynexp\">1024</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">// end of [wcmap_create]</span>\n"
msgstr ""

#. type: Plain text
#: word-counting/main.html:290
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"wcmap_incby1\n"
"  <span class=\"keyword\">(</span>map<span class=\"keyword\">,</span> w<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> opt <span "
"class=\"keyword\">=</span> $HT<span class=\"keyword\">.</span>hashtbl_search "
"<span class=\"keyword\">(</span>map<span class=\"keyword\">,</span> w<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">case+</span> opt <span class=\"keyword\">of</span>\n"
"<span class=\"keyword\">|</span> <span class=\"keyword\">~</span>Some_vt "
"<span class=\"keyword\">(</span>n<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=&gt;</span>\n"
"  <span class=\"keyword\">{</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val-</span><span "
"class=\"keyword\">~</span>Some_vt _ <span class=\"keyword\">=</span> "
"$HT<span class=\"keyword\">.</span>hashtbl_insert <span "
"class=\"keyword\">(</span>map<span class=\"keyword\">,</span> w<span "
"class=\"keyword\">,</span> n+<span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">}</span>\n"
"<span class=\"keyword\">|</span> <span class=\"keyword\">~</span>None_vt "
"<span class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> $HT<span "
"class=\"keyword\">.</span>hashtbl_insert_any <span "
"class=\"keyword\">(</span>map<span class=\"keyword\">,</span> w<span "
"class=\"keyword\">,</span> <span class=\"dynexp\">1</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[wcmap_incby1]</span>\n"
msgstr ""

#. type: Plain text
#: word-counting/main.html:293
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span> "
"wcmap_listize <span class=\"keyword\">(</span>map<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> $HT<span "
"class=\"keyword\">.</span>hashtbl_takeout_all <span "
"class=\"keyword\">(</span>map<span class=\"keyword\">)</span></span>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:296 word-counting/main.html:470
msgid ""
"<span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[local]</span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:300
msgid ""
"A complete running program containing the entirety of the above presented "
"code can be found in the file wordcnt.dats, and there is also a Makefile for "
"compiling it."
msgstr ""

#. type: Plain text
#: word-counting/main.html:305
msgid ""
"Following is a list of the 100 most frequently used words in the novel "
"\"Moby Dick\" by Herman Melville:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:408
msgid ""
"<pre> the\t->\t14515 of\t->\t6673 and\t->\t6464 a\t->\t4799 to\t->\t4683 "
"in\t->\t4210 that\t->\t3080 it\t->\t2533 his\t->\t2513 i\t->\t2127 "
"he\t->\t1894 but\t->\t1822 s\t->\t1816 with\t->\t1765 as\t->\t1750 "
"is\t->\t1748 was\t->\t1645 for\t->\t1637 all\t->\t1535 this\t->\t1431 "
"at\t->\t1331 by\t->\t1211 whale\t->\t1191 not\t->\t1169 from\t->\t1095 "
"so\t->\t1066 be\t->\t1062 on\t->\t1062 him\t->\t1061 you\t->\t953 "
"one\t->\t921 there\t->\t864 now\t->\t786 or\t->\t783 had\t->\t779 "
"have\t->\t772 were\t->\t684 they\t->\t667 which\t->\t653 like\t->\t647 "
"me\t->\t629 then\t->\t628 are\t->\t618 their\t->\t618 some\t->\t617 "
"what\t->\t617 when\t->\t606 an\t->\t600 no\t->\t590 my\t->\t586 "
"upon\t->\t566 out\t->\t537 man\t->\t527 up\t->\t523 into\t->\t522 "
"ship\t->\t513 more\t->\t507 ahab\t->\t501 if\t->\t500 them\t->\t471 "
"we\t->\t470 ye\t->\t470 sea\t->\t455 old\t->\t449 would\t->\t432 "
"other\t->\t427 been\t->\t415 over\t->\t408 these\t->\t405 will\t->\t397 "
"though\t->\t384 its\t->\t381 only\t->\t377 down\t->\t376 such\t->\t375 "
"who\t->\t366 any\t->\t360 yet\t->\t345 head\t->\t344 boat\t->\t333 "
"time\t->\t333 her\t->\t332 long\t->\t330 captain\t->\t327 very\t->\t323 "
"here\t->\t321 about\t->\t317 do\t->\t316 still\t->\t312 than\t->\t311 "
"great\t->\t306 those\t->\t306 said\t->\t303 before\t->\t298 has\t->\t293 "
"must\t->\t293 two\t->\t292 t\t->\t291 most\t->\t285 seemed\t->\t283 </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:412
msgid ""
"Unsurprisingly, <u>whale</u> is the most frequently used noun in this novel, "
"and the second one and third one are <u>ship</u> and <u>sea</u>, "
"respectively."
msgstr ""

#. type: Plain text
#: word-counting/main.html:416
msgid "<h2> Turning stateful functions into stateless templates </h2>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:422
msgid ""
"In the above implementation, the function [char_get] is stateful, that is, "
"it posseses an internal state. If two threads call [char_get] around the "
"same time, then a race-condition may happen. In ATS, we can eliminate a "
"stateful function by turning it into a template. For instance, we can "
"declare [char_get] as follows:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:427
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span><span class=\"keyword\">}</span></span> char_get "
"<span class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:431
msgid ""
"Also, functions that call [char_get] directly or indirectly need to be "
"declared as templates. This means that we need to turn [word_get] and "
"[WordCounting] into templates as well:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:437
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span><span class=\"keyword\">}</span></span> word_get "
"<span class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">stropt</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span><span "
"class=\"keyword\">}</span></span> WordCounting <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">wcmap</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:440
msgid "Now let us declare a function [WordCounting_fileref] as follows:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:445
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> WordCounting_fileref <span "
"class=\"keyword\">(</span>inp<span class=\"keyword\">:</span> <span "
"class=\"staexp\">FILEref</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">wcmap</span></span> </pre>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:448
msgid ""
"which is just variant of [WordCounting] that reads all the words from a "
"given file handle. Then [WordCounting_fileref] can be implemented as "
"follows:"
msgstr ""

#. type: Plain text
#: word-counting/main.html:452
msgid "<pre class=\"patsyntax\"> <span class=\"keyword\">local</span>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:455
msgid ""
"<span class=\"keyword\">staload</span> STDIO <span "
"class=\"keyword\">=</span> \"libc/SATS/stdio.sats\""
msgstr ""

#. type: Plain text
#: word-counting/main.html:457
msgid ""
"<span class=\"keyword\">in</span> <span class=\"comment\">(* in of [local] "
"*)</span>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:467
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"WordCounting_fileref <span class=\"keyword\">(</span>inp<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"char_get&lt;<span class=\"keyword\">&gt;</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> $STDIO<span class=\"keyword\">.</span>fgetc0 "
"<span class=\"keyword\">(</span>inp<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  WordCounting <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[WordCounting_fileref]</span>\n"
msgstr ""

#. type: Plain text
#: word-counting/main.html:473
msgid ""
"It is now safe for two threads to simultaneously call [WordCounting_fileref] "
"on distinct file handles."
msgstr ""

#. type: Plain text
#: word-counting/main.html:477
msgid ""
"A complete running program containing the above implementation of "
"[WordCounting_fileref] can be found in the file wordcnt2.dats, and there is "
"also a Makefile for compiling it."
msgstr ""

#. type: Plain text
#: word-counting/main.html:484
msgid ""
"The template system of ATS is an advanced programming feature that can "
"greatly facilitate code organization and reuse. I will gradually present "
"more progromming examples to illustrate effective use of templates in "
"practice."
msgstr ""

#. type: Plain text
#: word-counting/main.html:488
msgid "<h2> A memory-clean implemenation of word-counting </h2>"
msgstr ""

#. type: Plain text
#: word-counting/main.html:495
msgid ""
"A program is considered a memory-clean implementation if all the dynamically "
"allocated memory is freed immediately before the termination of the "
"program. For instance, if you use <a "
"href=\"http://valgrind.org\">valgrind</a> to monitor an execution of this "
"program, then the gathered statics should indicate that no leak is ever "
"possible."
msgstr ""

#. type: Plain text
#: word-counting/main.html:501
msgid ""
"By making use of linear types, I modified the program in wordcnt.dats to "
"make it a memory-clean implementation. Please see wordcnt_vt.dats for the "
"entirety of the modified version. Also, there is a Makefile for compiling "
"it."
msgstr ""

#. type: Plain text
#: stack-array/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-stack-array</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:36
msgid "<h1> Effective ATS: An Array-Based Stack Implementation </h1>"
msgstr ""

#. type: Plain text
#: stack-array/main.html:46
msgid ""
"ATS advocates a programming paradigm referred to as <em>Programming with "
"Theorem-Proving</em> (PwTP) in which programs and proofs are syntactically "
"intertwined.  As proof construction can be highly expensive in terms of both "
"effort and time, making proper use of unsafe programming features (so as to "
"avoid explicit proof construction) is often a necessary skill for a "
"programmer who wants not just only to be able to code in ATS but also to do "
"it productively. In this article, I would like to present a simple "
"array-based stack implementation in which one can find certain typical uses "
"of unsafe programming features in ATS."
msgstr ""

#. type: Plain text
#: stack-array/main.html:50
msgid "<h2> API for Array-Based Stacks </h2>"
msgstr ""

#. type: Plain text
#: stack-array/main.html:52
msgid "As usual, let us first introduce an abstract type for array-based stacks:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:58
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">absvtype</span> stkarray_vtype <span "
"class=\"keyword\">(</span>a<span class=\"keyword\">:</span><span "
"class=\"keyword\">vt@ype+</span><span class=\"keyword\">,</span> m<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">,</span> n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> ptr</span> </pre>"
msgstr ""

#. type: Plain text
#: stack-array/main.html:60
msgid "We then introduce some shorthands as follows:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:67
msgid ""
"<pre class=\"patsyntax\"> <span class=\"keyword\">stadef</span> <span "
"class=\"staexp\">stkarray <span class=\"keyword\">=</span> <span "
"class=\"staexp\">stkarray_vtype</span></span> <span "
"class=\"keyword\">vtypedef</span> <span class=\"staexp\">stkarray <span "
"class=\"keyword\">(</span><span class=\"staexp\">a<span "
"class=\"keyword\">:</span>vt0p</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"staexp\"><span "
"class=\"keyword\">[</span>m<span class=\"keyword\">,</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">]</span></span> <span "
"class=\"staexp\">stkarray_vtype</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: stack-array/main.html:74
msgid ""
"Given a type T, an integer M and another integer N, the type [stkarray(T, M, "
"N)] is for an array-based stack such that (1) the elements stored in the "
"stack are of type T, (2) the capacity of the stack is M, and (3) the current "
"size of the stack is N.  Clearly, M >= N and N >= 0 holds, and this property "
"is encoded into the type of the following proof function "
"[lemma_stkarray_param]:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:83
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"prfexp\"><span class=\"keyword\">praxi</span>\n"
"lemma_stkarray_param\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"keyword\">(</span><span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">stkarray</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">INV</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">[</span>m &gt;= n<span "
"class=\"keyword\">;</span> n &gt;= 0<span class=\"keyword\">]</span></span> "
"<span class=\"staexp\">void</span></span>\n"
"<span class=\"comment\">// end of [lemma_stkarray_param]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:88
msgid ""
"As always, functions are needed for creating and destroying (linear)  "
"stkarray-values:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:100
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"stkarray_make_cap\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>cap<span class=\"keyword\">:</span> <span "
"class=\"staexp\">size_t</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">m</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:&lt;</span><span "
"class=\"keyword\">!</span><span class=\"staexp\">wrt</span><span "
"class=\"keyword\">&gt;</span> <span class=\"staexp\">stkarray</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">0</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span>\n"
"stkarray_free<span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">stkarray</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">0</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:&lt;</span><span class=\"keyword\">!</span><span "
"class=\"staexp\">wrt</span><span class=\"keyword\">&gt;</span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"comment\">//</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:105
msgid ""
"Given a size M, [stkarray_make_cap] creates an empty stack of capacity M.  "
"As linear elements stored in a stack are leaked after the stack is freed, "
"the type of [stkarray_free] indicates that the function can only be applied "
"to a stack containing no elements."
msgstr ""

#. type: Plain text
#: stack-array/main.html:109
msgid "For inserting an element, we have the following function:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:119
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"stkarray_insert\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int <span "
"class=\"keyword\">|</span> m <span class=\"keyword\">&gt;</span> n<span "
"class=\"keyword\">}</span></span>\n"
"<span class=\"keyword\">(</span>\n"
"  stk<span class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">stkarray</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">stkarray</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> x0<span class=\"keyword\">:</span> <span "
"class=\"staexp\">a</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:&lt;</span><span "
"class=\"keyword\">!</span><span class=\"staexp\">wrt</span><span "
"class=\"keyword\">&gt;</span> <span class=\"staexp\">void</span></span> "
"<span class=\"comment\">// endfun</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:124
msgid ""
"Note that [stkarray_insert] can only be called on a stack if its current "
"size is strictly less than its capacity. The type of [stkarray_insert] "
"states that the size of a stack argument is increased by 1 after an element "
"is inserted into it."
msgstr ""

#. type: Plain text
#: stack-array/main.html:128
msgid "For taking out an element, we have the following function:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:137
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"stkarray_takeout\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int <span "
"class=\"keyword\">|</span> n <span class=\"keyword\">&gt;</span> 0<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"keyword\">(</span>stk<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">stkarray</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">stkarray</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"staexp\">-</span><span class=\"staexp\">1</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:&lt;</span><span class=\"keyword\">!</span><span "
"class=\"staexp\">wrt</span><span class=\"keyword\">&gt;</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">// end of [stkarray_takeout]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:141
msgid ""
"Note that [stkarray_takeout] can only be called on a stack if its current "
"size is positive. The type of [stkarray_takeout] states that the size of a "
"stack is decreased by 1 after an element is taken out of it."
msgstr ""

#. type: Plain text
#: stack-array/main.html:145
msgid "<h2> Implementation of Array-Based Stacks </h2>"
msgstr ""

#. type: Plain text
#: stack-array/main.html:148
msgid ""
"We can use the following 3-pointer struct in C to reprensent an array-based "
"stack:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:157
#, no-wrap
msgid ""
"<pre>\n"
"typedef\n"
"struct {\n"
"  atstype_ptr stkarray_beg ; // the beg pointer\n"
"  atstype_ptr stkarray_end ; // the end pointer\n"
"  atstype_ref stkarray_cur ; // the current pointer\n"
"} atslib_stkarray_struct ;\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:162
msgid ""
"The pointers [stkarray_beg] and [stkarray_end] point to the beginning and "
"end of the base array while the pointer [stkarray_cur] points the top of the "
"current stack. Note that the beginning of the base array is the bottom of "
"the represented stack."
msgstr ""

#. type: Plain text
#: stack-array/main.html:167
msgid ""
"Let us introduce the folllowing two functions for getting and setting the "
"pointer [stkarray_cur]:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:177
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span>\n"
"stkarray_get_ptrcur<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>stk<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">stkarray</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">INV</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:&lt;</span><span "
"class=\"keyword\">&gt;</span> <span class=\"staexp\">ptr</span> <span "
"class=\"keyword\">=</span> \"mac#atslib_stkarray_get_ptrcur\"</span>\n"
"<span class=\"keyword\">extern</span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span>\n"
"stkarray_set_ptrcur<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>stk<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">stkarray</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">INV</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">ptr</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:&lt;</span><span "
"class=\"keyword\">!</span><span class=\"staexp\">wrt</span><span "
"class=\"keyword\">&gt;</span> <span class=\"staexp\">void</span> <span "
"class=\"keyword\">=</span> \"mac#atslib_stkarray_set_ptrcur\"</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:181
msgid ""
"As can be expected, these two functions are to be implemented in C "
"directly. The following implementation of [stkarray_insert] makes use of "
"these two functions as well as an unsafe function of the name [ptr0_set]:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:202
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"stkarray_insert\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">,</span> x0<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> p_cur <span "
"class=\"keyword\">=</span> stkarray_get_ptrcur <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> $UN<span "
"class=\"keyword\">.</span>ptr0_set&lt;<span class=\"staexp\">a</span><span "
"class=\"keyword\">&gt;</span> <span class=\"keyword\">(</span>p_cur<span "
"class=\"keyword\">,</span> x0<span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> "
"stkarray_set_ptrcur <span class=\"keyword\">(</span>stk<span "
"class=\"keyword\">,</span> ptr_succ&lt;<span class=\"staexp\">a</span><span "
"class=\"keyword\">&gt;</span> <span class=\"keyword\">(</span>p_cur<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"__assert <span class=\"keyword\">(</span>stk<span class=\"keyword\">)</span> "
"<span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"<span class=\"keyword\">extern</span> <span class=\"prfexp\"><span "
"class=\"keyword\">praxi</span> __assert <span "
"class=\"keyword\">(</span><span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">stkarray</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">stkarray</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"keyword\">}</span></span> <span class=\"comment\">(* end of "
"[prval] *)</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">in</span>\n"
"  <span class=\"comment\">// nothing</span>\n"
"<span class=\"keyword\">end</span></span></span> <span class=\"comment\">// "
"end of [stkarray_insert]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:211
msgid ""
"Note that [ptr0_set] writes a value (its 2nd argument) to a given memory "
"location (its 1st argument) without requiring a proof (of some at-view)  "
"associated with the location. In other words, [ptr0_set] performs a memory "
"update precisely in the same way as it is done in C. Also note that a proof "
"function [__assert] is introduced so as to make it possible for the "
"implementation to pass typechecking. The keyword [praxi] means that the "
"introduced proof function should be treated as an assertion and no "
"implementation for it is expected."
msgstr ""

#. type: Plain text
#: stack-array/main.html:220
msgid ""
"The following implementation of [stkarray_takeout] makes use of [ptr0_get], "
"which reads through a given pointer without requiring a proof (of some "
"at-view) associated with the location. Also, just like in the implementation "
"of [stkarray_insert], a proof function is asserted for the sole purpose of "
"making the implementation of [stkarray_takeout] pass typechecking."
msgstr ""

#. type: Plain text
#: stack-array/main.html:241
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"stkarray_takeout\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> x0 <span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> p_cur <span "
"class=\"keyword\">=</span> stkarray_get_ptrcur <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> p1_cur <span "
"class=\"keyword\">=</span> ptr_pred&lt;<span class=\"staexp\">a</span><span "
"class=\"keyword\">&gt;</span> <span class=\"keyword\">(</span>p_cur<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> x0 <span "
"class=\"keyword\">=</span> $UN<span "
"class=\"keyword\">.</span>ptr0_get&lt;<span class=\"staexp\">a</span><span "
"class=\"keyword\">&gt;</span> <span class=\"keyword\">(</span>p1_cur<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> stkarray_set_ptrcur <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">,</span> p1_cur<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"__assert <span class=\"keyword\">(</span>stk<span class=\"keyword\">)</span> "
"<span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"<span class=\"keyword\">extern</span> <span class=\"prfexp\"><span "
"class=\"keyword\">praxi</span> __assert <span "
"class=\"keyword\">(</span><span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">stkarray</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">stkarray</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"staexp\">-</span><span "
"class=\"staexp\">1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"keyword\">}</span></span> <span class=\"comment\">(* end of "
"[prval] *)</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">}</span></span> <span class=\"comment\">// end of "
"[stkarray_takeout]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:244
msgid ""
"The C code implementing [stkarray_get_ptrcur] and [stkarray_set_ptrcur] is "
"given below:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:253
#, no-wrap
msgid ""
"<pre>\n"
"ATSinline()\n"
"atstype_ptr\n"
"atslib_stkarray_get_ptrcur\n"
"  (atstype_ptr p)\n"
"{\n"
"  return ((atslib_stkarray_struct*)p)->stkarray_cur ;\n"
"} // end of [atslib_stkarray_get_ptrcur]\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:262
#, no-wrap
msgid ""
"ATSinline()\n"
"atsvoid_t0ype\n"
"atslib_stkarray_set_ptrcur\n"
"  (atstype_ptr p, atstype_ptr p2)\n"
"{\n"
"  ((atslib_stkarray_struct*)p)->stkarray_cur = p2 ; return ;\n"
"} // end of [atslib_stkarray_set_ptrcur]\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:266
msgid ""
"The C-names for [stkarray_get_ptrcur] and [stkarray_set_ptrcur] are chosen "
"to be [atslib_stkarray_get_ptrcur] and [atslib_stkarray_set_ptrcur], "
"respectively."
msgstr ""

#. type: Plain text
#: stack-array/main.html:275
msgid ""
"For more on array-based stack implementation, please see: <a "
"href=\"http://sourceforge.net/p/ats2-lang/code/ci/master/tree/libats/SATS/stkarray.sats\">stkarray.sats</a> "
", <a "
"href=\"http://sourceforge.net/p/ats2-lang/code/ci/master/tree/libats/DATS/stkarray.dats\">stkarray.dats</a> "
", and <a "
"href=\"http://sourceforge.net/p/ats2-lang/code/ci/master/tree/libats/CATS/stkarray.cats\">stkarray.cats</a>."
msgstr ""

#. type: Plain text
#: stack-array/main.html:279
msgid "<h2> Some Stack-Functions of Convenience </h2>"
msgstr ""

#. type: Plain text
#: stack-array/main.html:283
msgid ""
"If a caller attempts to insert an element into a stack that happens to be "
"full, we may require that the element be returned to the caller. The "
"following function [stkarray_insert_opt] does this precisely:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:304
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"stkarray_insert_opt\n"
"  <span class=\"keyword\">(</span>stk<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">stkarray</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">_</span><span class=\"keyword\">,</span> x0<span "
"class=\"keyword\">:</span> <span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:&lt;</span><span "
"class=\"keyword\">!</span><span class=\"staexp\">wrt</span><span "
"class=\"keyword\">&gt;</span> <span class=\"staexp\">Option_vt</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"stkarray_insert_opt\n"
"  <span class=\"keyword\">(</span>stk<span class=\"keyword\">,</span> "
"x0<span class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> isnot <span "
"class=\"keyword\">=</span> stkarray_isnot_full <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> isnot <span class=\"keyword\">then</span> "
"<span class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> stkarray_insert <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">,</span> x0<span "
"class=\"keyword\">)</span></span> <span class=\"keyword\">in</span> "
"None_vt<span class=\"keyword\">(</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"Some_vt<span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">}</span></span><span class=\"keyword\">(</span>x0<span "
"class=\"keyword\">)</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[stkarray_insert_opt]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:309
msgid ""
"Similarly, a caller may attempt to take an element out of a stack that "
"happens to be empty. The following function [stkarray_takeout_opt] returns "
"an optional value so that its caller can tell whether an element has "
"actually been taken out of a given stack:"
msgstr ""

#. type: Plain text
#: stack-array/main.html:330
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"stkarray_takeout_opt\n"
"  <span class=\"keyword\">(</span>stk<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">stkarray</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">_</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:&lt;</span><span class=\"keyword\">!</span><span "
"class=\"staexp\">wrt</span><span class=\"keyword\">&gt;</span> <span "
"class=\"staexp\">Option_vt</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"stkarray_takeout_opt\n"
"  <span class=\"keyword\">(</span>stk<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> isnot <span "
"class=\"keyword\">=</span> stkarray_isnot_nil <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> isnot <span class=\"keyword\">then</span> "
"<span class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x0 <span "
"class=\"keyword\">=</span> stkarray_takeout <span "
"class=\"keyword\">(</span>stk<span class=\"keyword\">)</span></span> <span "
"class=\"keyword\">in</span> Some_vt<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">}</span></span><span "
"class=\"keyword\">(</span>x0<span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"None_vt<span class=\"keyword\">(</span><span "
"class=\"comment\">(*void*)</span><span class=\"keyword\">)</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[stkarray_takeout_opt]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: stack-array/main.html:334
msgid ""
"For some sample code making use of the array-based stack implementation, "
"please see postfix_eval.dats, where an evaluator of arithmetic expressions "
"written in the postfix-notation is coded."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-DiningPhil2</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:36 DiningPhil/main.html:36
msgid "<h1> Effective ATS: Dining Philosophers </h1>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:40
msgid ""
"In this article, I present an implementation of a slight variant of the "
"famous problem of 5-Dining-Philosophers by Dijkstra that makes simple but "
"convincing use of linear types."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:44
msgid "<h2> The Original Problem </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:53 DiningPhil/main.html:54
msgid ""
"There are five philosophers sitting around a table and there are also 5 "
"forks placed on the table such that each fork is located between the left "
"hand of a philosopher and the right hand of another philosopher. Each "
"philosopher does the following routine repeatedly: thinking and dining.  In "
"order to dine, a philosopher needs to first acquire two forks: one located "
"on his left-hand side and the other on his right-hand side. After finishing "
"dining, a philosopher puts the two acquired forks onto the table: one on his "
"left-hand side and the other on his right-hand side."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:57
msgid "<h2> A Variant of the Original Problem </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:59
msgid "The following twist is added to the original version:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:65
msgid ""
"After a fork is used, it becomes a \"dirty\" fork and needs to be put in a "
"tray for dirty forks. There is a cleaner who cleans dirty forks and then "
"puts them back on the table."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:69
msgid "<h2> Channels for Communication </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:73
msgid ""
"A channel is just a shared queue of fixed capacity. The following two "
"functions are for inserting an element into and taking an element out of a "
"given channel:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:79
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> channel_insert <span "
"class=\"keyword\">(</span><span class=\"staexp\">channel</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span> "
"channel_takeout <span class=\"keyword\">(</span>chan<span "
"class=\"keyword\">:</span> <span class=\"staexp\">channel</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:84
msgid ""
"If [channel_insert] is called on a channel that is full, then the caller is "
"blocked until an element is taken out of the channel.  If [channel_takeout] "
"is called on a channel that is empty, then the caller is blocked until an "
"element is inserted into the channel."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:88
msgid "<h2> A Channel for Each Fork </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:91
msgid ""
"Forks are resources given a linear type. Each fork is initially stored in a "
"channel, which can be obtained by calling the following function:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:96
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> fork_changet <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">nphil</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">channel</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">fork</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:103
msgid ""
"where the type [nphil] is defined to be [natLt(5)] (for natural numbers less "
"than 5). The channels for storing forks are chosen to be of capacity 2. The "
"reason that channels of capacity 2 are chosen to store at most one element "
"(in each of them) is to guarantee that these channels can never be full (so "
"that there is no attempt made to send signals to awake callers supposedly "
"being blocked due to channels being full)."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:108
msgid "<h2> A Channel for the Fork Tray </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:111
msgid ""
"A tray for storing \"dirty\" forks is also a channel, which can be obtained "
"by calling the following function:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:116
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> forktray_changet <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">channel</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">fork</span><span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:119
msgid ""
"The capacity chosen for the channel is 6 (instead of 5) so that it can never "
"become full (as there are only 5 forks in total)."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:123
msgid "<h2> Philosopher Loop </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:125
msgid "Each philosopher is implemented as a loop:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:157
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"phil_loop <span class=\"keyword\">(</span>n<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> phil_think <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> nl <span "
"class=\"keyword\">=</span> phil_left <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">)</span></span> <span class=\"comment\">// = n</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> nr <span "
"class=\"keyword\">=</span> phil_right <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">)</span></span> <span class=\"comment\">// = (n+1) % "
"5</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> ch_lfork <span "
"class=\"keyword\">=</span> fork_changet <span "
"class=\"keyword\">(</span>nl<span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> ch_rfork <span "
"class=\"keyword\">=</span> fork_changet <span "
"class=\"keyword\">(</span>nr<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> lf <span "
"class=\"keyword\">=</span> channel_takeout <span "
"class=\"keyword\">(</span>ch_lfork<span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"dynexp\">println!</span> <span "
"class=\"keyword\">(</span><span class=\"dynstr\">\"phil_loop(\"</span><span "
"class=\"keyword\">,</span> n<span class=\"keyword\">,</span> <span "
"class=\"dynstr\">\") picks left fork\"</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> randsleep <span class=\"keyword\">(</span><span "
"class=\"dynexp\">2</span><span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// sleep up to 2 seconds</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> rf <span "
"class=\"keyword\">=</span> channel_takeout <span "
"class=\"keyword\">(</span>ch_rfork<span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"dynexp\">println!</span> <span "
"class=\"keyword\">(</span><span class=\"dynstr\">\"phil_loop(\"</span><span "
"class=\"keyword\">,</span> n<span class=\"keyword\">,</span> <span "
"class=\"dynstr\">\") picks right fork\"</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> phil_dine <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">,</span> lf<span class=\"keyword\">,</span> rf<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> ch_forktray <span "
"class=\"keyword\">=</span> forktray_changet <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> channel_insert <span "
"class=\"keyword\">(</span>ch_forktray<span class=\"keyword\">,</span> "
"lf<span class=\"keyword\">)</span></span> <span class=\"comment\">// left "
"fork to dirty tray</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> channel_insert <span "
"class=\"keyword\">(</span>ch_forktray<span class=\"keyword\">,</span> "
"rf<span class=\"keyword\">)</span></span> <span class=\"comment\">// right "
"fork to dirty tray</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  phil_loop <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[phil_loop]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:159
msgid "It should be straighforward to follow the code for [phil_loop]."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:163
msgid "<h2> Fork Cleaner Loop </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:165
msgid "A cleaner is implemented as a loop:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:181
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"cleaner_loop <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> ch <span "
"class=\"keyword\">=</span> forktray_changet <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> f0 <span "
"class=\"keyword\">=</span> channel_takeout <span "
"class=\"keyword\">(</span>ch<span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// [f0] is dirty</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> cleaner_wash <span "
"class=\"keyword\">(</span>f0<span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// washes dirty [f0]</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> cleaner_return <span "
"class=\"keyword\">(</span>f0<span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// puts back cleaned [f0]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  cleaner_loop <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[cleaner_loop]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:185
msgid ""
"The function [cleaner_return] first finds out the number of a given fork and "
"then uses the number to locate the channel for storing the fork. Its actual "
"implementation is given as follows:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:196
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"cleaner_return <span class=\"keyword\">(</span>f<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> n <span "
"class=\"keyword\">=</span> fork_get_num <span "
"class=\"keyword\">(</span>f<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> ch <span "
"class=\"keyword\">=</span> fork_changet <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> channel_insert <span "
"class=\"keyword\">(</span>ch<span class=\"keyword\">,</span> f<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:198
msgid "It should now be straighforward to follow the code for [cleaner_loop]."
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:202 IPC-redis/main.html:154 DiningPhil/main.html:196
msgid "<h2> Testing </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:204
msgid "The entire code of this implementation is stored in the following files:"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:211
msgid ""
"<pre> DiningPhil2.sats DiningPhil2.dats DiningPhil2_fork.dats "
"DiningPhil2_thread.dats </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil2/main.html:215
msgid ""
"There is also a Makefile available for compiling the ATS source code into an "
"excutable for testing. One should be able to encounter a deadlock after "
"running the simulation for a while."
msgstr ""

#. type: Plain text
#: mergesort/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-mergesort</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:36
msgid "<h1> Effective ATS: Mergesort </h1>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:39
msgid ""
"In this article, I would like to use mergesort as a concrete example to "
"demonstrate a natural style of refinement-based programming."
msgstr ""

#. type: Plain text
#: mergesort/main.html:43
msgid "<h2> What is Mergesort? </h2>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:47
msgid ""
"Let me answer this question by giving a specification-like implementation of "
"mergesort. Suppose that we have a type [myseq] declared as follows for the "
"data that [mergesort] is to be called on:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:52
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abstype</span> myseq</span> </pre>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:54
msgid "Naturally, we assign the following interface to [mergesort]:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:59
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> mergesort <span "
"class=\"keyword\">(</span>xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">myseq</span></span> </pre>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:61
msgid "A straightforward implementation of [mergesort] can be given as follows:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:77
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"mergesort <span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> n <span "
"class=\"keyword\">=</span> myseq_length <span "
"class=\"keyword\">(</span>xs<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"  <span class=\"keyword\">if</span> n &gt;= <span class=\"dynexp\">2</span> "
"<span class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span>xs1<span class=\"keyword\">,</span> xs2<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> myseq_split "
"<span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">in</span>\n"
"    myseq_merge <span class=\"keyword\">(</span>mergesort <span "
"class=\"keyword\">(</span>xs1<span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> mergesort <span "
"class=\"keyword\">(</span>xs2<span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"<span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span> <span "
"class=\"comment\">// end of [if]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[mergesort]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:81
msgid ""
"where the function [myseq_length], [myseq_split] and [myseq_merge] are "
"assigned the following types:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:88
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> myseq_length <span "
"class=\"keyword\">(</span>xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> myseq_split <span "
"class=\"keyword\">(</span>xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">myseq</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">)</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> myseq_merge <span "
"class=\"keyword\">(</span>xs1<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">,</span> xs2<span "
"class=\"keyword\">:</span> <span class=\"staexp\">myseq</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span></span> </pre>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:90
msgid "and their functionalities are briefly explained below:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:96
msgid ""
"<ul> <li> [myseq_length] returns the length of a given myseq-value.  <li> "
"[myseq_split] splits a given myseq-value into two myseq-values.  <li> "
"[myseq_merge] merges two given sorted myseq-values into one sorted "
"myseq-value.  </ul>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:101
msgid ""
"Even for someone who is unfamiliar with the syntax of ATS, it is probably "
"fair to say that the above specification-like implementation of [mergesort] "
"is often preferrable to a description of mergesort in English or other "
"natural langauges."
msgstr ""

#. type: Plain text
#: mergesort/main.html:105
msgid "<h2> Specifying with Dependent Types </h2>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:112
msgid ""
"As the given implementation of mergesort is recursive, there must be a "
"reason why we expect that the implemented function [mergesort] is "
"terminating. Inevitably, we need to talk about the length of a myseq-value "
"if we argue for [mergesort] being terminating, where the length of a "
"myseq-value refers to the number of items contained in the sequence "
"represented by the myseq-value."
msgstr ""

#. type: Plain text
#: mergesort/main.html:117
msgid ""
"In ATS, we can refine [myseq] as follows by making it a type constructor "
"carrying one integer parameter:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:122
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abstype</span> myseq<span class=\"keyword\">(</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:127
msgid ""
"Given a static integer N, [myseq(N)] is for myseq-values of length N.  The "
"type assigned to [mergesort] can be refined as follows to capture the "
"invariant that a given myseq-value and its sorted version have the same "
"length:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:132
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> mergesort<span class=\"staexp\"><span "
"class=\"keyword\">{</span>n<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>xs<span "
"class=\"keyword\">:</span> <span class=\"staexp\">myseq</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">myseq</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:135
msgid ""
"As for the functions [myseq_length], [myseq_split] and [myseq_merge], they "
"can be assigned the following more informative types:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:147
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> myseq_length<span "
"class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> myseq_split<span "
"class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>int <span class=\"keyword\">|</span> n &gt;= "
"2<span class=\"keyword\">}</span></span>\n"
"  <span class=\"keyword\">(</span>xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">[</span>n1<span "
"class=\"keyword\">,</span>n2<span class=\"keyword\">:</span>pos <span "
"class=\"keyword\">|</span> n1+n2==n<span class=\"keyword\">]</span></span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">myseq</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">n1</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n2</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> myseq_merge<span "
"class=\"staexp\"><span class=\"keyword\">{</span>n1<span "
"class=\"keyword\">,</span>n2<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>xs1<span "
"class=\"keyword\">:</span> <span class=\"staexp\">myseq</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">n1</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> xs2<span "
"class=\"keyword\">:</span> <span class=\"staexp\">myseq</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">n2</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">myseq</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">n1</span><span "
"class=\"staexp\">+</span><span class=\"staexp\">n2</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:151
msgid ""
"Note that the type assigned to [myseq_split] implies that this function can "
"only be applied to a given myseq-value containing at least 2 items and the "
"two myseq-values it returns are strictly shorter than the given myseq-value."
msgstr ""

#. type: Plain text
#: mergesort/main.html:156
msgid ""
"The above implementation of [mergesort] can be slightly modified into the "
"following version:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:180
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"mergesort <span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> sort\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>nat<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">.&lt;</span><span class=\"staexp\">n</span><span "
"class=\"keyword\">&gt;.</span>\n"
"<span class=\"keyword\">(</span>\n"
"  xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> n <span "
"class=\"keyword\">=</span> myseq_length <span "
"class=\"keyword\">(</span>xs<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> n &gt;= <span class=\"dynexp\">2</span> "
"<span class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span>xs1<span class=\"keyword\">,</span> xs2<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> myseq_split "
"<span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">in</span>\n"
"    myseq_merge <span class=\"keyword\">(</span>sort <span "
"class=\"keyword\">(</span>xs1<span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> sort <span class=\"keyword\">(</span>xs2<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"<span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span> <span "
"class=\"comment\">// end of [if]</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[sort]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  sort <span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[mergesort]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:183
msgid ""
"Note that [sort] is verified to be terminating based on the termination "
"metric &lt;n&gt; (supplied by the programmer)."
msgstr ""

#. type: Plain text
#: mergesort/main.html:188
msgid ""
"When trying to implement [myseq_split], we should be able to quickly realize "
"that the following interface is much more suitable for it:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:194
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> myseq_split<span "
"class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>int <span class=\"keyword\">|</span> n &gt;= "
"2<span class=\"keyword\">}</span></span>\n"
"  <span class=\"keyword\">(</span>xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">myseq</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">n</span><span "
"class=\"staexp\">/</span><span class=\"staexp\">2</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"staexp\">-</span><span "
"class=\"staexp\">n</span><span class=\"staexp\">/</span><span "
"class=\"staexp\">2</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:199
msgid ""
"The interface states that [myseq_split] returns a pair of myseq-values of "
"length n/2 and n-n/2 when applied to a myseq-value of length n and an "
"integer of value n. The implementation of [mergesort] can now be slightly "
"modified as follows:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:223
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"mergesort <span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> sort\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>n<span "
"class=\"keyword\">:</span>nat<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">.&lt;</span><span class=\"staexp\">n</span><span "
"class=\"keyword\">&gt;.</span>\n"
"<span class=\"keyword\">(</span>\n"
"  xs<span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span> <span class=\"staexp\">n</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">myseq</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> n &gt;= <span class=\"dynexp\">2</span> "
"<span class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> n2 <span "
"class=\"keyword\">=</span> half <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">)</span></span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span>xs1<span class=\"keyword\">,</span> xs2<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> myseq_split "
"<span class=\"keyword\">(</span>xs<span class=\"keyword\">,</span> n<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">in</span>\n"
"    myseq_merge <span class=\"keyword\">(</span>sort <span "
"class=\"keyword\">(</span>xs1<span class=\"keyword\">,</span> n2<span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> sort <span "
"class=\"keyword\">(</span>xs2<span class=\"keyword\">,</span> n-n2<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"<span class=\"keyword\">(</span>xs<span class=\"keyword\">)</span> <span "
"class=\"comment\">// end of [if]</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[sort]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"  sort <span class=\"keyword\">(</span>xs<span class=\"keyword\">,</span> "
"myseq_length<span class=\"keyword\">(</span>xs<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[mergesort]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:227
msgid ""
"We now have a specification-like implementation of mergesort that "
"typechecks, which can be thought of as some form of blueprint intended for "
"implementing mergesort on concrete types such as lists and arrays."
msgstr ""

#. type: Plain text
#: mergesort/main.html:231
msgid "<h2> Mergesort on Lists </h2>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:234
msgid ""
"As can be expected, the interface for mergesort on lists is given as "
"follows:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:240
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>t0p<span "
"class=\"keyword\">}</span></span> mergesort<span class=\"staexp\"><span "
"class=\"keyword\">{</span>n<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>xs<span "
"class=\"keyword\">:</span> <span class=\"staexp\">list</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">list</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:245
msgid ""
"This interface indicates that [mergesort] is a function template "
"parameterized over the type of the elements in a list given as its "
"argument. Let us now focus on [myseq_merge], which is given the following "
"interface:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:254
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>t0p<span class=\"keyword\">}</span></span>\n"
"myseq_merge\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>n1<span "
"class=\"keyword\">,</span>n2<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"keyword\">(</span>xs1<span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> xs2<span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n2</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">list</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n1</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">n2</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">// end of [myseq_merge]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:256
msgid "Following is a straightforward implementation of [myseq_merge] on lists:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:283
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"<span class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span><span class=\"comment\">(*tmp*)</span>\n"
"myseq_merge\n"
"  <span class=\"keyword\">(</span>xs10<span class=\"keyword\">,</span> "
"xs20<span class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">case+</span> xs10 <span "
"class=\"keyword\">of</span>\n"
"<span class=\"keyword\">|</span> cons <span "
"class=\"keyword\">(</span>x1<span class=\"keyword\">,</span> xs11<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span>\n"
"  <span class=\"keyword\">(</span>\n"
"    <span class=\"keyword\">case+</span> xs20 <span "
"class=\"keyword\">of</span>\n"
"    <span class=\"keyword\">|</span> cons <span "
"class=\"keyword\">(</span>x2<span class=\"keyword\">,</span> xs21<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> <span "
"class=\"keyword\">let</span>\n"
"        <span class=\"dynexp\"><span class=\"keyword\">val</span> sgn <span "
"class=\"keyword\">=</span> gcompare_val&lt;<span "
"class=\"staexp\">a</span><span class=\"keyword\">&gt;</span> <span "
"class=\"keyword\">(</span>x1<span class=\"keyword\">,</span> x2<span "
"class=\"keyword\">)</span></span>\n"
"      <span class=\"keyword\">in</span>\n"
"        <span class=\"keyword\">if</span> sgn &lt;= <span "
"class=\"dynexp\">0</span>\n"
"          <span class=\"keyword\">then</span> cons<span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">}</span></span><span class=\"keyword\">(</span>x1<span "
"class=\"keyword\">,</span> myseq_merge&lt;<span "
"class=\"staexp\">a</span><span class=\"keyword\">&gt;</span> <span "
"class=\"keyword\">(</span>xs11<span class=\"keyword\">,</span> xs20<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span>\n"
"          <span class=\"keyword\">else</span> cons<span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">}</span></span><span class=\"keyword\">(</span>x2<span "
"class=\"keyword\">,</span> myseq_merge&lt;<span "
"class=\"staexp\">a</span><span class=\"keyword\">&gt;</span> <span "
"class=\"keyword\">(</span>xs10<span class=\"keyword\">,</span> xs21<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span>\n"
"        <span class=\"comment\">// end of [if]</span>\n"
"      <span class=\"keyword\">end</span> <span class=\"comment\">(* end of "
"[cons] *)</span>\n"
"    <span class=\"keyword\">|</span> nil <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=&gt;</span> xs10\n"
"  <span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">|</span> nil <span class=\"keyword\">(</span><span "
"class=\"comment\">(*void*)</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=&gt;</span> xs20\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[myseq_merge]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:286
msgid ""
"Note that [gcompare_val] is a generic function template for comparing "
"values."
msgstr ""

#. type: Plain text
#: mergesort/main.html:291
msgid ""
"Please find the entirety of the implementation of mergesort on lists plus "
"some testing code in mergesort_list.dats."
msgstr ""

#. type: Plain text
#: mergesort/main.html:295
msgid "<h2> Mergesort on Arrays </h2>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:300
msgid ""
"The abstract specification-like implementation of [mergesort] given above is "
"of so-called functional style. While it is not well-suited for implementing "
"mergesort on arrays (of imperative style), I would still like to give it a "
"try so as to make a point."
msgstr ""

#. type: Plain text
#: mergesort/main.html:306
msgid ""
"First, as an array in ATS is of C-style, there is no size information "
"attached to the array. So the interface for [mergesort] needs to be modified "
"as follows:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:312
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>t0p<span "
"class=\"keyword\">}</span></span> mergesort<span class=\"staexp\"><span "
"class=\"keyword\">{</span>n<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>xs<span "
"class=\"keyword\">:</span> <span class=\"staexp\">arrayref</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> n<span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">arrayref</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:315
msgid ""
"This interface means that [mergesort] takes both an array and the size of "
"the array as its two arguments."
msgstr ""

#. type: Plain text
#: mergesort/main.html:319
msgid "Following is the interface for [myseq_merge] on arrays:"
msgstr ""

#. type: Plain text
#: mergesort/main.html:329
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>t0p<span class=\"keyword\">}</span></span>\n"
"myseq_merge\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>n1<span "
"class=\"keyword\">,</span>n2<span class=\"keyword\">:</span>nat<span "
"class=\"keyword\">}</span></span>\n"
"<span class=\"keyword\">(</span>\n"
"  xs1<span class=\"keyword\">:</span> <span "
"class=\"staexp\">arrayref</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> xs2<span class=\"keyword\">:</span> <span "
"class=\"staexp\">arrayref</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n2</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> n1<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> n2<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">n2</span><span class=\"keyword\">)</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">arrayref</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n1</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">n2</span><span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// end of [myseq_merge]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: mergesort/main.html:336
msgid ""
"There is extensive use of unsafe programming features in my implementation "
"of [myseq_merge] on arrays. Writing code this way is primarily for the "
"purpose of saving some time as the given implementation of mergesort on "
"arrays is not meant for practical use; it is only meant to make a point that "
"the specification-like implementation of [mergesort] given above can indeed "
"be adapted to handle arrays."
msgstr ""

#. type: Plain text
#: mergesort/main.html:341
msgid ""
"Please find the entirety of the implementation of mergesort on arrays plus "
"some testing code in mergesort_array.dats."
msgstr ""

#. type: Plain text
#: mergesort/main.html:345
msgid "<h2> Refinement-based Programming </h2>"
msgstr ""

#. type: Plain text
#: mergesort/main.html:356
msgid ""
"While it may seem a bit too pedantic to implement a simple algorithm like "
"mergesort in the way presented above, I do hope that this style of "
"refinement-based programming should be obviously appealing to anyone wanting "
"to write even moderately complex programs. The manner in which abstract "
"types are supported in ATS is particularly designed under the guideline to "
"maximally promote refinement-based programming. As I see it, the ability to "
"make effective use of abstraction in controlling programming complexity is "
"the most important characteristic of a top programmer, and the type system "
"of ATS can greatly help one acquire this ability.  Have fun!"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-IPC-redis</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:36
msgid "<h1> Effective ATS: Inter-Process Communication based on Redis </h1>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:41
msgid ""
"In this article, I present a straightforward example of inter-process "
"communication based on the NOSQL <a href=\"http://redis.io\">redis</a>.  The "
"primary purpose of this example is to show a concrete case where redis "
"functions are directly called inside ATS code."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:45
msgid "<h2> Message Channels </h2>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:47
msgid "Let us first introduce a type [msgchan] for message channels:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:53
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abstype</span> msgchan_type <span "
"class=\"keyword\">=</span> ptr</span> <span class=\"keyword\">typedef</span> "
"<span class=\"staexp\">msgchan <span class=\"keyword\">=</span> <span "
"class=\"staexp\">msgchan_type</span></span> </pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:55
msgid "The following function is for creating a message channel:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:60
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> msgchan_create <span "
"class=\"keyword\">(</span>name<span class=\"keyword\">:</span> <span "
"class=\"staexp\">string</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">msgchan</span></span> "
"</pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:64
msgid ""
"In the actual implementation, a message channel is just a key referring to a "
"queue in redis, and the function [msgchan_create] computes such a key based "
"on a given name."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:69
msgid ""
"In order to insert a message into a given message channel, the following "
"function [msgchan_insert] can be called:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:75
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> msgchan_insert\n"
"  <span class=\"keyword\">(</span>chan<span class=\"keyword\">:</span> <span "
"class=\"staexp\">msgchan</span><span class=\"keyword\">,</span> msg<span "
"class=\"keyword\">:</span> <span class=\"staexp\">string</span><span "
"class=\"keyword\">,</span> nerr<span class=\"keyword\">:</span> <span "
"class=\"staexp\">&amp;</span><span class=\"staexp\">int</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">_</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:78
msgid ""
"The third argument of [msgchan_insert] is call-by-reference, and its value "
"is increased to indicate a failed attempt to insert a message."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:83
msgid ""
"In order to take out a message for a given message channel, the following "
"function [msgchan_takeout] can be called:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:88
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> msgchan_takeout <span "
"class=\"keyword\">(</span>chan<span class=\"keyword\">:</span> <span "
"class=\"staexp\">msgchan</span><span class=\"keyword\">,</span> nerr<span "
"class=\"keyword\">:</span> <span class=\"staexp\">&amp;</span><span "
"class=\"staexp\">int</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">_</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">stropt</span></span> "
"</pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:95
msgid ""
"The second argument of [msgchan_takeout] is call-by-reference, and its value "
"is increased to indicate a failed attempt to take out a message. What "
"[msgchan_takeout] returns is an optional string, which is either a regular "
"string or a null pointer. In case a null pointer is returned, it is also an "
"indication of failure of some sort.  Note that a call to [msgchan_takeout] "
"on a given channel is blocked if the channel is currently empty."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:101
msgid ""
"If calling [msgchan_insert] or [msgchan_takeout] on a channel results in a "
"failure, then the redis connection associated with the channel should be "
"re-established before a second attempt is made."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:105
msgid "<h2> Redis Connection </h2>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:112
msgid ""
"To set up a redis connection means to create a value of the type "
"[redisContext(l)], where l refers to the memory location at which the value "
"is stored.  Let us use the name redisContext-value to refer to such a "
"value.  In case a redis connection cannot be set up successfully, the type "
"[redisContext(null)] is assigned to the created redisContext-value, which is "
"just a null pointer."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:119
msgid ""
"Once a redis connection is established, the redisContext-value associated "
"with this connection is stored in a reference (that is, an array of size "
"1).  The following function can be called to obtain the stored "
"redisContext-value (for temporary use):"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:124
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> the_redisContext_vtget <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">[</span>l<span class=\"keyword\">:</span>addr<span "
"class=\"keyword\">]</span></span> <span class=\"staexp\">vttakeout0</span> "
"<span class=\"keyword\">(</span><span "
"class=\"staexp\">redisContext</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">l</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:126
msgid "where [vttakeout0] is defined as follows:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:132
msgid ""
"<pre class=\"patsyntax\"> <span class=\"keyword\">vtypedef</span> <span "
"class=\"staexp\">vttakeout0 <span class=\"keyword\">(</span><span "
"class=\"staexp\">a<span class=\"keyword\">:</span><span "
"class=\"keyword\">vt@ype</span></span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span> <span class=\"keyword\">-&lt;</span><span "
"class=\"staexp\">lin</span><span class=\"keyword\">,</span><span "
"class=\"staexp\">prf</span><span class=\"keyword\">&gt;</span> <span "
"class=\"staexp\">void</span> <span class=\"keyword\">|</span> <span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// borrowed linear value</span> </pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:134
msgid "The following code depicts a typical calling sequence:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:145
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"prfexp\">fpf</span> <span "
"class=\"keyword\">|</span> ctx<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> the_redisContext_vtget <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span></span> <span "
"class=\"comment\">//</span> <span class=\"comment\">// Here is some code "
"that makes use of [ctx]</span> <span class=\"comment\">//</span> <span "
"class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> fpf <span class=\"keyword\">(</span>ctx<span "
"class=\"keyword\">)</span></span> <span class=\"comment\">// returning the "
"borrowed context</span> <span class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:150
msgid ""
"where [the_redisContext_vtget] is called to obtain a redisContext-value and "
"a proof function for returning this value, and the proof function is then "
"called on the redisContext-value to return it (in the sense of "
"theorem-proving)  after its being used."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:157
msgid ""
"The ATS code implementing message channels can be found in the following "
"files:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:163
msgid "<pre> msgchan.sats msgchan.dats redisContextSetup.dats </pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:166
msgid ""
"In the file [test_up.dats], some testing code is available for uploading the "
"content of a file into a message channel."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:171
msgid ""
"In the file [test_dn.dats], some testing code is available for downloading "
"the content of a message channel into a file."
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:178
msgid ""
"There is also a Makefile available for compiling the ATS source code into "
"excutables [test_up] and [test_dn] for testing. Assume the availability of a "
"redis server running on the default port 6379 at the IP address 127.0.0.1.  "
"By executing the following command-line:"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:182
msgid "<pre> cat msgchan.sats | ./test_up & ./test_dn </pre>"
msgstr ""

#. type: Plain text
#: IPC-redis/main.html:187
msgid ""
"one should be able to see the content of the file [msgchan.sats] being "
"output to the console in a line-by-line fashion, where a short pause (of 3 "
"seconds at most) is introduced between the appearance of two consecutive "
"lines."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:28 Producer-Consumer/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-Producer-Consumer</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:36
msgid "<h1> Effective ATS: Readers-and-Writers </h1>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:41
msgid ""
"In general, ATS shines much more brightly in contexts where dynamic testing "
"becomes more difficult to perform and/or control.  In this article, I "
"present in ATS an implementation of the classical Readers-and-Writers "
"problem in concurrent programming."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:45 DiningPhil/main.html:45 Producer-Consumer/main.html:50
msgid "<h2> Description of the Problem </h2>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:52
msgid ""
"The Readers-and-Writers problem models access to a database.  In order for a "
"process to read from the database, the process must be granted a "
"read-access. In order for it to write to the database, it must be granted a "
"write-access.  It is not allowed for a read-access and a write-access to be "
"granted at the same time.  While multiple read-accesses can be granted "
"simultaneously, only one write-access can be granted at a time."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:56
msgid "<h2> Interface for Database Access </h2>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:58
msgid "Following is an abstract interface for accessing database:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:71
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"staexp\"><span class=\"keyword\">abstype</span> DB <span "
"class=\"keyword\">=</span> ptr</span> <span class=\"comment\">//</span> "
"<span class=\"staexp\"><span class=\"keyword\">absview</span> "
"DBread_v</span> <span class=\"staexp\"><span "
"class=\"keyword\">absview</span> DBwrite_v</span> <span "
"class=\"comment\">//</span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> DBread <span class=\"keyword\">(</span><span "
"class=\"prfexp\">pf<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBread_v</span></span> <span class=\"keyword\">|</span> "
"db<span class=\"keyword\">:</span> <span class=\"staexp\">DB</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> DBwrite <span class=\"keyword\">(</span><span "
"class=\"prfexp\">pf<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBwrite_v</span></span> <span class=\"keyword\">|</span> "
"db<span class=\"keyword\">:</span> <span class=\"staexp\">DB</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:76
msgid ""
"For calling [DBread] to read from a database, a proof of the (abstract) view "
"[DBread_v] is needed.  For calling [DBwrite] to write to a database, a proof "
"of the (abstract) view [DBwrite_v] is needed."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:80
msgid "<h2> Databases-with-state </h2>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:83
msgid ""
"Let us introduce a linear abstract type [DBshell] for a database with some "
"linear state:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:93
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"staexp\"><span class=\"keyword\">absvtype</span> DBshell <span "
"class=\"keyword\">(</span>r<span class=\"keyword\">:</span> int<span "
"class=\"keyword\">,</span> w<span class=\"keyword\">:</span> int<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> ptr</span> <span "
"class=\"comment\">//</span> <span class=\"keyword\">vtypedef</span> <span "
"class=\"staexp\">DBshell <span class=\"keyword\">=</span> <span "
"class=\"staexp\"><span class=\"keyword\">[</span>r<span "
"class=\"keyword\">,</span>w<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">]</span></span> <span class=\"staexp\">DBshell</span> "
"<span class=\"keyword\">(</span><span class=\"staexp\">r</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">w</span><span "
"class=\"keyword\">)</span></span> <span class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:98
msgid ""
"Given integer r and w, a value of the type [DBshell(r, w)] is referred to as "
"a database-with-state in which the associated database is currently granting "
"r read-accesses and w write-accesses. The following two proof functions "
"mention explicitly some constraints on parameters r and w:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:110
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">praxi</span>\n"
"lemma_DBshell_param\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">,</span>w<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span><span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBshell</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">r</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">w</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">[</span>0 &lt;= r<span "
"class=\"keyword\">;</span> 0 &lt;= w<span class=\"keyword\">;</span> w &lt;= "
"1<span class=\"keyword\">]</span></span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">praxi</span>\n"
"lemma_DBshell_param2\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">,</span>w<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span><span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBshell</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">r</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">w</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">[</span>r == 0 || <span "
"class=\"keyword\">(</span>r <span class=\"keyword\">&gt;</span> 0 &amp;&amp; "
"w == 0<span class=\"keyword\">)</span><span "
"class=\"keyword\">]</span></span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"comment\">//</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:115
msgid ""
"Given a type [DBshell(r, w)], the proof function [lemma_DBshell_param] "
"states that r is a natural number and w is between 0 and 1, inclusive; the "
"proof function [lemma_DBshell_param2] states that w must equal 0 if r is "
"positive."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:119
msgid "Some functions on databases-with-state are listed as follows:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:129
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> DBshell_dbget <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBshell</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">DB</span></span> <span "
"class=\"comment\">//</span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> DBshell_nread <span class=\"staexp\"><span "
"class=\"keyword\">{</span>r<span class=\"keyword\">,</span>w<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBshell</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">r</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">w</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">r</span><span class=\"keyword\">)</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> DBshell_nwrite <span "
"class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">,</span>w<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>x<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">DBshell</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">r</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">w</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">int</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">w</span><span "
"class=\"keyword\">)</span></span> <span class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:134
msgid ""
"Clearly, [DBshell_dbget] is meant to return the database associated with a "
"given database-with-state. As for [DBshell_nread] and [DBshell_nwrite], they "
"can be called on a database-with-state of type [DBshell(r, w)] to obtain the "
"values of r and w, respectively."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:138
msgid "<h2> Encoding the Policy for Database Access </h2>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:141
msgid ""
"The policy for database access is formally encoded in the types of the "
"following declared function:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:156
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"DBshell_acquire_read\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBshell</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">r</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">0</span><span class=\"keyword\">)</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">DBshell</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">r</span><span "
"class=\"staexp\">+</span><span class=\"staexp\">1</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">0</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">DBread_v</span> <span class=\"keyword\">|</span> <span "
"class=\"staexp\">void</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"DBshell_release_read\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">,</span>w<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span><span "
"class=\"prfexp\">pf<span class=\"keyword\">:</span> <span "
"class=\"staexp\">DBread_v</span></span> <span class=\"keyword\">|</span> "
"x<span class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">DBshell</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">r</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">w</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">DBshell</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">r</span><span class=\"staexp\">-</span><span "
"class=\"staexp\">1</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">w</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"DBshell_acquire_write\n"
"  <span class=\"keyword\">(</span>x<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">DBshell</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">0</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">0</span><span class=\"keyword\">)</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">DBshell</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">0</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">1</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">DBwrite_v</span> <span class=\"keyword\">|</span> <span "
"class=\"staexp\">void</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"DBshell_release_write\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">,</span>w<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span><span "
"class=\"prfexp\">pf<span class=\"keyword\">:</span> <span "
"class=\"staexp\">DBwrite_v</span></span> <span class=\"keyword\">|</span> "
"x<span class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">DBshell</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">r</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">w</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">DBshell</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">r</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">w</span><span class=\"staexp\">-</span><span "
"class=\"staexp\">1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"comment\">//</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:164
msgid ""
"A proof of the view [DBread_v] is needed for reading from a database.  In "
"order to obtain it, [DBshell_acquire_read] needs to be called on a "
"database-with-state that is currently granting no write-access.  Similarly, "
"a proof of the view [DBwrite_v] is needed for writing to a database.  In "
"order to obtain it, [DBshell_acquire_write] needs to be called on a "
"database-with-state that is currently granting neither read-access nor "
"write-access."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:168
msgid "<h2> Shared Databases-with-state </h2>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:173
msgid ""
"A shared database-with-state essentially wraps a protection mechanism around "
"a database-with-state. Let introduce a non-linear abstract type [SDBshell] "
"for shared databases-with-state:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:178
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abstype</span> SDBshell <span class=\"keyword\">=</span> "
"ptr</span> </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:182
msgid ""
"As can be expected, there is a mutex for protecting the database-with-state "
"inside a shared database-with-state.  The following two functions can be "
"called to acquire/release the protected database-with-state:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:188
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> SDBshell_acquire <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">DBshell</span></span> "
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> SDBshell_release "
"<span class=\"keyword\">(</span>sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\">DBshell</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:190
msgid "Let us now see an implementation of the following declared functions:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:201
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> SDBshell_acquire_read "
"<span class=\"keyword\">(</span>sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">DBread_v</span> <span class=\"keyword\">|</span> <span "
"class=\"staexp\">void</span><span class=\"keyword\">)</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> SDBshell_release_read "
"<span class=\"keyword\">(</span><span class=\"prfexp\">pf<span "
"class=\"keyword\">:</span> <span class=\"staexp\">DBread_v</span></span> "
"<span class=\"keyword\">|</span> sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> <span "
"class=\"comment\">//</span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> SDBshell_acquire_write <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">DBwrite_v</span> <span class=\"keyword\">|</span> <span "
"class=\"staexp\">void</span><span class=\"keyword\">)</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> SDBshell_release_write "
"<span class=\"keyword\">(</span><span class=\"prfexp\">pf<span "
"class=\"keyword\">:</span> <span class=\"staexp\">DBwrite_v</span></span> "
"<span class=\"keyword\">|</span> sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> <span "
"class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:204
msgid ""
"which can be called to safely support database access in concurrent "
"programming (without causing race conditions)."
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:211
msgid ""
"There is a conditional variable (CV) inside a shared database-with-state.  "
"The following function [SDBshell_wait_read] can be called by a process to "
"wait on the CV if it wants to read but the database is currently granting a "
"write-access to another process:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:223
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"SDBshell_wait_read\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span>\n"
"<span class=\"keyword\">(</span>\n"
"  sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">DBshell</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">r</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">1</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">DBshell</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"comment\">// end of "
"[SDBshell_wait_read]</span>\n"
"<span class=\"comment\">//</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:228
msgid ""
"Similarly, the following function [SDBshell_wait_write] can be called by a "
"process to wait on the CV if it wants to write but the database is currently "
"granting a read-access or write-access to another process:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:238
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"SDBshell_wait_write\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>r<span "
"class=\"keyword\">,</span>w<span class=\"keyword\">:</span>int <span "
"class=\"keyword\">|</span> r+w &gt;= 1<span "
"class=\"keyword\">}</span></span>\n"
"<span class=\"keyword\">(</span>\n"
"  sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">DBshell</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">r</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">w</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">DBshell</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"comment\">// end of "
"[SDBshell_wait_write]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:241
msgid ""
"In order to wake up a process waiting on the conditional variable, the "
"following function [SDBshell_signal] can be called:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:248
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"keyword\">extern</span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> SDBshell_signal <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> <span "
"class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:251
msgid ""
"Furthermore, two auxiliary functions are declared as follows to facilitate "
"the implementation of [SDBshell_acquire_read] and [SDBshell_acquire_write]:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:261
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"SDBshell_acquire_read2\n"
"  <span class=\"keyword\">(</span>sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">DBshell</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">_</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">DBread_v</span> <span "
"class=\"keyword\">|</span> <span class=\"staexp\">void</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"SDBshell_acquire_write2\n"
"  <span class=\"keyword\">(</span>sx<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SDBshell</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">DBshell</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">_</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">DBwrite_v</span> <span "
"class=\"keyword\">|</span> <span class=\"staexp\">void</span><span "
"class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:263
msgid "The following code implements [SDBshell_acquire_read]:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:274
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SDBshell_acquire_read\n"
"  <span class=\"keyword\">(</span>sx<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">(</span><span "
"class=\"prfexp\">pf</span> <span class=\"keyword\">|</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x <span "
"class=\"keyword\">=</span> SDBshell_acquire <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"prfexp\">pf</span> <span "
"class=\"keyword\">|</span> <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_acquire_read2 <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_release <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:294
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SDBshell_acquire_read2\n"
"  <span class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"  lemma_DBshell_param <span class=\"keyword\">(</span>x<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> w <span "
"class=\"keyword\">=</span> DBshell_nwrite <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> w <span class=\"keyword\">=</span> <span "
"class=\"dynexp\">0</span>\n"
"  <span class=\"keyword\">then</span> DBshell_acquire_read <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">else</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_wait_read <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span> <span class=\"keyword\">in</span> "
"SDBshell_acquire_read2 <span class=\"keyword\">(</span>sx<span "
"class=\"keyword\">,</span> x<span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[else]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[SDBshell_acquire_read2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:296
msgid "The following code implements [SDBshell_release_read]:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:313
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SDBshell_release_read\n"
"  <span class=\"keyword\">(</span><span class=\"prfexp\">pf</span> <span "
"class=\"keyword\">|</span> sx<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x <span "
"class=\"keyword\">=</span> SDBshell_acquire <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> DBshell_release_read <span "
"class=\"keyword\">(</span><span class=\"prfexp\">pf</span> <span "
"class=\"keyword\">|</span> x<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> r <span "
"class=\"keyword\">=</span> DBshell_nread <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"    <span class=\"keyword\">if</span> r <span class=\"keyword\">=</span> "
"<span class=\"dynexp\">0</span>\n"
"      <span class=\"keyword\">then</span> SDBshell_signal <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">)</span></span>\n"
"    <span class=\"comment\">// end of [if]</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_release <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:315
msgid "The following code implements [SDBshell_acquire_write]:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:326
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SDBshell_acquire_write\n"
"  <span class=\"keyword\">(</span>sx<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">(</span><span "
"class=\"prfexp\">pf</span> <span class=\"keyword\">|</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x <span "
"class=\"keyword\">=</span> SDBshell_acquire <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"prfexp\">pf</span> <span "
"class=\"keyword\">|</span> <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_acquire_write2 <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_release <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:359
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SDBshell_acquire_write2\n"
"  <span class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"  lemma_DBshell_param <span class=\"keyword\">(</span>x<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"  lemma_DBshell_param2 <span class=\"keyword\">(</span>x<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> r <span "
"class=\"keyword\">=</span> DBshell_nread <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> r <span class=\"keyword\">=</span> <span "
"class=\"dynexp\">0</span>\n"
"  <span class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> w <span "
"class=\"keyword\">=</span> DBshell_nwrite <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">in</span>\n"
"    <span class=\"keyword\">if</span> w <span class=\"keyword\">=</span> "
"<span class=\"dynexp\">0</span>\n"
"      <span class=\"keyword\">then</span> DBshell_acquire_write <span "
"class=\"keyword\">(</span>x<span class=\"keyword\">)</span>\n"
"      <span class=\"keyword\">else</span> <span "
"class=\"keyword\">let</span>\n"
"        <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_wait_write <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"      <span class=\"keyword\">in</span>\n"
"        SDBshell_acquire_write2 <span class=\"keyword\">(</span>sx<span "
"class=\"keyword\">,</span> x<span class=\"keyword\">)</span>\n"
"      <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[else]</span>\n"
"    <span class=\"comment\">// end of [if]</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[then]</span>\n"
"  <span class=\"keyword\">else</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_wait_write <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span> <span class=\"keyword\">in</span> "
"SDBshell_acquire_write2 <span class=\"keyword\">(</span>sx<span "
"class=\"keyword\">,</span> x<span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[else]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[SDBshell_acquire_write2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:361
msgid "The following code implements [SDBshell_release_write]:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:374
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SDBshell_release_write\n"
"  <span class=\"keyword\">(</span><span class=\"prfexp\">pf</span> <span "
"class=\"keyword\">|</span> sx<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x <span "
"class=\"keyword\">=</span> SDBshell_acquire <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> DBshell_release_write <span "
"class=\"keyword\">(</span><span class=\"prfexp\">pf</span> <span "
"class=\"keyword\">|</span> x<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_signal <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SDBshell_release <span "
"class=\"keyword\">(</span>sx<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:378 DiningPhil/main.html:180
msgid "<h2> Summary of the Remaining Implementation </h2>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:380
msgid "Please find the entirety of the code in the following files:"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:385
msgid "<pre> DB_read_write.sats DB_read_write.dats </pre>"
msgstr ""

#. type: Plain text
#: Readers-and-Writers/main.html:389
msgid ""
"Instead of being coded in C directly, the rest of my implementation is also "
"written in ATS but it makes pervasive use of some unsafe programming "
"features."
msgstr ""

#. type: Plain text
#: file-copying/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-file-copying</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: file-copying/main.html:36
msgid "<h1> Effective ATS: Copying Files </h1>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:39
msgid ""
"While the task of copying files is conceptually simple, it can still be "
"quite interesting to implement it in ATS."
msgstr ""

#. type: Plain text
#: file-copying/main.html:43
msgid "<h2> Attempt One </h2>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:49
msgid ""
"In order to copy the content of one file into another, we need a means to "
"refer to the involved files. In Linux, the notion of file descriptor serves "
"precisely this purpose. Although we know that a file descriptor is "
"represented as an integer, it seems appropriate to make it abstract as is "
"done in the following declaration:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:54
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abst@ype</span> fildes <span class=\"keyword\">=</span> "
"int</span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:58
msgid ""
"Often it is a good practice to give a name to an abstract type that is less "
"likely to cause collision and then introduce a short alias for the name.  "
"For instance, the following declarations demonstrate such a practice:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:64
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abst@ype</span> fildes_t0ype <span "
"class=\"keyword\">=</span> int</span> <span class=\"keyword\">stadef</span> "
"<span class=\"staexp\">fildes<span class=\"keyword\">:</span> <span "
"class=\"keyword\">t@ype</span> <span class=\"keyword\">=</span> <span "
"class=\"staexp\">fildes_t0ype</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:68
msgid ""
"My naming convention uses the special identifier [t0ype] to indicate a type "
"of the sort t@ype, that is, a type of unknown size. Note that the "
"stadef-declaration can also be replaced with the following one:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:73
msgid ""
"<pre class=\"patsyntax\"> <span class=\"keyword\">typedef</span> <span "
"class=\"staexp\">fildes <span class=\"keyword\">=</span> <span "
"class=\"staexp\">fildes_t0ype</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:76
msgid ""
"Now let us name the file-copying function [fcopy1] and give it the following "
"interface:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:81
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> fcopy1 <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fildes</span><span "
"class=\"keyword\">,</span> dst<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:84
msgid ""
"How should we implement [fcopy1]? For the moment, let us try to answer this "
"question in a somewhat abstract manner."
msgstr ""

#. type: Plain text
#: file-copying/main.html:90
msgid ""
"Clearly, we should be able to read chars from [src] and also write chars "
"into [dst]. So let us assume that the following two functions are available "
"for use:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:96
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> readch <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fildes</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">char</span></span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> writech <span "
"class=\"keyword\">(</span>src<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> c<span "
"class=\"keyword\">:</span> <span class=\"staexp\">char</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:102
msgid ""
"There is yet one more thing: We should be able to tell whether we have "
"finished reading all the chars from a given file. One simple way to do this "
"is to require that [readch] return a special value to indicate the end of a "
"file being reached. For this purpose, we modify the interface of [readch] as "
"follows:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:107
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> readch <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fildes</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:111
msgid ""
"We use natural numbers, that is, non-negative integers for valid chars and a "
"negative integer (e.g., -1) for the special value (indicating that the end "
"of [src] is reached). We can now readily implement [fcopy1] as follows:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:125
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"fcopy1 <span class=\"keyword\">(</span>src<span class=\"keyword\">,</span> "
"dst<span class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> c <span "
"class=\"keyword\">=</span> readch <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> c &gt;= <span class=\"dynexp\">0</span> "
"<span class=\"keyword\">then</span>\n"
"  <span class=\"keyword\">(</span>writech <span "
"class=\"keyword\">(</span>dst<span class=\"keyword\">,</span> c<span "
"class=\"keyword\">)</span><span class=\"keyword\">;</span> fcopy1 <span "
"class=\"keyword\">(</span>src<span class=\"keyword\">,</span> dst<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span>\n"
"<span class=\"comment\">// end of [if]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">(* end of "
"[fcopy1] *)</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: file-copying/main.html:131
msgid ""
"At this point, the obviously question is: How can functions [readch] and "
"[writech] be implemented? They can be implemented based on the system calls "
"[read] and [write]. Please find a completed running implementation of "
"file-copying based on [fcopy1] in fcopy1.dats, where [readch] and [writech] "
"are implemented in C directly."
msgstr ""

#. type: Plain text
#: file-copying/main.html:145
msgid ""
"Of course, there is a lot of criticism that can be laid upon the above "
"implementation of file-copying. For instance, it is terribly inefficient; it "
"does not support any error-handling at all; etc. I will attempt to address "
"these issues in the following presentation. However, one thing that is "
"extremely positive about this implementation is the introduction of "
"functions [readch] and [writech], which adds a layer to shield system calls "
"[read] and [write] from being used directly. This is a programming style I "
"would recommend highly and repeatedly. What seems really unfortunate to me "
"is that popular books on systems programming (e.g. <a "
"href=\"http://www.apuebook.com/\">APUE</a>) often do very little, if at all, "
"to advocate this very useful programming style!"
msgstr ""

#. type: Plain text
#: file-copying/main.html:149
msgid "<h2> Attempt Two </h2>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:157
msgid ""
"Obviously, [fcopy1] is very inefficient for copying files as it calls [read] "
"and [write] each time to read and write only one char, respectively.  If "
"multiple chars are to be read at once, then a buffer (that is, some memory) "
"must be made available to store them. As it is largely straightforward to "
"handle only cases where such a buffer is statically allocated, I will focus "
"on a solution that can also cope with dynamically allocated buffers."
msgstr ""

#. type: Plain text
#: file-copying/main.html:159
msgid "Let us first introduce an abstract type for buffers:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:165
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">absvtype</span> buffer_vtype <span "
"class=\"keyword\">=</span> ptr</span> <span "
"class=\"keyword\">vtypedef</span> <span class=\"staexp\">buffer <span "
"class=\"keyword\">=</span> <span class=\"staexp\">buffer_vtype</span></span> "
"</pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:169
msgid ""
"Actually, [buffer_vtype] is introduced as a viewtype, that is, a linear "
"type, and the following functions are for creating and destroying a buffer, "
"respectively:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:175
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> buffer_create <span "
"class=\"keyword\">(</span>m<span class=\"keyword\">:</span> <span "
"class=\"staexp\">size_t</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">buffer</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> buffer_destroy <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">:</span> <span "
"class=\"staexp\">buffer</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:178
msgid ""
"As we also need to test whether a buffer contains any data or not, let us "
"introduce the following function for this purpose:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:183
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> buffer_isnot_empty <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:187
msgid ""
"In addition, let us use the names [readbuf] and [writebuf] for functions "
"reading and writing multiple chars, respectively, and assign to them the "
"following types:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:193
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> readbuf <span "
"class=\"keyword\">(</span>src<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> buf<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">buffer</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> writebuf <span "
"class=\"keyword\">(</span>dst<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> buf<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">buffer</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:197
msgid ""
"Let [fcopy2] be given the same interface as [fcopy1].  The following code "
"gives a straightforward implementation of [fcopy2] based on [readbuf] and "
"[writebuf]:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:225
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"fcopy2 <span class=\"keyword\">(</span>src<span class=\"keyword\">,</span> "
"dst<span class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> loop\n"
"<span class=\"keyword\">(</span>\n"
"  src<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> dst<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fildes</span><span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> readbuf <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> isnot <span "
"class=\"keyword\">=</span> buffer_isnot_empty <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> isnot <span "
"class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> writebuf <span class=\"keyword\">(</span>dst<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">)</span></span> <span "
"class=\"keyword\">in</span> loop <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">,</span> dst<span class=\"keyword\">,</span> buf<span "
"class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"<span class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"comment\">// end of [if]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[loop]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> buf <span "
"class=\"keyword\">=</span>\n"
"  buffer_create <span class=\"keyword\">(</span>i2sz<span "
"class=\"keyword\">(</span>BUFSZ<span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> loop <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">,</span> dst<span class=\"keyword\">,</span> buf<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> buffer_destroy <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">in</span>\n"
"  <span class=\"comment\">// nothing</span>\n"
"<span class=\"keyword\">end</span></span></span> <span class=\"comment\">(* "
"end of [fcopy2] *)</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: file-copying/main.html:231
msgid ""
"Note that [BUFSZ] is a compile-time integer constant and [i2sz] is a "
"cast-function for casting an integer of the type [int] to one of the type "
"[size_t].  Please find the code of a completed running implementation of "
"file-copying based on [fcopy2] in fcopy2.dats, where [readbuf] and "
"[writebuf] are implemented in C directly."
msgstr ""

#. type: Plain text
#: file-copying/main.html:235
msgid "<h2> Attempt Three </h2>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:240
msgid ""
"While the inefficiency of [fcopy1] is addressed in the implementation of "
"[fcopy2], the absence of error-handling is not. I now give another "
"implementation of file-copying and address the issue of error-handling in "
"this implementation."
msgstr ""

#. type: Plain text
#: file-copying/main.html:246
msgid ""
"Clearly, a call to [read] or [write] can fail due to a variety of reasons.  "
"If such a failure occurs, we should probably stop file-copying and report an "
"error. Let us introduce another file-copying function [fcopy3] as follows:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:251
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> fcopy3 <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fildes</span><span "
"class=\"keyword\">,</span> dst<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> nerr<span "
"class=\"keyword\">:</span> <span class=\"staexp\">&amp;</span><span "
"class=\"staexp\">int</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:258
msgid ""
"The third argument [nerr] of [fcopy3] is a call-by-reference integer. In "
"other words, what is passed as the third argument of [fcopy3] is the address "
"of a left-value. If an error caused by [read] or [write] occurs during "
"file-copying, then the value of the integer stored in [nerr] should be "
"increased. To achieve this, we can modify the types of [readbuf] and "
"[writebuf] as follows:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:264
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> readbuf <span "
"class=\"keyword\">(</span>src<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> buf<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">buffer</span><span "
"class=\"keyword\">,</span> nerr<span class=\"keyword\">:</span> <span "
"class=\"staexp\">&amp;</span><span class=\"staexp\">int</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> writebuf <span "
"class=\"keyword\">(</span>dst<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> buf<span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">buffer</span><span "
"class=\"keyword\">,</span> nerr<span class=\"keyword\">:</span> <span "
"class=\"staexp\">&amp;</span><span class=\"staexp\">int</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: file-copying/main.html:270
msgid ""
"The function [readbuf] calls [read]; if this call reports an error, then "
"[readbuf] should increase the value of the integer stored in its third "
"argument. The function [writebuf] does the same with [write].  The following "
"code gives an implementation of [fcopy3] similar to that of [fcopy2]:"
msgstr ""

#. type: Plain text
#: file-copying/main.html:300
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"fcopy3 <span class=\"keyword\">(</span>src<span class=\"keyword\">,</span> "
"dst<span class=\"keyword\">,</span> nerr<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> loop\n"
"<span class=\"keyword\">(</span>\n"
"  src<span class=\"keyword\">:</span> <span "
"class=\"staexp\">fildes</span><span class=\"keyword\">,</span> dst<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fildes</span><span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span><span class=\"keyword\">,</span> nerr<span "
"class=\"keyword\">:</span> <span class=\"staexp\">&amp;</span><span "
"class=\"staexp\">int</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> nerr0 <span "
"class=\"keyword\">=</span> nerr</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> readbuf <span class=\"keyword\">(</span>src<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">,</span> nerr<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> isnot <span "
"class=\"keyword\">=</span> buffer_isnot_empty <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"  <span class=\"keyword\">if</span> isnot <span "
"class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> writebuf <span class=\"keyword\">(</span>dst<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">,</span> nerr<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">in</span>\n"
"    <span class=\"keyword\">if</span> nerr <span class=\"keyword\">=</span> "
"nerr0 <span class=\"keyword\">then</span> loop <span "
"class=\"keyword\">(</span>src<span class=\"keyword\">,</span> dst<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">,</span> nerr<span "
"class=\"keyword\">)</span> <span class=\"keyword\">else</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*error*)</span><span "
"class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> "
"<span class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"comment\">// end of [if]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[loop]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> buf <span "
"class=\"keyword\">=</span> buffer_create <span "
"class=\"keyword\">(</span>i2sz<span class=\"keyword\">(</span>BUFSZ<span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> loop <span "
"class=\"keyword\">(</span>src<span class=\"keyword\">,</span> dst<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">,</span> nerr<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> buffer_destroy "
"<span class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">in</span>\n"
"  <span class=\"comment\">// nothing</span>\n"
"<span class=\"keyword\">end</span></span></span> <span class=\"comment\">(* "
"end of [fcopy3] *)</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: file-copying/main.html:305
msgid ""
"Note that the loop function exits whenever an error due to [read] or [write] "
"is reported.  Please find the code of a completed running implementation of "
"file-copying based on [fcopy3] in fcopy3.dats, where [readbuf] and "
"[writebuf] are implemented in C directly."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:28
#, no-wrap
msgid ""
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\" />\n"
"<title>EFFECTIVATS-DiningPhil</title>\n"
"<style type=\"text/css\">\n"
"  .patsyntax {color:#808080;background-color:#E0E0E0;}\n"
"  .patsyntax span.keyword {color:#000000;font-weight:bold;}\n"
"  .patsyntax span.comment {color:#787878;font-style:italic;}\n"
"  .patsyntax span.extcode {color:#A52A2A;}\n"
"  .patsyntax span.neuexp  {color:#800080;}\n"
"  .patsyntax span.staexp  {color:#0000F0;}\n"
"  .patsyntax span.prfexp  {color:#603030;}\n"
"  .patsyntax span.dynexp  {color:#F00000;}\n"
"  .patsyntax span.stalab  {color:#0000F0;font-style:italic}\n"
"  .patsyntax span.dynlab  {color:#F00000;font-style:italic}\n"
"  .patsyntax span.dynstr  {color:#008000;font-style:normal}\n"
"  .patsyntax span.stacstdec  {text-decoration:none;}\n"
"  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}\n"
"  .patsyntax span.dyncstdec  {text-decoration:none;}\n"
"  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}\n"
"  .patsyntax span.dyncst_implement  "
"{color:#B80000;text-decoration:underline;}\n"
"</style>\n"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:41
msgid ""
"The three most distinguished features of ATS are dependent types, linear "
"types, and localizable templates. In this article, I present an "
"implementation of the famous problem of 5-Dining-Philosophers by Dijkstra "
"that makes simple but convincing use of linear types."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:58
msgid "<h2> A Linear Type for Resources </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:60
msgid "First, let us introduce a type definition as follows:"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:65
msgid ""
"<pre class=\"patsyntax\"> <span class=\"keyword\">typedef</span> <span "
"class=\"staexp\">phil <span class=\"keyword\">=</span> <span "
"class=\"staexp\">int</span></span> </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:68
msgid ""
"The sole purpose of using [phil] instead of [int] as the type for "
"philosophers is to make the presented code easier to follow."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:73
msgid ""
"The forks mentioned in the description of the problem refer to shared "
"resources. Let us next introduce a linear abstract type for the forks:"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:78
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">absvt@ype</span> fork <span class=\"keyword\">=</span> "
"int</span> </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:85
msgid ""
"This declaration means that [fork] is an abstract viewtype (that is, a "
"linear abstract type) whose size equals the size of [int].  Please note that "
"the information on [fork] and [int] being of the same size is not available "
"until after typechecking when abstract types are replaced with concrete "
"types."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:90
msgid ""
"For a philosopher to acquire and release his left fork, the following "
"functions can be called:"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:96
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> phil_acquire_lfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">phil</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">fork</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> phil_release_lfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">phil</span><span class=\"keyword\">,</span> f<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fork</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:99
msgid ""
"For a philosopher to acquire and release his right fork, the following "
"functions can be called:"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:105
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> phil_acquire_rfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">phil</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">fork</span></span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> phil_release_rfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">phil</span><span class=\"keyword\">,</span> f<span "
"class=\"keyword\">:</span> <span class=\"staexp\">fork</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:111
msgid ""
"As forks are shared resources, these functions for acquiring and releasing "
"forks should in general involve some sort of locking mechanism. If a fork is "
"acquired, then it should be released after its use. By assigning a linear "
"type to forks, we can rely on the type system of ATS to keep track of forks, "
"ensuring their being handled properly."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:115
msgid "<h2> Philosopher Implemented as a Loop </h2>"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:118
msgid ""
"According to the description of the problem, we implement a loop as follows "
"to simulate a philosopher:"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:131
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> phil_loop <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">phil</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"phil_loop <span class=\"keyword\">(</span>n<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> phil_think <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> phil_dine <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"  phil_loop <span class=\"keyword\">(</span>n<span "
"class=\"keyword\">)</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[phil_loop]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:134
msgid ""
"The function [phil_think], which requires no resources, can be implemented "
"as follows:"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:145
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> phil_think <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">phil</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"phil_think <span class=\"keyword\">(</span>n<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span>\n"
"<span class=\"keyword\">(</span>\n"
"  randsleep <span class=\"keyword\">(</span><span "
"class=\"dynexp\">10</span><span class=\"keyword\">)</span> <span "
"class=\"comment\">// for sleeping up to 10 secs</span>\n"
"<span class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:148
msgid ""
"The function [phil_dine], which involves acquiring and releasing resources, "
"can be implemented as follows:"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:169
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"keyword\">extern</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> phil_dine <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">:</span> <span "
"class=\"staexp\">phil</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"phil_dine <span class=\"keyword\">(</span>n<span class=\"keyword\">)</span> "
"<span class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> lf <span "
"class=\"keyword\">=</span> phil_acquire_lfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> randsleep <span class=\"keyword\">(</span><span "
"class=\"dynexp\">1</span><span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// for sleeping up to 1 secs</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> rf <span "
"class=\"keyword\">=</span> phil_acquire_rfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> randsleep <span class=\"keyword\">(</span><span "
"class=\"dynexp\">3</span><span class=\"keyword\">)</span></span> <span "
"class=\"comment\">// for sleeping up to 3 secs</span>\n"
"<span class=\"comment\">//</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> phil_release_lfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">,</span> lf<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> phil_release_rfork <span "
"class=\"keyword\">(</span>n<span class=\"keyword\">,</span> rf<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">in</span>\n"
"  <span class=\"comment\">// nothing</span>\n"
"<span class=\"keyword\">end</span></span></span> <span class=\"comment\">// "
"end of [phil_dine]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:176
msgid ""
"Note that both [lf] and [rf] are assigned the linear type [fork], making "
"them linear values. As every linear value must be consumed in some way or "
"returned, removing the call to [phil_release_lfork] (or "
"[phil_release_rfork]) causes a type-error that can be readily detected "
"during typechecking. This is a great advantage of assigning linear types to "
"values representing resources."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:192
msgid ""
"If we run [phil_loop] on 5 threads, then we can employ 5 mutexes to protect "
"5 forks (one for each). We can also employ one mutex to protect 5 forks and "
"then introduce some conditional variables to avoid busy-waiting. Instead, "
"the implementation given here runs [phil_loop] on 5 processes (which are "
"created by invoking the system call [fork]) and calls [mmap] to obtain "
"memory for storing the 5 forks shared by these processes. It creates a lock "
"based on the underlining file system to protect these forks and inserts "
"sleeps of random length to avoid complete busy-waiting. This style of "
"implementation is chosen primarily for the purpose of a demo. The interested "
"reader is encouraged to give a thread-based implementation that employs "
"mutexes and possibly conditional variables."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:202
msgid ""
"Note that each philosopher in the given implementation picks first his left "
"fork and then his right fork. In the case where everyone of them holds a "
"fork on his left hand, a deadlock occurs. A simple way to avoid such a "
"deadlock is to have a philosopher (among the 5) who picks first his right "
"fork and then his left fork."
msgstr ""

#. type: Plain text
#: DiningPhil/main.html:209
msgid ""
"The problem of 5-Dining-Philosphers was precisely introduced to study "
"deadlocks and deadlock avoidance. If one tests the given implementation, he "
"or she should likely to see a deadlock occurring in a few minutes. Please "
"use the command [kill] to remove all of the deadlocked processes."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:36
msgid "<h1> Effective ATS: Producer-Consumer </h1>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:46
msgid ""
"The Producer-Consumer problem is a classical one in concurrent programming.  "
"In this article, I present an implementation of this problem that makes "
"highly effective use of dependent types and linear types.  Due to great "
"difficulty in debugging concurrent programs, relying on static checking to "
"detect and fix bugs is of much more significance in concurrent programing "
"than in sequential programming.  While the style of programming I employ "
"here may take time for one to master, the great advantages it brings can be "
"readily appreciated. In general, ATS shines much more brightly in contexts "
"where dynamic testing becomes more difficult to perform and/or control."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:57
msgid ""
"Given a buffer of finite capacity, there are multiple producers who insert "
"items into the buffer and also multiple consumers who take out items from "
"the buffer. If a producer wants to insert an item but the buffer is full, "
"the producer is blocked until the buffer becomes not full. If a consumer "
"wants to take out an item but the buffer is empty, then the consumer is "
"blocked until the buffer is not empty."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:61
msgid "<h2> Interface for Linear Buffer </h2>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:63
msgid "Let us first declare as follows a linear abstract type for buffers:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:76
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"staexp\"><span class=\"keyword\">absvtype</span> buffer_vtype <span "
"class=\"keyword\">(</span>a<span class=\"keyword\">:</span><span "
"class=\"keyword\">vt@ype+</span><span class=\"keyword\">,</span> m<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">,</span> n<span "
"class=\"keyword\">:</span> int<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> ptr</span> <span class=\"comment\">//</span> "
"<span class=\"keyword\">vtypedef</span> <span class=\"staexp\">buffer <span "
"class=\"keyword\">(</span><span class=\"staexp\">a<span "
"class=\"keyword\">:</span>vt0p</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"staexp\"><span "
"class=\"keyword\">[</span>m<span class=\"keyword\">,</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">]</span></span> <span "
"class=\"staexp\">buffer_vtype</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"keyword\">)</span></span> <span "
"class=\"keyword\">vtypedef</span> <span class=\"staexp\">buffer <span "
"class=\"keyword\">(</span><span class=\"staexp\">a<span "
"class=\"keyword\">:</span>vt0p</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m<span class=\"keyword\">:</span>int</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n<span "
"class=\"keyword\">:</span>int</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"staexp\">buffer_vtype</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span></span> <span class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:81
msgid ""
"Given a type T and two integers M and N, the type [buffer(T, M, N)] is for a "
"buffer of capacity M in which N elements of the type T are stored.  The "
"following lemma can be used to establish the property that M >= N and N >= 0 "
"(for the purpose of constraint-solving):"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:88
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"prfexp\"><span class=\"keyword\">praxi</span>\n"
"lemma_buffer_param<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span><span class=\"keyword\">(</span><span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">[</span>m &gt;= n<span class=\"keyword\">;</span> n &gt;= "
"0<span class=\"keyword\">]</span></span> <span "
"class=\"staexp\">void</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:91
msgid ""
"The function [buffer_make_nil] can be called to create a linear buffer of a "
"given capacity that contains no elements:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:97
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> buffer_make_nil<span "
"class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">:</span>pos<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>cap<span class=\"keyword\">:</span> <span "
"class=\"staexp\">int</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">0</span><span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:100
msgid ""
"The functions [buffer_isnil] and [buffer_isful] can be called to test "
"whether a given buffer is empty and full, respectively:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:108
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> buffer_isnil<span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span><span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">n</span><span "
"class=\"staexp\">==</span><span class=\"staexp\">0</span><span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> buffer_isful<span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span><span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">m</span><span "
"class=\"staexp\">==</span><span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:111
msgid ""
"The function [buffer_insert] is for inserting an element into a buffer that "
"is not full:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:120
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"buffer_insert<span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int <span "
"class=\"keyword\">|</span> n <span class=\"keyword\">&lt;</span> m<span "
"class=\"keyword\">}</span></span>\n"
"<span class=\"keyword\">(</span>\n"
"  <span class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"staexp\">+</span><span "
"class=\"staexp\">1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> x<span class=\"keyword\">:</span> <span "
"class=\"staexp\">a</span>\n"
"<span class=\"keyword\">)</span> <span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"comment\">// end of "
"[buffer_insert]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:123
msgid ""
"The function [buffer_insert] is for taking out an element from a buffer that "
"is not empty:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:130
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span>\n"
"buffer_takeout<span class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">,</span>n<span class=\"keyword\">:</span>int <span "
"class=\"keyword\">|</span> n <span class=\"keyword\">&gt;</span> 0<span "
"class=\"keyword\">}</span></span>\n"
"  <span class=\"keyword\">(</span>buf<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">m</span><span "
"class=\"keyword\">,</span> <span class=\"staexp\">n</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">n</span><span class=\"staexp\">-</span><span "
"class=\"staexp\">1</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:134
msgid "<h2> Interface for Shared Buffer </h2>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:140
msgid ""
"In terms of implementation, a shared buffer wraps a protection mechanism "
"around a linear buffer that consists of a mutex and two conditional "
"variables. The mutex is for protecting the linear buffer and the conditional "
"variables are introduced to avoid busy-waiting. I will present more details "
"on the protection mechanism later."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:144
msgid "Let us now introduce an abstract type for shared buffers:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:154
msgid ""
"<pre class=\"patsyntax\"> <span class=\"comment\">//</span> <span "
"class=\"staexp\"><span class=\"keyword\">abstype</span> sbuffer_type <span "
"class=\"keyword\">(</span>a<span class=\"keyword\">:</span><span "
"class=\"keyword\">vt@ype</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> ptr</span> <span class=\"comment\">//</span> "
"<span class=\"keyword\">typedef</span> <span class=\"staexp\">sbuffer <span "
"class=\"keyword\">(</span><span class=\"staexp\">a<span "
"class=\"keyword\">:</span>vt0p</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"staexp\">sbuffer_type</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span></span> <span class=\"comment\">//</span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:160
msgid ""
"Please note that [sbuffer] is a non-linear type. This means that a shared "
"buffer cannot be freed explicitly after its creation. It is also possible to "
"make [sbuffer] a reference-counted linear type so that a shared buffer can "
"be freed. The interested reader is encouraged to give this alternative "
"design a try, which should only lead to slightly more involved "
"implementation."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:165
msgid ""
"Given a linear buffer, [sbuffer_make_buffer] turns it into a shared buffer "
"(by wrapping a protection mechanism around it):"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:171
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> sbuffer_make_buffer <span "
"class=\"keyword\">(</span><span class=\"staexp\">buffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">sbuffer</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:174
msgid "The function [sbuffer_insert] inserts an element into a shared buffer:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:180
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> sbuffer_insert <span "
"class=\"keyword\">(</span><span class=\"staexp\">sbuffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"comment\">// called by "
"producer</span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:183
msgid ""
"Note that a call to [sbuffer_insert] may be blocked due to the linear buffer "
"inside the shared buffer being full."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:188
msgid "The function [sbuffer_takeout] takes out an element from a shared buffer:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:194
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> sbuffer_takeout <span "
"class=\"keyword\">(</span>sbuf<span class=\"keyword\">:</span> <span "
"class=\"staexp\">sbuffer</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span></span> <span class=\"comment\">// called by "
"consumer</span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:197
msgid ""
"Note that a call to [sbuffer_takeout] may be blocked due to the linear "
"buffer inside the shared buffer being empty."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:201
msgid "<h2> Implementation of Shared Buffer </h2>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:203
msgid "The linear buffer inside a shared buffer is protected by a mutex."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:208
msgid ""
"The function [sbuffer_acquire] is for acquiring the linear buffer inside a "
"given shared buffer:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:213
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> sbuffer_acquire<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">:</span> <span class=\"staexp\">sbuffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">buffer</span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:216
msgid ""
"The function [sbuffer_release] is for releasing a linear buffer (to the same "
"shared buffer from which the linear buffer was previously acquired):"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:221
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> sbuffer_release<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">:</span> <span class=\"staexp\">sbuffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> buf<span "
"class=\"keyword\">:</span> <span class=\"staexp\">buffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:224
msgid "Let us now declare two functions as follows:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:232
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> sbuffer_insert2 <span "
"class=\"keyword\">(</span><span class=\"staexp\">sbuffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">_</span><span class=\"keyword\">,</span> x<span "
"class=\"keyword\">:</span> <span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span> sbuffer_takeout2 <span "
"class=\"keyword\">(</span>sbf<span class=\"keyword\">:</span> <span "
"class=\"staexp\">sbuffer</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">INV</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span> <span class=\"staexp\">&gt;&gt;</span> <span "
"class=\"staexp\">_</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:237
msgid ""
"A call to the function [sbuffer_insert2] tries to insert an element into a "
"given linear buffer. In the case where the linear buffer is full, the caller "
"is blocked to wait on some conditional variable until it is notified that "
"the linear buffer is no longer full."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:244
msgid ""
"A call to the function [sbuffer_takeout2] tries to take out an element from "
"a given linear buffer. In the case where the linear buffer is empty, the "
"caller is blocked to wait on some conditional variable until it is notified "
"that the linear buffer is no longer empty."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:249
msgid ""
"It is straightforward to implement [sbuffer_insert] and [sbuffer_takeout] "
"based on [sbuffer_insert2] and [sbuffer_takeout2], respectively:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:259
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"sbuffer_insert <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">,</span> x<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> buf <span "
"class=\"keyword\">=</span> sbuffer_acquire <span "
"class=\"keyword\">(</span>sbuf<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> sbuffer_insert2 "
"<span class=\"keyword\">(</span>sbuf<span class=\"keyword\">,</span> "
"buf<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> sbuffer_release "
"<span class=\"keyword\">(</span>sbuf<span class=\"keyword\">,</span> "
"buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:268
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"sbuffer_takeout <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> x <span "
"class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> buf <span "
"class=\"keyword\">=</span> sbuffer_acquire <span "
"class=\"keyword\">(</span>sbuf<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> x<span "
"class=\"comment\">(*a*)</span> <span class=\"keyword\">=</span> "
"sbuffer_takeout2 <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> sbuffer_release "
"<span class=\"keyword\">(</span>sbuf<span class=\"keyword\">,</span> "
"buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:274
msgid ""
"There are two conditional variables (CVs) inside a shared buffer.  One of "
"them is for handling the condition of the linear buffer (inside the shared "
"buffer) being empty, and the other CV is for handling the condition of the "
"linear buffer being full. The following functions are implemented directly "
"based on these two conditional variables:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:289
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span>\n"
"sbuffer_wait_isnil\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">sbuffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">0</span><span class=\"keyword\">)</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">buffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"sbuffer_signal_isnil<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>m<span class=\"keyword\">,</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>sbuf<span class=\"keyword\">:</span> <span "
"class=\"staexp\">sbuffer</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span>\n"
"sbuffer_wait_isful\n"
"  <span class=\"staexp\"><span class=\"keyword\">{</span>a<span "
"class=\"keyword\">:</span>vt0p<span class=\"keyword\">}</span></span><span "
"class=\"staexp\"><span class=\"keyword\">{</span>m<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span><span class=\"staexp\">sbuffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">buffer</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">,</span> <span "
"class=\"staexp\">m</span><span class=\"keyword\">)</span> <span "
"class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">buffer</span><span "
"class=\"keyword\">(</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"sbuffer_signal_isful<span class=\"staexp\"><span "
"class=\"keyword\">{</span>a<span class=\"keyword\">:</span>vt0p<span "
"class=\"keyword\">}</span></span><span class=\"staexp\"><span "
"class=\"keyword\">{</span>m<span class=\"keyword\">,</span>n<span "
"class=\"keyword\">:</span>int<span class=\"keyword\">}</span></span> <span "
"class=\"keyword\">(</span>sbuf<span class=\"keyword\">:</span> <span "
"class=\"staexp\">sbuffer</span><span class=\"keyword\">(</span><span "
"class=\"staexp\">a</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>\n"
"<span class=\"comment\">//</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:297
msgid ""
"The type assigned to the function [sbuffer_wait_isnil] means that its caller "
"must have possession of a linear buffer when calling it and the caller "
"should still have possession of the linear buffer, which may be empty, when "
"the call returns. The reason for the linear buffer being still empty at the "
"moment when a call to [sbuffer_wait_isnil] returns is that other callers "
"(consumers) may have gained access to the linear buffer earlier."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:302
msgid ""
"The type assigned to the function [sbuffer_wait_isful] can be explained "
"similarly."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:308
msgid "<h4> Implementing [sbuffer_insert2] </h4>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:310
msgid "An implementation of [sbuffer_insert2] is given as follows:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:341
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"sbuffer_insert2\n"
"  <span class=\"keyword\">(</span>sbuf<span class=\"keyword\">,</span> "
"buf<span class=\"keyword\">,</span> x<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> isful <span "
"class=\"keyword\">=</span> buffer_isful <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> lemma_buffer_param <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> isful\n"
"  <span class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"      sbuffer_wait_isful <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">)</span></span>\n"
"    <span class=\"comment\">// end of [val]</span>\n"
"  <span class=\"keyword\">in</span>\n"
"    sbuffer_insert2 <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[then]</span>\n"
"  <span class=\"keyword\">else</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> isnil <span "
"class=\"keyword\">=</span> buffer_isnil <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> buffer_insert "
"<span class=\"keyword\">(</span>buf<span class=\"keyword\">,</span> x<span "
"class=\"keyword\">)</span></span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">if</span> isnil <span class=\"keyword\">then</span> "
"sbuffer_signal_isnil <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">in</span>\n"
"    <span class=\"comment\">// nothing</span>\n"
"  <span class=\"keyword\">end</span></span> <span class=\"comment\">// end "
"of [else]</span>\n"
"<span class=\"comment\">//  </span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[sbuffer_insert2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:346
msgid ""
"The code should be self-explaining. Please note that inserting an element "
"into an empty buffer requires a signal to be sent to the CV handling the "
"condition of buffer being empty. If this is not done, then a deadlock may "
"occur as the consumers waiting on the CV can never be awakened."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:350
msgid "<h4> Implementing [sbuffer_takeout2] </h4>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:379
#, no-wrap
msgid ""
"<pre\n"
"class=\"patsyntax\">\n"
"<span class=\"dynexp\"><span class=\"keyword\">implement</span><span "
"class=\"keyword\">{</span><span class=\"staexp\">a</span><span "
"class=\"keyword\">}</span>\n"
"sbuffer_takeout2\n"
"  <span class=\"keyword\">(</span>sbuf<span class=\"keyword\">,</span> "
"buf<span class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"dynexp\"><span class=\"keyword\">val</span> isnil <span "
"class=\"keyword\">=</span> buffer_isnil <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"prfexp\"><span class=\"keyword\">prval</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> lemma_buffer_param <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> isnil\n"
"  <span class=\"keyword\">then</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span>\n"
"      sbuffer_wait_isnil <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">)</span></span>\n"
"    <span class=\"comment\">// end of [val]</span>\n"
"  <span class=\"keyword\">in</span>\n"
"    sbuffer_takeout2 <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">,</span> buf<span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[then]</span>\n"
"  <span class=\"keyword\">else</span> x <span "
"class=\"keyword\">where</span>\n"
"  <span class=\"keyword\">{</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> isful <span "
"class=\"keyword\">=</span> buffer_isful <span "
"class=\"keyword\">(</span>buf<span class=\"keyword\">)</span></span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> x<span "
"class=\"comment\">(*a*)</span> <span class=\"keyword\">=</span> "
"buffer_takeout <span class=\"keyword\">(</span>buf<span "
"class=\"keyword\">)</span></span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"comment\">(*void*)</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">if</span> isful <span class=\"keyword\">then</span> "
"sbuffer_signal_isful <span class=\"keyword\">(</span>sbuf<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">}</span> <span class=\"comment\">(* end of [else] "
"*)</span>\n"
"<span class=\"comment\">//  </span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[sbuffer_takeout2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:384
msgid ""
"The code should be self-explaining. Please note that taking out an element "
"from a full buffer requires a signal to be sent to the CV handling the "
"condition of buffer being full. If this is not done, then a deadlock may "
"occur as the producers waiting on the CV can never be awakened."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:388
msgid "<h4> Summary of the Remaining Implementation </h4>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:393
msgid ""
"The remaining implementation of the producer-consumer problem can be readily "
"done in C (based on pthread support for mutexes and conditional "
"variables). For instance, [sbuffer] can be represented as a pointer to a "
"value of the following struct type:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:403
#, no-wrap
msgid ""
"<pre>\n"
"struct\n"
"{\n"
"  void *buffer ;\n"
"  mutex_t mutex ;\n"
"  cond_t CVisnil ;\n"
"  cond_t CVisful ;\n"
"}\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:412
msgid ""
"Instead of being coded in C directly, the rest of my implementation is also "
"written in ATS but it makes pervasive use of some unsafe programming "
"features. Please find the entirety of the code in the files sbuffer.sats and "
"sbuffer.dats. There is no testing code in my implementation as I feel highly "
"confident about its correctness. A primary reason for programming in ATS is "
"that one can make effective use of types in ATS so as to convince oneself "
"that his or her code should perform as expected. I feel that I have done it "
"in this case."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:416
msgid "<h2> Safe Programming with Shared Resources </h2>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:420
msgid ""
"In the rest of the article, I would like to outline a general approach to "
"safe programming with shared resources that can be seen as a generalization "
"of the implementation of the producer-consumer problem presented above."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:424
msgid "Suppose we have a linear type [Resource] for values that we want to share:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:429
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">absvtype</span> Resource</span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:433
msgid ""
"Let us introduce a (non-linear) type [SharedResource] for values that are "
"formed by wrapping some kind of protection mechnism around linear values of "
"the type [Resource]:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:438
msgid ""
"<pre class=\"patsyntax\"> <span class=\"staexp\"><span "
"class=\"keyword\">abstype</span> SharedResource</span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:440
msgid "The function that does the wrapping can be given the following type:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:445
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> SharedResource_create <span "
"class=\"keyword\">(</span>R<span class=\"keyword\">:</span> <span "
"class=\"staexp\">Resource</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span "
"class=\"staexp\">SharedResource</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:449
msgid ""
"The linear resource inside a shared resource is protected by a lock, and the "
"following two functions are for taking out the linear resource and returning "
"it back:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:455
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> SharedResource_acquire <span "
"class=\"keyword\">(</span>SR<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SharedResource</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">Resource</span></span> "
"<span class=\"dynexp\"><span class=\"keyword\">fun</span> "
"SharedResource_release <span class=\"keyword\">(</span>SR<span "
"class=\"keyword\">:</span> <span class=\"staexp\">SharedResource</span><span "
"class=\"keyword\">,</span> R<span class=\"keyword\">:</span> <span "
"class=\"staexp\">Resource</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:458
msgid ""
"Let us now assume that we have the following function for processing a "
"linear resource:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:463
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> Resource_process <span "
"class=\"keyword\">(</span>R<span class=\"keyword\">:</span> <span "
"class=\"staexp\"><span class=\"keyword\">!</span></span><span "
"class=\"staexp\">Resource</span> <span class=\"staexp\">&gt;&gt;</span> "
"<span class=\"staexp\">_</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">bool</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:467
msgid ""
"If a call to [Resource_process] returns true, then the resource has been "
"processed properly. Otherwise, it is an indication that the state of the "
"resource needs to be changed before it is suitable for processing."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:471
msgid "What we want to implement is the following function:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:476
msgid ""
"<pre class=\"patsyntax\"> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> SharedResource_process <span "
"class=\"keyword\">(</span>SR<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SharedResource</span><span class=\"keyword\">)</span><span "
"class=\"keyword\">:</span> <span class=\"staexp\">void</span></span> </pre>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:479
msgid ""
"When called on a shared resource, [SharedResource_process] tries to process "
"the linear resource inside it by calling [Resource_process]."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:483
msgid "An implementation of [SharedResource_process] is sketched as follows:"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:488
msgid ""
"<pre class=\"patsyntax\"> <span class=\"keyword\">extern</span> <span "
"class=\"dynexp\"><span class=\"keyword\">fun</span> SharedResource_process2 "
"<span class=\"keyword\">(</span>SR<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SharedResource</span><span class=\"keyword\">,</span> "
"R<span class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">Resource</span> "
"<span class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">_</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:497
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SharedResource_process\n"
"  <span class=\"keyword\">(</span>SR<span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> <span class=\"keyword\">(</span><span "
"class=\"keyword\">)</span> <span class=\"keyword\">where</span>\n"
"<span class=\"keyword\">{</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> R <span "
"class=\"keyword\">=</span> SharedResource_acquire <span "
"class=\"keyword\">(</span>SR<span class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SharedResource_process2 <span "
"class=\"keyword\">(</span>SR<span class=\"keyword\">,</span> R<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SharedResource_release <span "
"class=\"keyword\">(</span>SR<span class=\"keyword\">,</span> R<span "
"class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">}</span></span>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:500
msgid ""
"<span class=\"keyword\">extern</span> <span class=\"dynexp\"><span "
"class=\"keyword\">fun</span> SharedResource_wait <span "
"class=\"keyword\">(</span>SR<span class=\"keyword\">:</span> <span "
"class=\"staexp\">SharedResource</span><span class=\"keyword\">,</span> "
"R<span class=\"keyword\">:</span> <span class=\"staexp\"><span "
"class=\"keyword\">!</span></span><span class=\"staexp\">Resource</span> "
"<span class=\"staexp\">&gt;&gt;</span> <span class=\"staexp\">_</span><span "
"class=\"keyword\">)</span><span class=\"keyword\">:</span> <span "
"class=\"staexp\">void</span></span>"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:522
#, no-wrap
msgid ""
"<span class=\"dynexp\"><span class=\"keyword\">implement</span>\n"
"SharedResource_process2\n"
"  <span class=\"keyword\">(</span>SR<span class=\"keyword\">,</span> R<span "
"class=\"keyword\">)</span> <span class=\"keyword\">=</span> <span "
"class=\"keyword\">let</span>\n"
"  <span class=\"dynexp\"><span class=\"keyword\">val</span> ans <span "
"class=\"keyword\">=</span> Resource_process <span "
"class=\"keyword\">(</span>R<span class=\"keyword\">)</span></span>\n"
"<span class=\"keyword\">in</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">if</span> ans\n"
"  <span class=\"keyword\">then</span>\n"
"  <span class=\"keyword\">(</span>\n"
"    <span class=\"comment\">// processing is done properly</span>\n"
"    <span class=\"comment\">// there may be a need to send signals</span>\n"
"    <span class=\"comment\">// to some conditional variables</span>\n"
"  <span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">else</span> <span class=\"keyword\">let</span>\n"
"    <span class=\"dynexp\"><span class=\"keyword\">val</span> <span "
"class=\"keyword\">(</span><span class=\"keyword\">)</span> <span "
"class=\"keyword\">=</span> SharedResource_wait <span "
"class=\"keyword\">(</span>SR<span class=\"keyword\">,</span> R<span "
"class=\"keyword\">)</span></span>\n"
"  <span class=\"keyword\">in</span>\n"
"    SharedResource_process2 <span class=\"keyword\">(</span>SR<span "
"class=\"keyword\">,</span> R<span class=\"keyword\">)</span>\n"
"  <span class=\"keyword\">end</span> <span class=\"comment\">// end of "
"[else]</span>\n"
"<span class=\"comment\">//</span>\n"
"<span class=\"keyword\">end</span></span> <span class=\"comment\">// end of "
"[SharedResource_process2]</span>\n"
"</pre>\n"
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:527
msgid ""
"A call to [SharedResource_wait] puts the caller on the waiting-list of some "
"conditional variable to avoid busy-waiting. Whenever the condition needed "
"for [Resource_process] to do proper processing is met, a signal should be "
"sent to the conditional variable (by another caller)."
msgstr ""

#. type: Plain text
#: Producer-Consumer/main.html:532
msgid ""
"Please find in the file SharedResource.dats the entirety of the code "
"presented in this section."
msgstr ""
